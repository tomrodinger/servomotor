#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "stm32g0xx_hal.h"
#include "../firmware/Src/ADC.h"
#include "leds.h"
#include "error_handling.h"
#include "debug_uart.h"
#include <math.h>
#include "motor_hal.h"
#include "hall_sensor_calculations.h"

#define ENCODER_ROTATIONS_PER_SHAFT_ROTATION (TOTAL_NUMBER_OF_SEGMENTS / N_HALL_SENSORS / 2)
#define SUPPLY_VOLTAGE_CALIBRATION_CONSTANT 23664
#define HALL_SENSOR_SINE_AMPLITUDE (1500 / 4)
#define HALL_SENSOR_SINE_OFFSET (HALL_SENSOR_SHIFT * 2 * 2 / 4 / 16) // Our ADC is 12 bits and the hall sensor voltage has a nominal value about half way of the reference (half of VCC)

#define MAX_UINT16 ((1 << 16) - 1)

// ADC buffer used by hall sensor calculations
uint16_t ADC_buffer[DMA_ADC_BUFFER_SIZE] = {0};

void adc_init(void)
{
    // Initialize ADC buffer with simulated values
    for(int i = 0; i < DMA_ADC_BUFFER_SIZE; i += ADC_CYCLE_INDEXES) {
        ADC_buffer[i + MOTOR_CURRENT_PHASE_A_CYCLE_INDEX] = 1350;        // Motor current
        ADC_buffer[i + HALL1_ADC_CYCLE_INDEX] = HALL_SENSOR_SINE_OFFSET; // Hall 1
        ADC_buffer[i + SUPPLY_VOLTAGE_ADC_CYCLE_INDEX] = 65535;          // Supply voltage
        ADC_buffer[i + MOTOR_CURRENT_PHASE_B_CYCLE_INDEX] = 1350;        // Motor current
        ADC_buffer[i + HALL2_ADC_CYCLE_INDEX] = HALL_SENSOR_SINE_OFFSET; // Hall 2
        ADC_buffer[i + TEMPERATURE_ADC_CYCLE_INDEX] = 32768;             // Temperature
        ADC_buffer[i + 6] = 1350;                                        // Motor current
        ADC_buffer[i + HALL3_ADC_CYCLE_INDEX] = HALL_SENSOR_SINE_OFFSET; // Hall 3
    }
}


uint16_t get_hall_sensor1_voltage(void)
{
    uint16_t a = ADC_buffer[HALL1_ADC_CYCLE_INDEX + 0] +
                 ADC_buffer[HALL1_ADC_CYCLE_INDEX + ADC_CYCLE_INDEXES] +
                 ADC_buffer[HALL1_ADC_CYCLE_INDEX + ADC_CYCLE_INDEXES * 2] +
                 ADC_buffer[HALL1_ADC_CYCLE_INDEX + ADC_CYCLE_INDEXES * 3];
/*  if(a < 8500 - 2000) {
        fatal_error(ERROR_DEBUG1); // All error messages are defined in error_text.h, which is an autogenerated file based on error_codes.json in the servomotor Python module (<repo root>/python_programs/servomotor/error_codes.json)
    }
    if(a > 8500 + 2000) {
        fatal_error(ERROR_DEBUG1); // All error messages are defined in error_text.h, which is an autogenerated file based on error_codes.json in the servomotor Python module (<repo root>/python_programs/servomotor/error_codes.json)
    } */
    return a;
}

uint16_t get_hall_sensor2_voltage(void)
{
    uint16_t a = ADC_buffer[HALL2_ADC_CYCLE_INDEX + 0] +
                 ADC_buffer[HALL2_ADC_CYCLE_INDEX + ADC_CYCLE_INDEXES] +
                 ADC_buffer[HALL2_ADC_CYCLE_INDEX + ADC_CYCLE_INDEXES * 2] +
                 ADC_buffer[HALL2_ADC_CYCLE_INDEX + ADC_CYCLE_INDEXES * 3];
/*  if(a < 8500 - 2000) {
        fatal_error(ERROR_DEBUG1); // All error messages are defined in error_text.h, which is an autogenerated file based on error_codes.json in the servomotor Python module (<repo root>/python_programs/servomotor/error_codes.json)
    }
    if(a > 8500 + 2000) {
        fatal_error(ERROR_DEBUG1); // All error messages are defined in error_text.h, which is an autogenerated file based on error_codes.json in the servomotor Python module (<repo root>/python_programs/servomotor/error_codes.json)
    } */
    return a;
}

uint16_t get_hall_sensor3_voltage(void)
{
    uint16_t a = ADC_buffer[HALL3_ADC_CYCLE_INDEX + 0] +
                 ADC_buffer[HALL3_ADC_CYCLE_INDEX + ADC_CYCLE_INDEXES] +
                 ADC_buffer[HALL3_ADC_CYCLE_INDEX + ADC_CYCLE_INDEXES * 2] +
                 ADC_buffer[HALL3_ADC_CYCLE_INDEX + ADC_CYCLE_INDEXES * 3];
/*  if(a < 8500 - 2000) {
        fatal_error(ERROR_DEBUG1); // All error messages are defined in error_text.h, which is an autogenerated file based on error_codes.json in the servomotor Python module (<repo root>/python_programs/servomotor/error_codes.json)
    }
    if(a > 8500 + 2000) {
        fatal_error(ERROR_DEBUG1); // All error messages are defined in error_text.h, which is an autogenerated file based on error_codes.json in the servomotor Python module (<repo root>/python_programs/servomotor/error_codes.json)
    } */
    return a;
}


uint16_t get_temperature_ADC_value(void)
{
    // Return value above OVERHEAT_TEMPERATURE_THRESHOLD_ADC_VALUE (11900)
    // to avoid triggering overheat protection
    return 12800;  // temperature around 71Â°C
}

uint16_t get_supply_voltage_ADC_value(void)
{
	double motor_supply_voltage = 30.0;
	double reference_voltage = 3.3;
	double voltage_divider_R1 = 18000;
	double voltage_divider_R2 = 1500;
	double voltage_divider_gain = voltage_divider_R2 / (voltage_divider_R1 + voltage_divider_R2);
	uint32_t ADC_bits = 12;
	double ADC_value = motor_supply_voltage * voltage_divider_gain / reference_voltage * (1 << ADC_bits) * 4;
	if (ADC_value > MAX_UINT16) {
		printf("ERROR: ADC_value exceeded maximum value\n");
		exit(1);
	}
//	printf("ADC value: %lf\n", ADC_value);
	return (uint16_t)(ADC_value);
}


uint16_t get_supply_voltage_volts_times_10(void)
{
	uint16_t supply_voltage = get_supply_voltage_ADC_value();
	uint32_t supply_voltage_calibrated = (supply_voltage * SUPPLY_VOLTAGE_CALIBRATION_CONSTANT) >> 20;

	return (uint16_t)supply_voltage_calibrated;
}


void print_supply_voltage(void)
{
	char buf[100];
	int16_t supply_voltage = get_supply_voltage_ADC_value();
	sprintf(buf, "Supply voltage (ADC value): %hd\n", supply_voltage);
	print_debug_string(buf);
	int32_t supply_voltage_calibrated = (supply_voltage * SUPPLY_VOLTAGE_CALIBRATION_CONSTANT) >> 20;
	int16_t whole_number = supply_voltage_calibrated / 10;
	int16_t decimal = (supply_voltage_calibrated % 10);
	sprintf(buf, "Supply voltage: %hd.%hu\n", whole_number, decimal);
	print_debug_string(buf);
}


void set_analog_watchdog_limits(uint16_t lower_limit, uint16_t upper_limit)
{
}

uint16_t get_motor_current(void)
{
    // Return simulated motor current around the expected baseline of 1350
    // This matches EXPECTED_MOTOR_CURRENT_BASELINE from motor_control.c
    return 1350;
}
 
// -----------------------------------------------------------------------------
// Simulate ADC conversion for hall sensor channels.
// This function recalculates the sinusoidal analog values for the three hall sensors,
// based on the current motor angle (in degrees) and writes those values into each ADC DMA buffer cycle.
// Each hall sensor value is written to its corresponding ADC buffer index.
void simulate_ADC_hall_sensor_values(void)
{
    double angleDeg = MotorHAL_GetPosition();
    double angleRad = angleDeg * M_PI / 180.0;

    double hall1 = HALL_SENSOR_SINE_OFFSET + HALL_SENSOR_SINE_AMPLITUDE * sin(angleRad * ENCODER_ROTATIONS_PER_SHAFT_ROTATION);
    double hall2 = HALL_SENSOR_SINE_OFFSET + HALL_SENSOR_SINE_AMPLITUDE * sin(angleRad * ENCODER_ROTATIONS_PER_SHAFT_ROTATION - (2.0 * M_PI / 3.0));
    double hall3 = HALL_SENSOR_SINE_OFFSET + HALL_SENSOR_SINE_AMPLITUDE * sin(angleRad * ENCODER_ROTATIONS_PER_SHAFT_ROTATION - (4.0 * M_PI / 3.0));

    if ((hall1 < HALL_SENSOR_SINE_OFFSET - HALL_SENSOR_SINE_AMPLITUDE) || (hall1 > 65535.0)) {
        printf("Error: unexpected hall sensor value. It overflowed the uint16_t: %.2f\n", hall1);
        exit(1);
    }
    if ((hall2 < HALL_SENSOR_SINE_OFFSET - HALL_SENSOR_SINE_AMPLITUDE) || (hall2 > 65535.0)) {
        printf("Error: unexpected hall sensor value. It overflowed the uint16_t: %.2f\n", hall2);
        exit(1);
    }
    if ((hall3 < HALL_SENSOR_SINE_OFFSET - HALL_SENSOR_SINE_AMPLITUDE) || (hall3 > 65535.0)) {
        printf("Error: unexpected hall sensor value. It overflowed the uint16_t: %.2f\n", hall3);
        exit(1);
    }

    for (int i = 0; i < DMA_ADC_BUFFER_SIZE; i += ADC_CYCLE_INDEXES) {
         ADC_buffer[i + HALL1_ADC_CYCLE_INDEX] = (uint16_t)hall1;
         ADC_buffer[i + HALL2_ADC_CYCLE_INDEX] = (uint16_t)hall2;
         ADC_buffer[i + HALL3_ADC_CYCLE_INDEX] = (uint16_t)hall3;
    }
}
