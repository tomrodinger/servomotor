# Servomotor Test Summary

## Test Files

| Filename                                                                       | Description                                                                                                                               | Module Used     | Obsolete | Prints PASS/FAIL |
| :----------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------- | :-------------- | :------- | :--------------- |
| `test_all_leds_on.py`                                                          | Resets devices and turns on all LEDs using a test mode command. Uses older `communication` module.                                        | `communication` | Yes      | No               |
| `test_communication_while_high_speed.py`                                       | Stress tests communication (ping) while the motor executes a high-speed accelerate-coast-decelerate profile. Uses `servomotor` library.     | `servomotor`    | No       | Yes              |
| `test_continuous_graphing.py`                                                  | Simple Matplotlib animation example, unrelated to motor control.                                                                          | `N/A`           | Yes      | No               |
| `test_enable_disable.py`                                                       | Repeatedly enables and disables motor MOSFETs for many iterations. Reliability test. Uses older `communication` module.                   | `communication` | Yes      | No               |
| `test_fast_short_move_with_velocity.py`                                        | Tests queuing and executing many short, fast moves using velocity control. Uses `servomotor` library.                                     | `servomotor`    | No       | Yes              |
| `test_get_comprehensive_position.py`                                           | Continuously polls and prints the comprehensive position (motor, hall, external encoder) for a specified motor. Uses `servomotor` library. | `servomotor`    | No       | Yes              |
| `test_get_firmware_version.py`                                                 | Tests the "Get firmware version" command in both main firmware and bootloader modes. Validates version format, consistency, and mode detection. Uses `servomotor` library. | `servomotor`    | No       | Yes              |
| `test_getch.py`                                                                | Tests the `getch` terminal input utility using a mock motor class. No hardware interaction.                                               | `N/A`           | Yes      | No               |
| `test_glue_machine_rotation_matrix.py`                                         | Loads glue machine calibration/transform data, visualizes, and tests the transformation matrix accuracy. Application-specific.            | `N/A`           | No       | Yes              |
| `test_go_to_closed_loop_mode_and_spin_motor.py`                                | Tests closed-loop entry, performs moves, checks final position, and gathers success statistics based on phase angle. Uses older `communication` module. | `communication` | Yes      | No               |
| `test_go_to_closed_loop_mode_and_then_get_data_many_times.py`                  | Repeatedly enters closed-loop mode and reads/saves the internal data buffer (including Goertzel results). Data collection focus. Uses older `communication` module. | `communication` | Yes      | No               |
| `test_go_to_closed_loop_mode_plot_data.py`                                     | Reads and plots data logs generated by `test_go_to_closed_loop_mode_and_then_get_data_many_times.py`. Post-processing script.             | `N/A`           | Yes      | No               |
| `test_go_to_closed_loop_mode.py`                                               | Detailed closed-loop entry test: captures data, runs Python Goertzel comparison, logs results, generates histograms. Uses older `communication` module. | `communication` | Yes      | No               |
| `test_go_to_position.py`                                                       | Tests `go_to_position` command accuracy with position specified in different units (rotations, degrees, radians, counts). Uses `servomotor` library. | `servomotor`    | No       | Yes              |
| `test_gradual_speed_up.py`                                                     | Detects motors and gradually increases speed using `move_with_velocity` until max speed or error. Speed limit test. Uses `servomotor` library. | `servomotor`    | No       | Yes              |
| `test_homing.py`                                                               | Tests `homing` command accuracy with distance specified in different units and directions. Uses `servomotor` library.                     | `servomotor`    | No       | Yes              |
| `test_iterate_reset_and_enable.py`                                             | Repeatedly moves, disables, resets, enables. Reliability test. Uses older `communication` module. Potentially outdated/unclear.          | `communication` | Yes      | No               |
| `test_json_read.py`                                                            | Reads and prints contents of `motor_commands.json`. Basic utility script.                                                                 | `N/A`           | Yes      | No               |
| `test_motor_position_vs_hall_sensor_position_vs_external_encoder_position.py`  | Moves motor while sampling internal position, hall position, and external encoder position. Logs data and calculates deviations. Uses older `communication` module. | `communication` | Yes      | No               |
| `test_move_with_acceleration.py`                                               | Tests `move_with_acceleration` command accuracy with acceleration specified in different units. Uses `servomotor` library.                | `servomotor`    | No       | Yes              |
| `test_move_with_velocity.py`                                                   | Tests `move_with_velocity` command accuracy with velocity specified in different units. Uses `servomotor` library.                      | `servomotor`    | No       | Yes              |
| `test_ping.py`                                                                 | Basic communication test using `ping` command and verifying echoed data. Uses `servomotor` library.                                       | `servomotor`    | No       | Yes              |
| `test_random_speed_stress.py`                                                  | Complex stress test: detects, assigns aliases, pings, runs random speed moves on multiple motors, monitors errors, resets periodically. Uses `servomotor` library. | `servomotor`    | No       | Yes              |
| `test_safety_limit.py`                                                         | Low-level test using direct serial communication and special command to verify internal firmware motion calculations.                     | `serial`        | Yes      | Yes              |
| `test_servomotor_module_get_command_id.py`                                     | Unit test for the `servomotor.get_command_id()` function. No hardware interaction.                                                        | `servomotor`    | Yes      | Yes              |
| `test_servomotor_module.py`                                                    | Simple script using potentially outdated `servomotor.execute_command` to enable/reset. No verification.                                   | `servomotor`    | Yes      | No               |
| `test_terminal_formatting.py`                                                  | Tests the `terminal_formatting` utility module. No hardware interaction.                                                                  | `N/A`           | Yes      | No               |
| `test_time_sync_multiple_devices.py`                                           | Tests time synchronization across multiple specified motors, reporting min/max error. Uses older `communication` module.                  | `communication` | Yes      | No               |
| `test_test_mode.py`                                                            | Verifies the "Test mode" command, including invalid and fatal error scenarios. Checks for correct fatal error codes and enforces timeout behavior. Uses `servomotor` library. | `servomotor`    | No       | Yes              |
| `test_time_sync.py`                                                            | Tests time synchronization for a single specified motor, reporting error continuously. Uses older `communication` module.                 | `communication` | Yes      | No               |
| `test_get_temperature.py`                                                      | Tests the "Get temperature" command by measuring temperature changes during high-power motor operation. Validates thermal protection and step-skipping detection. Uses `servomotor` library. | `servomotor`    | No       | Yes              |

## `test_get_temperature.py`

This test verifies the "Get temperature" command functionality by measuring temperature changes during high-power motor operation. It validates temperature measurement accuracy, thermal protection behavior, and motor step-skipping detection due to overheating.

**Test Scenarios:**
1. **Baseline Temperature Reading:**
   - Takes initial temperature reading after cooling period
   - Validates temperature is within acceptable range (10°C - 80°C by default)

2. **High-Power Motor Operation:**
   - Configures motor for maximum current (390) and specified velocity
   - Queues single long-duration move followed by velocity=0 to prevent queue empty errors
   - Monitors motor status for fatal errors during operation
   - Runs motor continuously for specified duration (default: 120 seconds)

3. **Final Temperature Reading:**
   - Takes final temperature reading after motor operation
   - Calculates temperature increase and validates against minimum threshold
   - Ensures final temperature stays within safe operating range

4. **Multi-Motor Support:**
   - Detects all motors on bus with collision-resistant detection
   - Tests all detected motors simultaneously
   - Reports individual results for each motor

**Key Implementation Details:**
- Uses simplified queue management: one long move + velocity=0 command to prevent error 18
- Sets proper time and velocity units for easy parameter specification
- Monitors for thermal protection events and position deviation errors
- Supports configurable test parameters via command line arguments
- Provides comprehensive error handling and status reporting

**Command-line arguments:**
- `-p`, `--port`: Serial port device name (required unless `-P` is used)
- `-P`, `--PORT`: Show available ports and prompt for selection
- `--initial-sleep`: Initial cooling time in seconds (default: 30)
- `--motor-run-time`: High-power motor run time in seconds (default: 120)
- `--min-temp`: Minimum acceptable temperature in °C (default: 10)
- `--max-temp`: Maximum acceptable temperature in °C (default: 80)
- `--temp-increase`: Minimum expected temperature increase in °C (default: 5)
- `--max-current`: Maximum motor current setting (default: 390)
- `--velocity`: Motor velocity in rotations/second (default: 1.0)
- `--position-deviation`: Max allowable position deviation (default: 100000)
- `--repeat`: Number of times to repeat the test (default: 1)
- `--verbose`: Enable verbose output

**Example usage:**
```bash
# Basic test with default settings
python3 test_get_temperature.py -p /dev/ttyUSB0

# Extended test with custom parameters
python3 test_get_temperature.py -p /dev/ttyUSB0 --initial-sleep 300 --motor-run-time 1800 --temp-increase 10

# Quick test for development
python3 test_get_temperature.py -p /dev/ttyUSB0 --initial-sleep 5 --motor-run-time 60 --temp-increase 2
```

## `test_set_device_alias.py`

This test verifies the device alias setting functionality using the `servomotor` library and the `M3` class. It covers:
- Setting a random valid alias (0–251) and verifying with device detection.
- Attempting to set invalid aliases (254, 253, 252) and confirming the device enters a fatal error state.
- Removing the alias (setting to 255) and confirming the device is detected with alias 255.

**Command-line arguments:**
- `-p`, `--port`: Serial port device name (required)
- `--bootloader`: Enter bootloader mode before running the test
- `--verbose`: Enable verbose output
- `-P`, `--PORT`: Show available ports and prompt for selection
- `--repeat N`: Repeat all test scenarios N times (default: 1)

After each repeat, the script prints the number of passes and failures for each test scenario. At the end, a grand summary is printed. The script exits with code 0 if all tests pass in all repeats, or 1 if any test fails.

Example usage:
```
python3 test_set_device_alias.py -p /dev/ttyUSB0 --repeat 5
```

## `test_test_mode.py`

This test verifies the correct behavior of the "Test mode" command in the servomotor firmware/bootloader. It covers both invalid and valid (fatal error-triggering) scenarios, and ensures the device responds as expected.

**Test Scenarios:**
1. **Invalid Test Mode Parameter:**
   - Sends a test_mode value >= 72 (e.g., 255), which is not supported by the firmware.
   - Expects the device to enter the ERROR_INVALID_TEST_MODE (code 53) fatal error state.
   - The device should NOT respond to the test_mode command (timeout is expected).
   - The test then calls get_status to confirm the fatal error code is set.

2. **Valid Test Mode Parameter (Triggers Fatal Error):**
   - Randomly selects a fatal error code N in the range 0–59.
   - Sends test_mode = N + 12, which, per firmware logic, triggers fatal_error(N).
   - The device should NOT respond to the test_mode command (timeout is expected).
   - The test then calls get_status to confirm the correct fatal error code is set.

**Key Implementation Details:**
- The test uses only the device's unique ID for all commands after initial detection, ensuring robust addressing even if the alias is 255.
- After each fatal error is triggered, the test performs a system reset to return the device to a known state before the next scenario.
- The test explicitly checks that a timeout occurs after sending a test_mode command that triggers a fatal error. If no timeout occurs, the test fails.
- The test supports --bootloader and --repeat options for flexibility and repeated validation.
- The test prints clear PASS/FAIL results and exits with code 0 on success, 1 on failure.

**Firmware Mapping Reference:**
- test_mode == 0: disables test mode
- test_mode 1–9: set_motor_test_mode
- test_mode 10–11: set_led_test_mode
- test_mode 12–71: triggers fatal_error(test_mode - 12), i.e., test_mode 12 triggers fatal_error(0), 13 triggers fatal_error(1), ..., 71 triggers fatal_error(59)
- test_mode >= 72: triggers fatal_error(ERROR_INVALID_TEST_MODE)

**Command-line arguments:**
- `-p`, `--port`: Serial port device name (required)
- `--bootloader`: Enter bootloader mode before running the test
- `--verbose`: Enable verbose output
- `-P`, `--PORT`: Show available ports and prompt for selection
- `--repeat N`: Repeat all test scenarios N times (default: 1)

**Example usage:**
```
python3 test_test_mode.py -p /dev/ttyUSB0 --repeat 5 --verbose
```

## `test_get_firmware_version.py`

This test verifies the "Get firmware version" command functionality in both main firmware and bootloader modes using the `servomotor` library and the `M3` class. It covers:

- Testing the command in main firmware mode (returns firmware version with `inBootloader=0`)
- Testing the command in bootloader mode (returns bootloader version with `inBootloader=1`)
- Validating firmware version format (handles both list `[dev, patch, minor, major]` and u32 integer formats)
- Verifying the `inBootloader` flag correctly reflects the current mode
- Testing both alias and unique ID addressing methods
- Ensuring consistency across multiple repeated calls
- Comprehensive error handling and validation

**Test Scenarios:**
1. **Main Firmware Mode Test:**
   - Resets device and enters main firmware mode (long delay after reset)
   - Tests `get_firmware_version` command using alias addressing
   - Tests `get_firmware_version` command using unique ID addressing
   - Verifies both methods return identical results
   - Validates that `inBootloader` flag is 0 (false)

2. **Bootloader Mode Test:**
   - Resets device and enters bootloader mode (short delay after reset)
   - Tests `get_firmware_version` command using alias addressing
   - Tests `get_firmware_version` command using unique ID addressing
   - Verifies both methods return identical results
   - Validates that `inBootloader` flag is 1 (true)

3. **Repeat Testing:**
   - When `--repeat N` is specified, performs multiple calls to verify consistency
   - Validates all repeated calls return identical results

**Key Implementation Details:**
- Uses extended addressing (unique ID) for robust communication after device detection
- Validates firmware version format: `[development, patch, minor, major]` or u32 integer
- Converts version components to human-readable format (e.g., "0.11.0.0")
- Supports both bootloader and main firmware modes via `--bootloader` flag
- Comprehensive validation of version components and ranges
- Clear PASS/FAIL reporting with detailed error messages

**Command-line arguments:**
- `-p`, `--port`: Serial port device name (required unless `-P` is used)
- `-P`, `--PORT`: Show available ports and prompt for selection
- `--bootloader`: Enter bootloader mode before running the test
- `--repeat N`: Repeat all test scenarios N times (default: 1)
- `--verbose`: Enable verbose output

**Example usage:**
```bash
# Test in main firmware mode
python3 test_get_firmware_version.py -p /dev/ttyUSB0

# Test in bootloader mode
python3 test_get_firmware_version.py -p /dev/ttyUSB0 --bootloader

# Test with multiple repeats in bootloader mode
python3 test_get_firmware_version.py -p /dev/ttyUSB0 --bootloader --repeat 5

# Interactive port selection with verbose output
python3 test_get_firmware_version.py -P --verbose
```

## Best Practices for Writing Tests

Based on the modern tests using the `servomotor` module, follow these best practices:

*   **Use `servomotor` Library:** Import and utilize the `servomotor` library, specifically the `M3` class for motor control.
*   **Clear Initialization:** Instantiate the `M3` object, clearly defining units (`time_unit`, `position_unit`, `velocity_unit`, etc.).
*   **Command-Line Arguments:** Use `argparse` to handle common options like serial port (`-p`, `-P`), alias (`-a`), and verbosity (`-v`), making tests more flexible.
*   **Port Handling Order:** **Crucially**, ensure argument parsing (`parser.parse_args()`) and setting the port via `servomotor.set_serial_port_from_args(args)` happen *before* calling `servomotor.open_serial_port()`. This prevents the library from incorrectly falling back to reading `serial_device.txt`.
*   **Port Management:** Use `servomotor.open_serial_port()` at the beginning and `servomotor.close_serial_port()` at the end, typically within a `try...finally` block to ensure the port is closed even if errors occur.
*   **Clean State:** Start tests with `motor.system_reset()` followed by an appropriate delay (e.g., `time.sleep(1.0)`) to ensure a known starting condition.
*   **Safe Operation:** Use `motor.enable_mosfets()` before commanding movement and `motor.disable_mosfets()` during cleanup (in the `finally` block).
*   **Structured Tests:** Encapsulate test logic within functions (e.g., `def test_my_feature(motor_obj):`). Pass the initialized motor object to the test function.
*   **Standard Entry Point:** Use `if __name__ == "__main__":` to handle argument parsing, port setup, motor initialization, calling the main test function, and final port closing.
*   **Verification:** Employ helper functions (e.g., `wait_for_moves_to_complete`) and assertion functions (e.g., `verify_position`, `verify_timing`, or standard `assert`) to programmatically check expected outcomes.
*   **Clear Pass/Fail:** Conclude the test script by printing "PASSED" upon successful completion. Use assertions or explicit checks to detect failures and ensure the script exits with a non-zero status code on failure. Tests designed for continuous monitoring, data collection, or visualization might naturally omit a final PASS/FAIL message and exit code.
*   **Summarize Multi-Part Tests:** If a test performs multiple distinct checks or runs in a loop, consider tracking internal pass/fail counts and printing a summary at the end before the final "PASSED" message.

## Remaining Work (Test Framework Implementation)

1.  **Refactor Test Scripts:**
    *   Apply the best practices structure (argument parsing before port opening, `try...finally`, passing motor object) to the remaining affected test scripts:
        *   `test_set_velocity_to_specific_values.py`
    *   Review *all* non-obsolete tests to ensure they consistently exit with code 0 on success and non-zero on failure.
    *   Consider adding internal summaries for tests performing multiple checks.
2.  **Address `test_random_speed_stress.py`:**
    *   Decide whether to install the `paho-mqtt` dependency (`pip install paho-mqtt`) or modify the test to make MQTT optional/removable if not needed.
3.  **Verify Simulator Compatibility:**
    *   Investigate why tests like `test_communication_while_high_speed.py`, `test_get_comprehensive_position.py`, and `test_go_to_position.py` timed out or had read errors with the simulator. This might require adjustments to the tests or the simulator itself.
    *   Investigate the timeout for `test_fast_short_move_with_velocity.py` with the simulator.
4.  **Test Runner Refinement (Optional):**
    *   The `run_all_tests.py` script could be enhanced to parse `TEST_SUMMARY.md` more robustly to check the "Prints PASS/FAIL" column dynamically instead of hardcoding exceptions.
5.  **Run and Verify:** Execute `run_all_tests.py` against the simulator (and eventually real hardware) after fixes are applied to confirm all expected tests pass.
## Bootloader Testing

### Test Script: `test_bootloader.py` (Proposed)

This test script aims to verify the core functionalities of the STM32G031 bootloader accessed via RS485 communication. It should cover the following areas:

*   **Basic Communication & Identification:**
    *   Verify `DETECT_DEVICES_COMMAND` response (Unique ID, Alias).
    *   Verify `GET_PRODUCT_INFO_COMMAND` response (Model Code, Compatibility Code).
    *   Verify `GET_STATUS_COMMAND` response indicates "in bootloader" status.
*   **Alias Configuration:**
    *   Test setting a valid alias using `SET_DEVICE_ALIAS_COMMAND`.
    *   Verify the new alias is reported correctly via `DETECT_DEVICES_COMMAND`.
    *   Test setting invalid aliases and confirm failure.
*   **Firmware Upgrade:**
    *   Test uploading firmware pages using `FIRMWARE_UPGRADE_COMMAND`.
    *   Verify success with correct model/compatibility codes and payload size.
    *   Test failure cases: incorrect model code, incorrect compatibility code, incorrect payload size.
    *   After a simulated successful upgrade and reset, verify the device attempts to boot the application.
*   **Application Launch Control:**
    *   Verify the bootloader attempts to launch valid firmware after a delay on startup.
    *   Verify sending any command during this delay cancels the automatic launch.
*   **System Reset:**
    *   Test `SYSTEM_RESET_COMMAND` and verify the device resets.
*   **Error Handling:**
    *   Test sending commands with invalid CRC32 checksums and verify they are ignored.
    *   Test sending commands with incorrect payload sizes and verify failure.
*   **Test Mode (Optional):**
    *   If feasible, test `TEST_MODE_COMMAND` to trigger specific fatal errors and verify behavior.
### `test_bootloader.py` Status (as of 2025-04-22)

*   **Purpose:** Test STM32G031 bootloader commands via RS485.
*   **Implementation:** Uses `servomotor.communication` module functions (`send_command`, `get_response`) for packet handling, following standard test structure. Requires manual entry into bootloader mode before running.
*   **Tests Implemented:** Basic Communication & Identification, Alias Configuration.
*   **Current Issues:** Encountered `TimeoutError` during broadcast `DETECT_DEVICES` command, potentially due to timeout handling logic in `communication.send_command` for alias 0. Further investigation or workarounds within the test script needed. Other test sections (Firmware Upgrade, Reset, Error Handling) are placeholders.