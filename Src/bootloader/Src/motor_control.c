#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "stm32g0xx_hal.h"
#include "microsecond_clock.h"
#include "debug_uart.h"
#include "PWM.h"
#include "ADC.h"
#include "hall_sensor_calculations.h"
#include "mosfets.h"
#include "CommutationTable.h"  // generated by a program called process_raw_hall_data.py
#include "error_handling.h"
#include "RS485.h"
#include "motor_control.h"
#include "leds.h"
#include "step_direction_input.h"


// set which axis this motor is controlling
#ifdef X_AXIS
	#include "LookupTableX.h" // generated by a program called BLDC_sin_lookup_table.py
#else
	#ifdef Y_AXIS
		#include "LookupTableY.h"
	#else
		#ifdef Z_AXIS
			#include "LookupTableZ.h"
		#else
			#ifdef SMALL_Z_AXIS
				#include "LookupTableSmallZ.h"
			#else
				#ifdef E_AXIS
					#include "LookupTableE.h"
				#else
					#error "You need to set an axis"
				#endif
			#endif
		#endif
	#endif
#endif


#define MAX_HOMING_ERROR 100000

#define POWER_MULTIPLIER 1

#define CLOSED_LOOP_PWM_VOLTAGE (100 * POWER_MULTIPLIER)
#define OPEN_LOOP_STATIC_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)
#define OPEN_LOOP_DYNAMIC_MOTOR_PWM_VOLTAGE (125 * POWER_MULTIPLIER)
#define CALIBRATION_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)
#define GO_TO_CLOSED_LOOP_MODE_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)
#define HOMING_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)

#define MAX_PWM_VOLTAGE_ADJUSTMENT 400

#define VELOCITY_SCALE_FACTOR 11
#define UINT32_MIDPOINT 2147483648
// This is the number of microsteps to turn the motor through one quarter of one commutation cycle (not one revolution)
#define HALL_TO_POSITION_90_DEGREE_OFFSET ((N_COMMUTATION_STEPS * N_COMMUTATION_SUB_STEPS) >> 2)

const struct three_phase_data_struct commutation_lookup_table[N_COMMUTATION_STEPS] = COMMUTATION_LOOKUP_TABLE_INITIALIZER;

#define ACCELERATION_SHIFT_LEFT 8
#define MOVEMENT_QUEUE_SIZE 16 // this has to be a power of 2
typedef struct {
    int64_t acceleration;
    uint32_t n_time_steps;
} movement_queue_t;
static movement_queue_t movement_queue[MOVEMENT_QUEUE_SIZE];
static uint8_t queue_write_position = 0;
static uint8_t queue_read_position = 0;
static uint8_t n_items_in_queue = 0;

static int32_t hall_position = 0;
static int32_t velocity = 0;
static uint64_t movement_end_time = 0;
static int64_t current_velocity_i64 = 0;
static int64_t current_position_i64 = 0;
static int32_t desired_position = 0; // this is the target position
static uint32_t commutation_position = 0;
static uint32_t commutation_position_offset = UINT32_MIDPOINT;
static uint64_t movement_start_time = 0;
static int32_t movement_start_position = 0;
static int32_t movement_end_position = 0;
static uint16_t max_acceleration = 1;
static int32_t max_velocity = MAX_VELOCITY;
static int32_t motor_pwm_voltage = 0;
static int32_t desired_motor_pwm_voltage = 0;
//static int32_t desired_velocity = 0;
static uint8_t motor_control_mode = OPEN_LOOP_POSITION_CONTROL;

static uint8_t go_to_closed_loop_mode_active = 0;

static uint32_t debug_counter = 0;
static uint16_t time_difference1 = 0;
static uint16_t time_difference2 = 0;
static uint16_t time_difference3 = 0;
static uint16_t time_difference4 = 0;
static uint16_t time_difference5 = 0;
static uint16_t max_time_difference1 = 0;
static uint16_t max_time_difference2 = 0;
static uint16_t max_time_difference3 = 0;
static uint16_t max_time_difference4 = 0;
static uint16_t max_time_difference5 = 0;
static uint64_t current_time_captured = 0;
static uint64_t movement_end_time_captured;
static uint16_t motor_control_tick_time_difference = 0;
static uint16_t max_motor_control_tick_time_difference = 0;
static uint16_t motor_control_time_difference = 0;
static uint16_t max_motor_control_time_difference = 0;

//extern uint16_t ADC_buffer[DMA_ADC_BUFFER_SIZE];


// for the following calibration movement calculations, the time unit is one motor calculation cycle. at the time of this
// writing, this is roughly 25 microseconds. it may be noted elsewhere what this is more accurately.

// this is the velocity used during coast phases of the calibration.
// CALIBRATION_MAX_VELOCITY is in units of motor microsteps per time unit.
// for example, 64 means that the motor will take 64 microsteps per time unit.
#define CALIBRATION_MAX_VELOCITY CALIBRATION_CAPTURE_STEP_SIZE

#define CALIBRATION_VELOCITY_SHIFT 7 // this is how many binary decimal places we are keeping for the calibration velocity value

#define CALIBRATION_ACCELERATION 1 // this is the acceleration used during calibration. the units are microsteps divided by
                                   // (1 << CALIBRATION_VELOCITY_SHIFT) per one unit of time squared.

// this is the time to accelerate or decelerate during calibration. careful that this number ends up being an integer.
#define CALIBRATION_ACCELERATION_TIME ((CALIBRATION_MAX_VELOCITY << CALIBRATION_VELOCITY_SHIFT) / CALIBRATION_ACCELERATION)

// this is the distance delta during one acceleration or deceleration move in the unit of microsteps
#define CALIBRATION_ACCELERATION_DISTANCE ((((((uint32_t)CALIBRATION_ACCELERATION_TIME * (uint32_t)(CALIBRATION_ACCELERATION_TIME + 1)) >> 1) * CALIBRATION_ACCELERATION) >> CALIBRATION_VELOCITY_SHIFT))

// this is the time to coast at constant velocity such that the distance covered is CALIBRATION_ACCELERATION_DISTANCE
#define CALIBRATION_SMALL_COAST_TIME ((uint16_t)((uint32_t)CALIBRATION_ACCELERATION_DISTANCE / CALIBRATION_MAX_VELOCITY))

// this is the movement distance to cover exactly one rotation of the hall sensor magnetic disc in the unit of microsteps
#define CALIBRATION_MOVEMENT_DISTANCE ((int32_t)N_COMMUTATION_STEPS * (int32_t)N_COMMUTATION_SUB_STEPS * (int32_t)ONE_REVOLUTION_STEPS)

// this is the time to coast at constant velocity while capturing hall sensor readings. this should be exactly such that after one
// coast phase, the motor will rotate through one hall sensor revolution (ie. moves CALIBRATION_MOVEMENT_DISTANCE).
#define CALIBRATION_COAST_TIME (CALIBRATION_MOVEMENT_DISTANCE / CALIBRATION_MAX_VELOCITY)



#define CAPTURE_HALL_SENSOR_READINGS 1
#define CAPTURE_HALL_POSITION 2
#define CAPTURE_ADJUSTED_HALL_SENSOR_READINGS 3


#define HOMING_MAX_VELOCITY 32

#define HOMING_VELOCITY_SHIFT 8 // this is how many binary decimal places we are keeping for the homing velocity value

#define HOMING_ACCELERATION 1 // this is the acceleration used during calibration. the units are microsteps divided by
                                   // (1 << HOMING_VELOCITY_SHIFT) per one unit of time squared.

// this is the time to accelerate or decelerate during calibration. careful that this number ends up being an integer.
#define HOMING_ACCELERATION_TIME ((HOMING_MAX_VELOCITY << HOMING_VELOCITY_SHIFT) / HOMING_ACCELERATION)

// this is the distance delta during one acceleration or deceleration move in the unit of microsteps
#define HOMING_ACCELERATION_DISTANCE ((((((uint32_t)HOMING_ACCELERATION_TIME * (uint32_t)(HOMING_ACCELERATION_TIME + 1)) >> 1) * HOMING_ACCELERATION) >> HOMING_VELOCITY_SHIFT))

// this is the time to coast at constant velocity such that the distance covered is HOMING_ACCELERATION_DISTANCE
#define HOMING_SMALL_COAST_TIME ((uint16_t)((uint32_t)HOMING_ACCELERATION_DISTANCE / HOMING_MAX_VELOCITY))

#define HOMING_MAX_REVOLUTIONS 300

// this is the movement distance to cover exactly one rotation of the hall sensor magnetic disc in the unit of microsteps
#define HOMING_MOVEMENT_DISTANCE (N_COMMUTATION_STEPS * N_COMMUTATION_SUB_STEPS * ONE_REVOLUTION_STEPS * HOMING_MAX_REVOLUTIONS)

// this is the time to coast at constant velocity while capturing hall sensor readings. this should be exactly such that after one
// coast phase, the motor will rotate through one hall sensor revolution (ie. moves HOMING_MOVEMENT_DISTANCE).
#define HOMING_COAST_TIME (HOMING_MOVEMENT_DISTANCE / HOMING_MAX_VELOCITY)


/*
 * Example:
 *    CALIBRATION_MAX_VELOCITY 64
 *    CALIBRATION_VELOCITY_SHIFT 8
 *    CALIBRATION_ACCELERATION 1
 *    CALIBRATION_ACCELERATION_TIME 16384
 *    CALIBRATION_ACCELERATION_DISTANCE 524320
 *    CALIBRATION_SMALL_COAST_TIME 8192.5 rounded down to 8192
 *    CALIBRATION_COAST_TIME 10080
 *    CALIBRATION_MOVEMENT_DISTANCE 645120
 */


struct calibration_struct {
    uint8_t move_number;
    uint16_t time;
    int16_t velocity;
    int16_t acceleration;
    uint8_t capturing_data;
    uint8_t verbose_data;
    uint8_t avg_counter;
    uint32_t hall1_sum;
    uint32_t hall2_sum;
    uint32_t hall3_sum;
};
struct calibration_struct calibration = {0};

struct go_to_closed_loop_mode_struct {
    uint8_t move_number;
    uint16_t time;
    int16_t velocity;
    int16_t acceleration;
};
struct go_to_closed_loop_mode_struct go_to_closed_loop_mode = {0};

struct capture_struct {
    uint8_t capture_type;
    uint8_t avg_counter;
    uint16_t hall1_sum;
    uint16_t hall2_sum;
    uint16_t hall3_sum;
};
struct capture_struct capture = {0};


struct homing_struct {
    uint8_t move_number;
    int8_t direction;
    uint32_t time;
    int16_t velocity;
    int16_t acceleration;
    int32_t start_position;
    int32_t start_six_step_hall_position;
};
struct homing_struct homing = {0};


struct closed_loop_struct {
    uint8_t move_number;
    uint32_t time;
    int16_t velocity;
    int16_t acceleration;
    uint8_t capturing_data;
    uint8_t avg_counter;
    uint32_t hall1_sum;
    uint32_t hall2_sum;
    uint32_t hall3_sum;
    uint16_t max_hall_reading;
    int32_t max_hall_position;
    int32_t max_hall_distance;
};
struct closed_loop_struct closed_loop = {0};


void clear_the_queue_and_stop_no_disable_interrupt(void)
{
    queue_read_position = 0;
    queue_write_position = 0;
    n_items_in_queue = 0;
    movement_end_time = 0;
    movement_end_position = desired_position;
}


void start_calibration(uint8_t verbose_data)
{
	char buf[200];

    if(verbose_data) {
    	rs485_transmit("Calibration start\n", 18);
    }

    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation

    clear_the_queue_and_stop_no_disable_interrupt();
    memset(&calibration, 0, sizeof(calibration));
    calibration.verbose_data = verbose_data;
    enable_mosfets();
    calibration.move_number = 1;
    calibration.time = CALIBRATION_ACCELERATION_TIME;
    calibration.velocity = 0;
    calibration.acceleration = -CALIBRATION_ACCELERATION;
    motor_pwm_voltage = CALIBRATION_MOTOR_PWM_VOLTAGE;

    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt

    if(verbose_data) {
    	sprintf(buf, "Cal start pos: %d   time: %hu   vel: %hd   accel: %hd\n", (int)desired_position, calibration.time, calibration.velocity, calibration.acceleration);
    	transmit(buf, strlen(buf));
    }
}


void handle_calibration_logic(void)
{
    uint16_t hall_data_buffer[3];
//	char buf[200];
	volatile uint32_t i;

	calibration.hall1_sum += get_hall_sensor1_voltage();
	calibration.hall2_sum += get_hall_sensor2_voltage();
	calibration.hall3_sum += get_hall_sensor3_voltage();
	calibration.avg_counter++;
	if(calibration.avg_counter == HALL_SAMPLES_PER_PRINT) {
		if(calibration.capturing_data) {
			hall_data_buffer[0] = calibration.hall1_sum - HALL_SENSOR_SHIFT;
			hall_data_buffer[1] = calibration.hall2_sum - HALL_SENSOR_SHIFT;
			hall_data_buffer[2] = calibration.hall3_sum - HALL_SENSOR_SHIFT;
		}
		else {
			hall_data_buffer[0] = 0;
			hall_data_buffer[1] = 0;
			hall_data_buffer[2] = 0;
		}
	    if(calibration.verbose_data) {
	    	rs485_transmit((void*)hall_data_buffer, 6);
	    }
	    else {
	    	for(i = 0; i < 1000; i++); // a delay to make up that we aren't transmitting anything
	    }
		calibration.avg_counter = 0;
		calibration.hall1_sum = 0;
		calibration.hall2_sum = 0;
		calibration.hall3_sum = 0;
	}

/*
#define CALIBRATION_MAX_VELOCITY 64
#define CALIBRATION_VELOCITY_SHIFT 8
#define CALIBRATION_ACCELERATION 1
#define CALIBRATION_ACCELERATION_TIME = ((CALIBRATION_VELOCITY << CALIBRATION_VELOCITY_SHIFT) / CALIBRATION_ACCELERATION)
#define CALIBRATION_ACCELERATION_DISTANCE = ((CALIBRATION_ACCELERATION_TIME * (CALIBRATION_ACCELERATION_TIME + 1)) >> 1)
#define CALIBRATION_SMALL_COAST_TIME (CALIBRATION_ACCELERATION_DISTANCE / CALIBRATION_MAX_VELOCITY)
*/

/*
| Move Number | Position Before Move                | Velocity at Beginning of Move | Acceleration                   | Movement Time                     | Velocity at End of Move   | Position Delta                     | Position After Move                  |
==================================================================================================================================================================================================================================================================
| 1           | 0                                   | 0                             | -CALIBRATION_ACCELERATION      | CALIBRATION_ACCELERATION_TIME     | -CALIBRATION_MAX_VELOCITY | -CALIBRATION_ACCELERATION_DISTANCE | -CALIBRATION_ACCELERATION_DISTANCE   |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 2           | -CALIBRATION_ACCELERATION_DISTANCE  | -CALIBRATION_MAX_VELOCITY     | 0                              | CALIBRATION_COAST_TIME / 2        | -CALIBRATION_MAX_VELOCITY | -CALIBRATION_MOVEMENT_DISTANCE / 2 | -CALIBRATION_ACCELERATION_DISTANCE   |
|             |                                     |                               |                                |                                   |                           |                                    | -CALIBRATION_MOVEMENT_DISTANCE / 2   |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 3           | -CALIBRATION_ACCELERATION_DISTANCE  | -CALIBRATION_MAX_VELOCITY     | +CALIBRATION_ACCELERATION      | CALIBRATION_ACCELERATION_TIME * 2 | CALIBRATION_MAX_VELOCITY  | 0                                  | -CALIBRATION_ACCELERATION_DISTANCE   |
|             | -CALIBRATION_MOVEMENT_DISTANCE / 2  |                               |                                |                                   |                           |                                    | -CALIBRATION_MOVEMENT_DISTANCE / 2   |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 4           | -CALIBRATION_ACCELERATION_DISTANCE  | CALIBRATION_MAX_VELOCITY      | 0                              | CALIBRATION_SMALL_COAST_TIME      | CALIBRATION_MAX_VELOCITY  | CALIBRATION_ACCELERATION_DISTANCE  | -CALIBRATION_MOVEMENT_DISTANCE / 2   |
|             | -CALIBRATION_MOVEMENT_DISTANCE / 2  |                               |                                |                                   |                           |                                    |                                      |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 5           | -CALIBRATION_MOVEMENT_DISTANCE / 2  | CALIBRATION_MAX_VELOCITY      | 0                              | CALIBRATION_COAST_TIME            | CALIBRATION_MAX_VELOCITY  | CALIBRATION_MOVEMENT_DISTANCE      | CALIBRATION_MOVEMENT_DISTANCE / 2    |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 6           | CALIBRATION_MOVEMENT_DISTANCE / 2   | CALIBRATION_MAX_VELOCITY      | 0                              | CALIBRATION_SMALL_COAST_TIME      | CALIBRATION_MAX_VELOCITY  | CALIBRATION_ACCELERATION_DISTANCE  | CALIBRATION_MOVEMENT_DISTANCE / 2    |
|             |                                     |                               |                                |                                   |                           |                                    | +CALIBRATION_ACCELERATION_DISTANCE   |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 7           | CALIBRATION_MOVEMENT_DISTANCE / 2   | CALIBRATION_MAX_VELOCITY      | -CALIBRATION_ACCELERATION      | CALIBRATION_ACCELERATION_TIME * 2 | -CALIBRATION_MAX_VELOCITY | 0                                  | CALIBRATION_MOVEMENT_DISTANCE / 2    |
|             | +CALIBRATION_ACCELERATION_DISTANCE  |                               |                                |                                   |                           |                                    | +CALIBRATION_ACCELERATION_DISTANCE   |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 8           | CALIBRATION_MOVEMENT_DISTANCE / 2   | -CALIBRATION_MAX_VELOCITY     | 0                              | calibration_max_hall_position /   | -CALIBRATION_MAX_VELOCITY | -calibration_max_hall_position     | CALIBRATION_MOVEMENT_DISTANCE / 2    |
|             | +CALIBRATION_ACCELERATION_DISTANCE  |                               |                                | CALIBRATION_MAX_VELOCITY          |                           |                                    | +CALIBRATION_ACCELERATION_DISTANCE   |
|             |                                     |                               |                                |                                   |                           |                                    | -calibration_max_hall_position       |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 9           | CALIBRATION_MOVEMENT_DISTANCE / 2   | -CALIBRATION_MAX_VELOCITY     | +CALIBRATION_ACCELERATION      | CALIBRATION_ACCELERATION_TIME     | 0                         | -CALIBRATION_ACCELERATION_DISTANCE | CALIBRATION_MOVEMENT_DISTANCE / 2    |
|             | +CALIBRATION_ACCELERATION_DISTANCE  |                               |                                |                                   |                           |                                    | -calibration_max_hall_position       |
|             | -calibration_max_hall_position      |                               |                                |                                   |                           |                                    |                                      |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------> Position
|
|Move Number                                                                                                 START        MAX HALL SENSOR MAX POSITION
| 1                                                                              <    <    <   <   <  <  < < <<|                      M
| 2                                 <    <    <    <    <    <    <    <    <    <
| 3   |<< < <  <  <   <   <    <    <
|     |>> > >  >  >   >   >    >    >
| 4                                 >    >    >    >    >    >    >
| 5                                                               >....>....>....>....>....>....>....>....>....>....>....>....>....>..m.>....>....>....>...>
| 6                                                                                                                                                        >....>....>....>....>....>....>
| 7                                                                                                                                                                                      >    >    >   >   >  >  > > >>|
|                                                                                                                                                                                        <    <    <   <   <  <  < < <<|
| 8                                                                                                                                                                  <    <    <    <    <
| 9                                                                                                                                   |<<< < <  <  <   <   <    <    <
\/
TIME
DOWNWARD

                                     <------------------------------------------> <--------------------------->
                                           CALIBRATION_MOVEMENT_DISTANCE / 2    CALIBRATION_ACCELERATION_DISTANCE
	   <---------------------------> <---------------------------> <--------------------------------------------------------------------------------------> <---------------------------> <--------------------------->
	                               CALIBRATION_ACCELERATION_DISTANCE                               CALIBRATION_MOVEMENT_DISTANCE                          CALIBRATION_ACCELERATION_DISTANCE
     CALIBRATION_ACCELERATION_DISTANCE                                                                                                                                                  CALIBRATION_ACCELERATION_DISTANCE
                                                                                                                                       <------------------->
                                                                                                                                  calibration.max_hall_distance
                                                                                                                                                                     <------------------->
                                                                                                                                                                  calibration.max_hall_distance
                                                                                                                                       <--------------------------->
                                                                                                                                     CALIBRATION_ACCELERATION_DISTANCE

|         Stopped (possibly briefly)
>         Movement tot he right
<         Movement to the left
>> > >  > Accelerating, moving right
<  < < << Accelerating, moving left
<< < <  < Decelerating, moving left
>  > > >> Decelerating, moving right
>   >   > Constant velocity coasting
....      Recording the hall sensor readings needed for position calibration
M         position of the maximum hall sensor reading
m         position of the maximum hall sensor reading found here
<------>  Distance covered by various movements (as labeled)

*/
    if(calibration.time == 0) {
        calibration.move_number++;
        switch(calibration.move_number) {
        case 2:
            calibration.time = CALIBRATION_COAST_TIME >> 1;
            calibration.acceleration = 0;
            break;
        case 3:
            calibration.time = CALIBRATION_ACCELERATION_TIME * 2;
            calibration.acceleration = CALIBRATION_ACCELERATION;
            break;
        case 4:
            calibration.time = CALIBRATION_SMALL_COAST_TIME;
            calibration.acceleration = 0;
            break;
        case 5:
            calibration.capturing_data = 1;
            calibration.time = CALIBRATION_COAST_TIME;
            calibration.acceleration = 0;
            break;
        case 6:
            calibration.time = CALIBRATION_SMALL_COAST_TIME;
            calibration.acceleration = 0;
//            sprintf(buf, "actual_position: %d   calibration.max_hall_position: %d\n", (int)actual_position, (int)calibration.max_hall_position);
//            transmit(buf, strlen(buf));
            break;
        case 7:
            calibration.capturing_data = 0;
            if(calibration.verbose_data) {
            	rs485_transmit("Calibration capture done\n", 25);
            }
            calibration.time = CALIBRATION_ACCELERATION_TIME * 2;
            calibration.acceleration = -CALIBRATION_ACCELERATION;
            break;
        case 8:
            calibration.time = CALIBRATION_MOVEMENT_DISTANCE / CALIBRATION_MAX_VELOCITY;
//            sprintf(buf, "FIX THIS moving for this amount of distance: %d\n", (int)CALIBRATION_MOVEMENT_DISTANCE);
//            transmit(buf, strlen(buf));
            calibration.acceleration = 0;
            break;
        case 9:
            calibration.time = CALIBRATION_ACCELERATION_TIME;
            calibration.acceleration = CALIBRATION_ACCELERATION;
            break;
        case 10:
			calibration.time = CALIBRATION_ACCELERATION_TIME >> 1; // this can be changed to any small value. the purpose is to allow the motor to settle after stopping moving
			calibration.acceleration = 0;
			calibration.velocity = 0;
			clear_the_queue_and_stop();
		    if(calibration.verbose_data) {
		    	rs485_transmit("Calibration done\n", 17);
		    }
			break;
        default:
//    		zero_hall_position();
//    		int32_t hall_position = get_hall_position();
//    		sprintf(buf, "desired_position: %d   hall_position: %d\n", (int)desired_position, (int)(hall_position));
//    		transmit(buf, strlen(buf));
    		motor_pwm_voltage = 0;
    		movement_end_position = desired_position;
//    		motor_control_mode = CLOSED_LOOP_POSITION_CONTROL;
            calibration.move_number = 0; // this signals that calibration is no longer in progress
            break;
        }
//        sprintf(buf, "%u: pos: %d   time: %hu   vel: %hd   accel: %hd\n", (unsigned int)calibration.move_number, (int)desired_position, calibration.time, calibration.velocity, calibration.acceleration);
//        transmit(buf, strlen(buf));
    }

    calibration.velocity += calibration.acceleration;
    desired_position += (((int32_t)calibration.velocity + (1 << (CALIBRATION_VELOCITY_SHIFT - 1))) >> CALIBRATION_VELOCITY_SHIFT); // implements rounding for better accuracy
    calibration.time--;
}

#define GO_TO_CLOSED_LOOP_MODE_ACCELERATION 1000000
#define GO_TO_CLOSED_LOOP_MODE_ACCELERATION_TIME 1000
#define GO_TO_CLOSED_LOOP_MODE_COAST_TIME 10000
void start_go_to_closed_loop_mode(void)
{
	transmit("Go to closed loop mode start\n", 29);

	clear_the_queue_and_stop_no_disable_interrupt();
	set_motor_control_mode(OPEN_LOOP_POSITION_CONTROL);
	enable_mosfets();
	motor_pwm_voltage = GO_TO_CLOSED_LOOP_MODE_MOTOR_PWM_VOLTAGE;
	add_to_queue(GO_TO_CLOSED_LOOP_MODE_ACCELERATION, GO_TO_CLOSED_LOOP_MODE_ACCELERATION_TIME);
	add_to_queue(0, GO_TO_CLOSED_LOOP_MODE_COAST_TIME);
	add_to_queue(-GO_TO_CLOSED_LOOP_MODE_ACCELERATION, GO_TO_CLOSED_LOOP_MODE_ACCELERATION_TIME * 2);
	add_to_queue(0, GO_TO_CLOSED_LOOP_MODE_COAST_TIME);
	add_to_queue(GO_TO_CLOSED_LOOP_MODE_ACCELERATION, GO_TO_CLOSED_LOOP_MODE_ACCELERATION_TIME);
	go_to_closed_loop_mode_active = 1;
}


void go_to_closed_loop_mode_logic(void)
{
    if(!go_to_closed_loop_mode_active) {
    	return;
    }

    if(n_items_in_queue == 0) {
		commutation_position_offset = commutation_position_offset - desired_position;
		zero_hall_position();
		desired_position = 0;
		current_position_i64 = 0;
		current_velocity_i64 = 0;
		movement_end_position = 0;
		movement_end_time = 0;
		motor_pwm_voltage = 0;
		set_motor_control_mode(CLOSED_LOOP_POSITION_CONTROL);
		hall_position = get_hall_position();
//    		sprintf(buf, "desired_position: %d   hall_position: %d\n", (int)desired_position, (int)(hall_position));
//    		transmit(buf, strlen(buf));
		go_to_closed_loop_mode_active = 0;
    }
}


void start_capture(uint8_t capture_type)
{
    transmit("Capture start\n", 14);

	TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation

    memset(&capture, 0, sizeof(capture));
    capture.capture_type = capture_type;

    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

void capture_logic(void)
{
    uint16_t hall_data_buffer[6];
    int32_t adjusted_hall_sensor_readings[3];
    static uint16_t counter = 0;

    if(capture.capture_type == CAPTURE_HALL_SENSOR_READINGS) {
    	if(counter == 0) {
    		counter = 256;

    		hall_data_buffer[0] = (get_hall_sensor1_voltage() << 3) - HALL_SENSOR_SHIFT;
    		hall_data_buffer[1] = (get_hall_sensor2_voltage() << 3) - HALL_SENSOR_SHIFT;
    		hall_data_buffer[2] = (get_hall_sensor3_voltage() << 3) - HALL_SENSOR_SHIFT;
			hall_data_buffer[3] = 65535;
			rs485_transmit((char*)hall_data_buffer, 8);
    	}
    	counter--;
    }
    else if(capture.capture_type == CAPTURE_HALL_POSITION) {
    	if(counter == 0) {
    		counter = 256;
    		int32_t hall_position = get_hall_position();
    		memcpy(hall_data_buffer + 3, &hall_position, sizeof(hall_position));
			rs485_transmit((char*)hall_data_buffer, 12);
    	}
    	counter--;
    }
    else if(capture.capture_type == CAPTURE_ADJUSTED_HALL_SENSOR_READINGS) {
    	if(counter == 0) {
    		counter = 256;
    		int32_t hall_position = get_hall_position();
			adjust_hall_sensor_readings(hall_data_buffer, adjusted_hall_sensor_readings);
			hall_data_buffer[0] = (adjusted_hall_sensor_readings[0] >> 16) + 32768;
			hall_data_buffer[1] = (adjusted_hall_sensor_readings[1] >> 16) + 32768;
			hall_data_buffer[2] = (adjusted_hall_sensor_readings[2] >> 16) + 32768;
    		memcpy(hall_data_buffer + 3, &hall_position, sizeof(hall_position));
			hall_data_buffer[5] = 65535; // magic number to indicate the end of the data
			rs485_transmit((char*)hall_data_buffer, 12);
    	}
    	counter--;
    }
}

/*
void start_homing(int32_t max_homing_displacement)
{
	char buf[200];
	motor_control_mode = OPEN_LOOP_POSITION_CONTROL;
    clear_the_queue_and_stop();
    transmit("Homing start\n", 13);
    memset(&homing, 0, sizeof(homing));
    enable_mosfets();
    reset_six_step_sequence();
	int32_t six_step_hall_position = get_six_step_hall_position();
    homing.move_number = 1;
	homing.time = HOMING_ACCELERATION_TIME;
    homing.velocity = 0;
    if(max_homing_displacement >= 0) {
    	homing.direction = 1;
        homing.acceleration = HOMING_ACCELERATION;
    }
    else {
    	homing.direction = -1;
        homing.acceleration = -HOMING_ACCELERATION;
    }
    homing.start_position = actual_position;
    homing.start_six_step_hall_position = six_step_hall_position;
    motor_pwm_voltage = HOMING_MOTOR_PWM_VOLTAGE;
    sprintf(buf, "Home start pos: %d   time: %u   vel: %hd   accel: %hd\n", (int)desired_position, (unsigned int)homing.time, homing.velocity, homing.acceleration);
    transmit(buf, strlen(buf));
}


void handle_homing_logic(void)
{
	int32_t six_step_hall_position = get_six_step_hall_position();
    static int32_t previous_six_step_hall_position = 0;
    char buf[200];
    int32_t delta_position;
    int32_t delta_six_step_hall_position;

	if(six_step_hall_position != previous_six_step_hall_position) {
//		sprintf(buf, "delta_position: %d   delta_six_step_hall_position: %d   min_expected_delta_position: %d\n  min_expected",
//			    (int)delta_position, (int)delta_six_step_hall_position, (int)min_expected_delta_position);
//		transmit(buf, strlen(buf));
		previous_six_step_hall_position = six_step_hall_position;


	}

	if(homing.direction == 1) {
		delta_position = actual_position - homing.start_position;
		delta_six_step_hall_position = six_step_hall_position - homing.start_six_step_hall_position;
	}
	else {
		delta_position = homing.start_position - actual_position;
		delta_six_step_hall_position = homing.start_six_step_hall_position - six_step_hall_position;
	}
	int32_t position_error = delta_position - delta_six_step_hall_position * 21502;
	if(abs(position_error) > MAX_HOMING_ERROR) {
		homing.time = 0;
		homing.move_number = 4;
		transmit("Crash detected\n", 15);
	}

    if(homing.time == 0) {
        homing.move_number++;
        switch(homing.move_number) {
        case 2:
            homing.time = HOMING_COAST_TIME;
            homing.acceleration = 0;
            break;
        case 3:
            homing.time = HOMING_ACCELERATION_TIME;
            homing.acceleration = HOMING_ACCELERATION;
            break;
        default:
			chear_the_queue_and_stop();
			homing.time = 0;
			homing.acceleration = 0;
			homing.velocity = 0;
            homing.move_number = 0; // this signals that homing is no longer in progress
            break;
        }
        sprintf(buf, "%u: pos: %d   time: %u   vel: %hd   accel: %hd\n", (unsigned int)homing.move_number, (int)desired_position, (unsigned int)homing.time, homing.velocity, homing.acceleration);
        transmit(buf, strlen(buf));
    }

    homing.velocity += homing.acceleration;
    actual_position += (((int32_t)homing.velocity + (1 << (HOMING_VELOCITY_SHIFT - 1))) >> HOMING_VELOCITY_SHIFT); // implements rounding for better accuracy
    homing.time--;
}
*/





void print_position(void)
{
	char buf[100];
	sprintf(buf, "hall_position: %d   desired_position: %d\n", (int)hall_position, (int)desired_position);
	transmit(buf, strlen(buf));
}

void print_queue_stats(void)
{
	char buf[100];
	sprintf(buf, "n_items_in_queue: %u\n", (unsigned int)n_items_in_queue);
	transmit(buf, strlen(buf));
}

void print_current_movement(void)
{
	char buf[150];
	uint64_t current_time = get_microsecond_time();
	sprintf(buf, "current_time: %lu   movement_start_time: %lu   movement_end_time: %lu\n",
			(unsigned long int)current_time, (unsigned long int)movement_start_time, (unsigned long int)movement_end_time);
	transmit(buf, strlen(buf));
	sprintf(buf, "movement_start_position: %d   movement_end_position: %d   motor_control_mode: %u\n",
			(int)movement_start_position, (int)movement_end_position, (unsigned int)motor_control_mode);
	transmit(buf, strlen(buf));
	sprintf(buf, "debug_counter: %u\n", (unsigned int)debug_counter);
	transmit(buf, strlen(buf));
}


void print_velocity(void)
{
	char buf[150];
//	sprintf(buf, "desired velocity: %ld   actual velocity: %ld\n", desired_velocity, velocity);
	sprintf(buf, "velocity: %ld\n", velocity);
	transmit(buf, strlen(buf));
}


void print_time_difference(void)
{
	char buf[150];
	sprintf(buf, "time_difference1: %hu   max_time_difference1: %hu\n", time_difference1, max_time_difference1);
	transmit(buf, strlen(buf));
	max_time_difference1 = 0;

	sprintf(buf, "time_difference2: %hu   max_time_difference2: %hu\n", time_difference2, max_time_difference2);
	transmit(buf, strlen(buf));
	max_time_difference2 = 0;

	sprintf(buf, "time_difference3: %hu   max_time_difference3: %hu\n", time_difference3, max_time_difference3);
	transmit(buf, strlen(buf));
	max_time_difference3 = 0;

	sprintf(buf, "time_difference4: %hu   max_time_difference4: %hu\n", time_difference4, max_time_difference4);
	transmit(buf, strlen(buf));
	max_time_difference4 = 0;

	sprintf(buf, "time_difference5: %hu   max_time_difference5: %hu\n", time_difference5, max_time_difference5);
	transmit(buf, strlen(buf));
	max_time_difference5 = 0;

	sprintf(buf, "current_time_captured: %u   movement_end_time_captured: %u\n", (unsigned int)current_time_captured, (unsigned int)movement_end_time_captured);
	transmit(buf, strlen(buf));

	sprintf(buf, "motor_control_time_difference: %hu   max_motor_control_time_difference: %hu\n", motor_control_time_difference, max_motor_control_time_difference);
	transmit(buf, strlen(buf));
	max_motor_control_time_difference = 0;

	sprintf(buf, "motor_control_tick_time_difference: %hu   max_motor_control_tick_time_difference: %hu\n", motor_control_tick_time_difference, max_motor_control_tick_time_difference);
	transmit(buf, strlen(buf));
	max_motor_control_tick_time_difference = 0;

//	uint32_t pr = NVIC_GetPriority(TIM1_BRK_UP_TRG_COM_IRQn); // enable the interrupt to this timer
//	sprintf(buf, "interrupt priority: %u\n", (unsigned int)pr);
//	transmit(buf, strlen(buf));

	current_time_captured = 1;
	movement_end_time_captured = 1;
}


void print_motor_current(void)
{
	char buf[100];
	int16_t current = get_motor_current();
	sprintf(buf, "%hd\n", current);
	transmit(buf, strlen(buf));
}



void add_to_queue(int32_t acceleration, uint32_t n_time_steps)
{
    if(n_items_in_queue < MOVEMENT_QUEUE_SIZE) {
        movement_queue[queue_write_position].acceleration = acceleration;
        movement_queue[queue_write_position].acceleration <<= ACCELERATION_SHIFT_LEFT;
        movement_queue[queue_write_position].n_time_steps = n_time_steps;
        queue_write_position = (queue_write_position + 1) & (MOVEMENT_QUEUE_SIZE - 1);
        n_items_in_queue++;
    }
}


void move_n_steps_in_m_time(int32_t displacement, uint32_t time_delta)
{
//	uint64_t local_time = get_microsecond_time();
//	add_to_queue(desired_position - displacement, local_time + time_delta);
}


uint8_t get_n_items_in_queue(void)
{
	return n_items_in_queue;
}


void clear_the_queue_and_stop(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    clear_the_queue_and_stop_no_disable_interrupt();
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}


void add_trapazoid_move_to_queue(int32_t new_position, uint32_t max_velocity, int32_t acceleration)
{
	add_to_queue(acceleration, 1000);
	add_to_queue(0, 1000000);
	add_to_queue(-acceleration, 1000);
}


void compute_velocity(void)
{
	static int32_t previous_hall_position = 0;
	static uint16_t previous_time = 0;
	uint16_t current_time;
	int32_t delta_position;
	uint16_t delta_time;
	static uint16_t count = 0;

	count++;
	if(count >= 20) {
		count = 0;

		current_time = TIM3->CNT;

		delta_position = hall_position - previous_hall_position;
		delta_time = current_time - previous_time;
		delta_position *= VELOCITY_SCALE_FACTOR;
		velocity = delta_position / delta_time;

		previous_hall_position = hall_position;
		previous_time = current_time;
	}
}

uint8_t handle_queued_movements(void)
{
	if(n_items_in_queue > 0) {
		if(movement_queue[queue_read_position].n_time_steps > 0) {
			current_velocity_i64 += movement_queue[queue_read_position].acceleration;
			current_position_i64 += current_velocity_i64;
			desired_position = ((int32_t *)&current_position_i64)[1]; // take the most significant 32 bit number
			movement_queue[queue_read_position].n_time_steps--;
		}
		else {
		    queue_read_position = (queue_read_position + 1) & (MOVEMENT_QUEUE_SIZE - 1);
		    n_items_in_queue--;
		}
		return 1;
	}

	return 0;
}


#define PID_SHIFT_RIGHT 18
int32_t PID_controller(int32_t error)
{
    int32_t output_value;
    int32_t proportional_term;
    static int32_t integral_term = 0;
    int32_t derivative_term;
    static int32_t previous_error = 0;
    int32_t error_change;
    static int32_t low_pass_filtered_error_change = 0;
#define PROPORTIONAL_CONSTANT_PID 10800 // if exceeding 32767 then need to check whether any math will overflow below in the proportional term
#define INTEGRAL_CONSTANT_PID 0
#define DERIVATIVE_CONSTANT_PID 000000
//#define DERIVATIVE_CONSTANT_PID 250000
//#define DERIVATIVE_CONSTANT_PID 1280000

    if(error < -10000) {
        error = -10000;
    }
    else if(error > 10000) {
        error = 10000;
    }
    integral_term += (error * INTEGRAL_CONSTANT_PID);
    if(integral_term > (CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT)) {
    	integral_term = CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT;
    }
    else if(integral_term < -(CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT)) {
    	integral_term = -(CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT);
    }
    proportional_term = error * PROPORTIONAL_CONSTANT_PID;
    error_change = error - previous_error;
    if(error_change > 5000) {
    	error_change = 5000;
    }
    if(error_change < -5000) {
    	error_change = -5000;
    }

    low_pass_filtered_error_change = (low_pass_filtered_error_change * 15);
    low_pass_filtered_error_change += error_change;
    low_pass_filtered_error_change >>= 4;
    derivative_term = low_pass_filtered_error_change * DERIVATIVE_CONSTANT_PID;
    previous_error = error;
    // maximum value are (approximately):
    // integral term:       66000000
    // proportional term:  250000000
    // derivative term:   1250000000
    // sum:               1510000000
    // Make sure it does not exceed the max int32_t = 2147483647
    // After shifting, the maximum values are:
    // integral term:      250
    // proportional term:  953
    // derivative term:   4768
    // sum:               6971
    output_value = (integral_term + proportional_term + derivative_term) >> PID_SHIFT_RIGHT;

//    if(output_value < -CLOSED_LOOP_PWM_VOLTAGE) {
//        output_value = -CLOSED_LOOP_PWM_VOLTAGE;
//    }
//    else if(output_value > CLOSED_LOOP_PWM_VOLTAGE) {
//        output_value = CLOSED_LOOP_PWM_VOLTAGE;
//    }

    return output_value;
}


void motor_movement_calculations(void)
{
	uint8_t moving = 0; // 1 indicates that the motor is moving, 0 indicates that it is stopped

    if(go_to_closed_loop_mode_active) {
        go_to_closed_loop_mode_logic();
        moving = 1;
    }

//    if(calibration.move_number > 0) {
//        handle_calibration_logic();
//        moving = 1;
//    }
//      if(go_to_closed_loop_mode.move_number > 0) {
//          go_to_closed_loop_mode_logic();
//          moving = 1;
//      }

//    else if(homing.move_number > 0) {
//        handle_homing_logic();
//    	moving = 1;
//    }
//    else if(capture.capture_type) {
//        capture_logic();
//    }
    moving |= handle_queued_movements();

	if(motor_control_mode == OPEN_LOOP_POSITION_CONTROL) {
		commutation_position = desired_position + commutation_position_offset;
		if(moving) {
			motor_pwm_voltage = OPEN_LOOP_DYNAMIC_MOTOR_PWM_VOLTAGE;
		}
		else {
			motor_pwm_voltage = OPEN_LOOP_STATIC_MOTOR_PWM_VOLTAGE;
		}
	}
	else {
		commutation_position = hall_position + commutation_position_offset;
		if(motor_control_mode == CLOSED_LOOP_POSITION_CONTROL) {
			int32_t motor_maximum_allowed_pwm_voltage;

			motor_pwm_voltage = PID_controller(desired_position - hall_position);

			if(motor_pwm_voltage >= 0) {
				motor_maximum_allowed_pwm_voltage = velocity + CLOSED_LOOP_PWM_VOLTAGE;
				if(motor_pwm_voltage > motor_maximum_allowed_pwm_voltage) {
					motor_pwm_voltage = motor_maximum_allowed_pwm_voltage;
				}
				commutation_position += HALL_TO_POSITION_90_DEGREE_OFFSET;
			}
			else {
				motor_maximum_allowed_pwm_voltage = velocity - CLOSED_LOOP_PWM_VOLTAGE;
				if(motor_pwm_voltage < motor_maximum_allowed_pwm_voltage) {
					motor_pwm_voltage = motor_maximum_allowed_pwm_voltage;
				}
				commutation_position -= HALL_TO_POSITION_90_DEGREE_OFFSET;
				motor_pwm_voltage = -motor_pwm_voltage;
			}
		}
		else {
			if(desired_motor_pwm_voltage >= 0) {
				commutation_position += HALL_TO_POSITION_90_DEGREE_OFFSET;
				motor_pwm_voltage = desired_motor_pwm_voltage;
			}
			else {
				commutation_position -= HALL_TO_POSITION_90_DEGREE_OFFSET;
				motor_pwm_voltage = -desired_motor_pwm_voltage;
			}
		}
	}
}


void motor_phase_calculations(void)
{
    static uint16_t commutation_step = 0;
    static uint16_t commutation_sub_step = 0;
    static uint32_t phase1;
    static uint32_t phase2;
    static uint32_t phase3;
    static int32_t phase1_slope;
    static int32_t phase2_slope;
    static int32_t phase3_slope;
    static int32_t tmp32bit;
//    char buf[200];
//    volatile uint32_t delay;

//    sprintf(buf, "commutation_position: %u\n", (unsigned int)commutation_position);
//    transmit(buf, strlen(buf));

    commutation_step = (commutation_position >> N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT) % N_COMMUTATION_STEPS;
    commutation_sub_step = (commutation_position & 0xff) >> (8 - N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT);

//    sprintf(buf, "commutation_step: %u   commutation_sub_step: %u\n", (unsigned int)commutation_step, (unsigned int)commutation_sub_step);
//    transmit(buf, strlen(buf));

//    for(delay = 0; delay < 100000; delay++);

    phase1 = commutation_lookup_table[commutation_step].phase1;
    phase2 = commutation_lookup_table[commutation_step].phase2;
    phase3 = commutation_lookup_table[commutation_step].phase3;
    phase1_slope = commutation_lookup_table[commutation_step].phase1_slope;
    phase2_slope = commutation_lookup_table[commutation_step].phase2_slope;
    phase3_slope = commutation_lookup_table[commutation_step].phase3_slope;

    tmp32bit = phase1_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase1 = phase1 + tmp32bit;

    tmp32bit = phase2_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase2 = phase2 + tmp32bit;

    tmp32bit = phase3_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase3 = phase3 + tmp32bit;

//    sprintf(buf, "Ph: %u %u %u   Motor voltage: %u\n", (unsigned int)phase1, (unsigned int)phase2, (unsigned int)phase3, (unsigned int)motor_pwm_voltage);
//    transmit(buf, strlen(buf));

//    for(delay = 0; delay < 100000; delay++);

    phase1 >>= 8;
    phase1 *= (uint32_t)motor_pwm_voltage;
    phase1 >>= 16;
    phase1 += 13;
    TIM1->CCR1 = phase1;

    phase2 >>= 8;
    phase2 *= (uint32_t)motor_pwm_voltage;
    phase2 >>= 16;
    phase2 += 13;
    TIM1->CCR2 = phase2;

    phase3 >>= 8;
    phase3 *= (uint32_t)motor_pwm_voltage;
    phase3 >>= 16;
    phase3 += 13;
    TIM1->CCR3 = phase3;

//    sprintf(buf, "Ph: %u %u %u   Motor voltage: %u\n", (unsigned int)phase1, (unsigned int)phase2, (unsigned int)phase3, (unsigned int)motor_pwm_voltage);
//    transmit(buf, strlen(buf));
}


void TIM1_BRK_UP_TRG_COM_IRQHandler(void)
{
	uint16_t start_time;
	uint16_t start_time2;
	uint16_t end_time;
	uint16_t end_time2;
	uint16_t motor_control_tick_time;
	static uint16_t previous_motor_control_tick_time;

	start_time = TIM3->CNT;
	start_time2 = start_time;
	hall_position = get_hall_position();
	end_time = TIM3->CNT;
	time_difference1 = end_time - start_time;
	if(time_difference1 > max_time_difference1) {
    	max_time_difference1 = time_difference1;
	}

	start_time = TIM3->CNT;
	compute_velocity();
	end_time = TIM3->CNT;
	time_difference2 = end_time - start_time;
	if(time_difference2 > max_time_difference2) {
    	max_time_difference2 = time_difference2;
	}

	start_time = TIM3->CNT;
	motor_movement_calculations();
	end_time = TIM3->CNT;
	time_difference3 = end_time - start_time;
	if(time_difference3 > max_time_difference3) {
    	max_time_difference3 = time_difference3;
	}

	start_time = TIM3->CNT;
	motor_phase_calculations();
	end_time = TIM3->CNT;
	time_difference4 = end_time - start_time;
	if(time_difference4 > max_time_difference4) {
    	max_time_difference4 = time_difference4;
	}

	motor_control_tick_time = TIM3->CNT;
	motor_control_tick_time_difference = motor_control_tick_time - previous_motor_control_tick_time;
	if(motor_control_tick_time_difference > max_motor_control_tick_time_difference) {
    	max_motor_control_tick_time_difference = motor_control_tick_time_difference;
	}
	previous_motor_control_tick_time = motor_control_tick_time;

	end_time2 = TIM3->CNT;
	motor_control_time_difference = end_time2 - start_time2;
	if(motor_control_time_difference > max_motor_control_time_difference) {
    	max_motor_control_time_difference = motor_control_time_difference;
	}

	TIM1->SR = 0; // clear the interrupt flag
}


void increase_motor_pwm_voltage(void)
{
	char buf[100];
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	desired_motor_pwm_voltage++;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
	sprintf(buf, "desired_motor_pwm_voltage: %d\n", (int)desired_motor_pwm_voltage);
	transmit(buf, strlen(buf));
}

void decrease_motor_pwm_voltage(void)
{
	char buf[100];
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	desired_motor_pwm_voltage--;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
	sprintf(buf, "desired_motor_pwm_voltage: %d\n", (int)desired_motor_pwm_voltage);
	transmit(buf, strlen(buf));
}

void set_motor_control_mode(uint8_t new_motor_control_mode)
{
	motor_control_mode = new_motor_control_mode;
}

uint8_t get_motor_control_mode(void)
{
	return motor_control_mode;
}

uint32_t get_update_frequency(void)
{
	return PWM_FREQUENCY * 2;
}

void zero_position_and_hall_sensor(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    clear_the_queue_and_stop_no_disable_interrupt();
	commutation_position_offset = commutation_position_offset - desired_position;
    zero_hall_position();
	desired_position = 0;
	current_position_i64 = 0;
	current_velocity_i64 = 0;
	movement_end_position = 0;
	movement_end_time = 0;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}



void set_max_velocity(int32_t new_max_velocity)
{
	max_velocity = new_max_velocity;
}

int32_t get_max_velocity(void)
{
	return max_velocity;
}

int32_t get_desired_position(void)
{
	return desired_position;
}

void set_max_acceleration(uint16_t new_max_acceleration)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	max_acceleration = new_max_acceleration;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

void reset_time(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    clear_the_queue_and_stop_no_disable_interrupt();
    movement_end_time = 0;
    reset_microsecond_time();
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

void emergency_stop(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    disable_mosfets();
    clear_the_queue_and_stop_no_disable_interrupt();
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}


int32_t get_actual_motor_position(void)
{
	int32_t ret;

    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	if(motor_control_mode == CLOSED_LOOP_POSITION_CONTROL) {
		ret = hall_position;
	}
	else {
		ret = desired_position;
	}
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
    return ret;
}

void get_motor_status(uint8_t *buf)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	buf[0] = motor_control_mode;
	buf[1] = calibration.move_number;
	buf[2] = homing.move_number;
	buf[3] = capture.capture_type;
	buf[4] = get_mosfets_enabled();
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

