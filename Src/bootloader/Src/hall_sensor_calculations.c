#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "stm32g0xx_hal.h"
#include "CommutationTable.h"  // generated by a program called process_raw_hall_data.py
#include "hall_sensor_calculations.h"
#include "error_handling.h"
#include "ADC.h"
#include "debug_uart.h"

#define UINT32_MIDPOINT 2147483648
#define HALL_POSITION_HYSTERESIS 100

// set which axis this motor is controlling
#ifdef X_AXIS
	#include "LookupTableX.h"
#else
	#ifdef Y_AXIS
		#include "LookupTableY.h"
	#else
		#ifdef Z_AXIS
			#include "LookupTableZ.h"
		#else
			#ifdef SMALL_Z_AXIS
				#include "LookupTablez.h"
			#else
				#ifdef E_AXIS
					#include "LookupTableE.h"
				#else
					#error "You need to set an axis"
				#endif
			#endif
		#endif
	#endif
#endif

static const struct hall_weights_struct hall_weights = HALL_WEIGHTS_INITIALIZER;

extern uint16_t ADC_buffer[DMA_ADC_BUFFER_SIZE];

static int8_t previous_largest_sensor = -1;
static int32_t sensor_incremental_position = 0;
static int32_t hall_sensor_offset = 0;
static uint16_t time_difference_div = 0;
static int32_t hall_position_with_hysteresis = 0;

void adjust_hall_sensor_readings(uint16_t hall_sensor_readings[3], int32_t adjusted_hall_sensor_readings[3])
{
	int32_t d0_shifted = (int32_t)(hall_sensor_readings[0] - HALL1_MIDLINE);
	int32_t d1_shifted = (int32_t)(hall_sensor_readings[1] - HALL2_MIDLINE);
	int32_t d2_shifted = (int32_t)(hall_sensor_readings[2] - HALL3_MIDLINE);
    int32_t d0 = (d0_shifted * hall_weights.h1[0] + d1_shifted * hall_weights.h1[1] + d2_shifted * hall_weights.h1[2]);
    int32_t d1 = (d1_shifted * hall_weights.h2[0] + d2_shifted * hall_weights.h2[1] + d0_shifted * hall_weights.h2[2]);
    int32_t d2 = (d2_shifted * hall_weights.h3[0] + d0_shifted * hall_weights.h3[1] + d1_shifted * hall_weights.h3[2]);
    adjusted_hall_sensor_readings[0] = d0;
    adjusted_hall_sensor_readings[1] = d1;
    adjusted_hall_sensor_readings[2] = d2;
}

int32_t get_hall_position(void)
{
    uint16_t hall_sensor_readings[3];
	int32_t d[3];
    int8_t largest_sensor;
    int32_t numerator;
    int32_t denominator;
    int32_t fraction;
    static uint16_t start_time;
	static uint16_t end_time;


	hall_sensor_readings[0] = ((ADC_buffer[1] + ADC_buffer[1 + 8] + ADC_buffer[1 + 16] + ADC_buffer[1 + 24]) << 3) - HALL_SENSOR_SHIFT;
	hall_sensor_readings[1] = ((ADC_buffer[3] + ADC_buffer[3 + 8] + ADC_buffer[3 + 16] + ADC_buffer[3 + 24]) << 3) - HALL_SENSOR_SHIFT;
	hall_sensor_readings[2] = ((ADC_buffer[5] + ADC_buffer[5 + 8] + ADC_buffer[5 + 16] + ADC_buffer[5 + 24]) << 3) - HALL_SENSOR_SHIFT;
	adjust_hall_sensor_readings(hall_sensor_readings, d);

    if((d[0] > d[1]) && (d[0] > d[2])) {
        largest_sensor = 0;
        numerator = d[1] - d[2];
        if(d[2] > d[1]) {
            denominator = d[0] - d[1];
        }
        else {
            denominator = d[0] - d[2];
        }
    }
    else if ((d[1] > d[2]) && (d[1] > d[0])) {
        largest_sensor = 1;
        numerator = d[2] - d[0];
        if(d[0] > d[2]) {
            denominator = d[1] - d[2];
        }
        else {
            denominator = d[1] - d[0];
        }
    }
    else {
        largest_sensor = 2;
        numerator = d[0] - d[1];
        if(d[1] > d[0]) {
            denominator = d[2] - d[0];
        }
        else {
            denominator = d[2] - d[1];
        }
    }

    numerator >>= 10;
    denominator >>= 10;

    start_time = TIM14->CNT;
    // watch out: it seems that this division will give the wrong result if the denominator exceeds the int16_t range
    fraction = numerator * SENSOR_SEGMENT_RESOLUTION_DIV_2 / denominator;
    end_time = TIM14->CNT;
    time_difference_div = end_time - start_time;
    fraction = fraction + SENSOR_SEGMENT_RESOLUTION_DIV_2;


    if(previous_largest_sensor == -1) {
        previous_largest_sensor = largest_sensor;
    }
    if (largest_sensor != previous_largest_sensor) {
        if (largest_sensor - previous_largest_sensor == 1) {
            sensor_incremental_position = sensor_incremental_position + SENSOR_SEGMENT_RESOLUTION;
//            red_LED_on();
        }
        else if (largest_sensor - previous_largest_sensor == -1) {
            sensor_incremental_position = sensor_incremental_position - SENSOR_SEGMENT_RESOLUTION;
//            red_LED_off();
        }
        else if (largest_sensor - previous_largest_sensor == -2) {
            sensor_incremental_position = sensor_incremental_position + SENSOR_SEGMENT_RESOLUTION;
//            red_LED_on();
        }
        else {
            sensor_incremental_position = sensor_incremental_position - SENSOR_SEGMENT_RESOLUTION;
//            red_LED_off();
        }
        previous_largest_sensor = largest_sensor;
    }

	return sensor_incremental_position + fraction - hall_sensor_offset;
}


int32_t get_hall_position_with_hysteresis(void)
{
	int32_t hall_position;

	hall_position = get_hall_position();
	if(hall_position > hall_position_with_hysteresis) {
		hall_position_with_hysteresis = hall_position;
	}
	else if(hall_position + HALL_POSITION_HYSTERESIS < hall_position_with_hysteresis) {
		hall_position_with_hysteresis = hall_position + HALL_POSITION_HYSTERESIS;
	}

	return hall_position_with_hysteresis;
}


void zero_hall_position(void)
{
	previous_largest_sensor = -1;
	sensor_incremental_position = 0;
	hall_sensor_offset = 0;
	int32_t hall_position = get_hall_position();
	hall_sensor_offset = hall_position;
}


void print_hall_position(void)
{
	char buf[100];
	int32_t hall_position = get_hall_position();
	sprintf(buf, "hall_position: %d   time_difference_div: %hu\n", (int)hall_position, time_difference_div);
	transmit(buf, strlen(buf));
}




