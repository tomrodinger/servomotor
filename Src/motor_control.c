#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "stm32g0xx_hal.h"
#include "microsecond_clock.h"
#include "debug_uart.h"
#include "PWM.h"
#include "ADC.h"
#include "hall_sensor_calculations.h"
#include "mosfets.h"
#include "CommutationTable.h"  // generated by a program called process_raw_hall_data.py
#include "error_handling.h"
#include "RS485.h"
#include "motor_control.h"
#include "leds.h"
#include "step_direction_input.h"
#include "LookupTableZ.h"

#define MAX_HOMING_ERROR 100000

#define POWER_MULTIPLIER 1

#define CLOSED_LOOP_PWM_VOLTAGE (100 * POWER_MULTIPLIER)
#define OPEN_LOOP_STATIC_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)
#define OPEN_LOOP_DYNAMIC_MOTOR_PWM_VOLTAGE (125 * POWER_MULTIPLIER)
#define CALIBRATION_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)
#define GO_TO_CLOSED_LOOP_MODE_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)
#define HOMING_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)

#define MAX_PWM_VOLTAGE_ADJUSTMENT 400

#define VELOCITY_SCALE_FACTOR 11
#define UINT32_MIDPOINT 2147483648
// This is the number of microsteps to turn the motor through one quarter of one commutation cycle (not one revolution)
#define HALL_TO_POSITION_90_DEGREE_OFFSET ((N_COMMUTATION_STEPS * N_COMMUTATION_SUB_STEPS) >> 2)

const struct three_phase_data_struct commutation_lookup_table[N_COMMUTATION_STEPS] = COMMUTATION_LOOKUP_TABLE_INITIALIZER;

#define ACCELERATION_SHIFT_LEFT 8
#define VELOCITY_SHIFT_LEFT 12
#define MOVEMENT_QUEUE_SIZE 16 // this has to be a power of 2
typedef struct {
	movement_type_t movement_type;
	union {
	    int64_t acceleration; // we use this variable if the movement_type == MOVE_WITH_ACCELERATION
	    int64_t velocity;     // we use this variable if the movement_type == MOVE_WITH_VELOCITY
	};
    uint32_t n_time_steps;
} movement_queue_t;
static movement_queue_t movement_queue[MOVEMENT_QUEUE_SIZE];
static uint8_t queue_write_position = 0;
static uint8_t queue_read_position = 0;
static uint8_t n_items_in_queue = 0;

static int32_t hall_position = 0;
static int32_t velocity = 0;
static uint64_t movement_end_time = 0;
static int64_t current_velocity_i64 = 0;
static int64_t current_position_i64 = 0;
static int32_t desired_position = 0; // this is the target position
static uint32_t commutation_position = 0;
static uint32_t commutation_position_offset = UINT32_MIDPOINT;
static uint64_t movement_start_time = 0;
static int32_t movement_start_position = 0;
static int32_t movement_end_position = 0;
//static int64_t max_acceleration = MAX_ACCELERATION;
static int64_t max_acceleration = 1418633883;
//static int64_t max_velocity = MAX_VELOCITY;
static int64_t max_velocity = 2954937499648;
static int32_t motor_pwm_voltage = 0;
static int32_t desired_motor_pwm_voltage = 0;
//static int32_t desired_velocity = 0;
static uint8_t motor_control_mode = OPEN_LOOP_POSITION_CONTROL;

static uint8_t go_to_closed_loop_mode_active = 0;
static int32_t commutation_scan_microsteps;
static uint8_t vibration_four_step;
static int32_t sum_delta;
static int32_t previous_hall_position;
static int32_t motor_pwm_voltage_limit;
static int32_t vibration_polarity_moving_average;
static int32_t max_motor_pwm_voltage_limit;
static uint32_t commutation_position_offset_at_max;

static uint8_t homing_active = 0;
static uint8_t calibration_active = 0;
static uint32_t calibration_index = 0;
static uint8_t decelerate_to_stop_active = 0;


static uint32_t debug_counter = 0;
static uint16_t time_difference1 = 0;
static uint16_t time_difference2 = 0;
static uint16_t time_difference3 = 0;
static uint16_t time_difference4 = 0;
static uint16_t time_difference5 = 0;
static uint16_t max_time_difference1 = 0;
static uint16_t max_time_difference2 = 0;
static uint16_t max_time_difference3 = 0;
static uint16_t max_time_difference4 = 0;
static uint16_t max_time_difference5 = 0;
static uint64_t current_time_captured = 0;
static uint64_t movement_end_time_captured;
static uint16_t motor_control_tick_time_difference = 0;
static uint16_t max_motor_control_tick_time_difference = 0;
static uint16_t motor_control_time_difference = 0;
static uint16_t max_motor_control_time_difference = 0;

//extern uint16_t ADC_buffer[DMA_ADC_BUFFER_SIZE];


// for the following calibration movement calculations, the time unit is one motor calculation cycle. at the time of this
// writing, this is roughly 25 microseconds. it may be noted elsewhere what this is more accurately.

// this is the velocity used during coast phases of the calibration.
// CALIBRATION_MAX_VELOCITY is in units of motor microsteps per time unit.
// for example, 64 means that the motor will take 64 microsteps per time unit.
#define CALIBRATION_MAX_VELOCITY CALIBRATION_CAPTURE_STEP_SIZE

#define CALIBRATION_VELOCITY_SHIFT 7 // this is how many binary decimal places we are keeping for the calibration velocity value

#define CALIBRATION_ACCELERATION 1 // this is the acceleration used during calibration. the units are microsteps divided by
                                   // (1 << CALIBRATION_VELOCITY_SHIFT) per one unit of time squared.

// this is the time to accelerate or decelerate during calibration. careful that this number ends up being an integer.
#define CALIBRATION_ACCELERATION_TIME ((CALIBRATION_MAX_VELOCITY << CALIBRATION_VELOCITY_SHIFT) / CALIBRATION_ACCELERATION)

// this is the distance delta during one acceleration or deceleration move in the unit of microsteps
#define CALIBRATION_ACCELERATION_DISTANCE ((((((uint32_t)CALIBRATION_ACCELERATION_TIME * (uint32_t)(CALIBRATION_ACCELERATION_TIME + 1)) >> 1) * CALIBRATION_ACCELERATION) >> CALIBRATION_VELOCITY_SHIFT))

// this is the time to coast at constant velocity such that the distance covered is CALIBRATION_ACCELERATION_DISTANCE
#define CALIBRATION_SMALL_COAST_TIME ((uint16_t)((uint32_t)CALIBRATION_ACCELERATION_DISTANCE / CALIBRATION_MAX_VELOCITY))

// this is the movement distance to cover exactly one rotation of the hall sensor magnetic disc in the unit of microsteps
#define CALIBRATION_MOVEMENT_DISTANCE ((int32_t)N_COMMUTATION_STEPS * (int32_t)N_COMMUTATION_SUB_STEPS * (int32_t)ONE_REVOLUTION_STEPS)

// this is the time to coast at constant velocity while capturing hall sensor readings. this should be exactly such that after one
// coast phase, the motor will rotate through one hall sensor revolution (ie. moves CALIBRATION_MOVEMENT_DISTANCE).
#define CALIBRATION_COAST_TIME (CALIBRATION_MOVEMENT_DISTANCE / CALIBRATION_MAX_VELOCITY)



#define CAPTURE_HALL_SENSOR_READINGS 1
#define CAPTURE_HALL_POSITION 2
#define CAPTURE_ADJUSTED_HALL_SENSOR_READINGS 3


#define HOMING_MAX_VELOCITY 32

#define HOMING_VELOCITY_SHIFT 8 // this is how many binary decimal places we are keeping for the homing velocity value

#define HOMING_ACCELERATION 1 // this is the acceleration used during calibration. the units are microsteps divided by
                                   // (1 << HOMING_VELOCITY_SHIFT) per one unit of time squared.

// this is the time to accelerate or decelerate during calibration. careful that this number ends up being an integer.
#define HOMING_ACCELERATION_TIME ((HOMING_MAX_VELOCITY << HOMING_VELOCITY_SHIFT) / HOMING_ACCELERATION)

// this is the distance delta during one acceleration or deceleration move in the unit of microsteps
#define HOMING_ACCELERATION_DISTANCE ((((((uint32_t)HOMING_ACCELERATION_TIME * (uint32_t)(HOMING_ACCELERATION_TIME + 1)) >> 1) * HOMING_ACCELERATION) >> HOMING_VELOCITY_SHIFT))

// this is the time to coast at constant velocity such that the distance covered is HOMING_ACCELERATION_DISTANCE
#define HOMING_SMALL_COAST_TIME ((uint16_t)((uint32_t)HOMING_ACCELERATION_DISTANCE / HOMING_MAX_VELOCITY))

#define HOMING_MAX_REVOLUTIONS 300

// this is the movement distance to cover exactly one rotation of the hall sensor magnetic disc in the unit of microsteps
#define HOMING_MOVEMENT_DISTANCE (N_COMMUTATION_STEPS * N_COMMUTATION_SUB_STEPS * ONE_REVOLUTION_STEPS * HOMING_MAX_REVOLUTIONS)

// this is the time to coast at constant velocity while capturing hall sensor readings. this should be exactly such that after one
// coast phase, the motor will rotate through one hall sensor revolution (ie. moves HOMING_MOVEMENT_DISTANCE).
#define HOMING_COAST_TIME (HOMING_MOVEMENT_DISTANCE / HOMING_MAX_VELOCITY)


/*
 * Example:
 *    CALIBRATION_MAX_VELOCITY 64
 *    CALIBRATION_VELOCITY_SHIFT 8
 *    CALIBRATION_ACCELERATION 1
 *    CALIBRATION_ACCELERATION_TIME 16384
 *    CALIBRATION_ACCELERATION_DISTANCE 524320
 *    CALIBRATION_SMALL_COAST_TIME 8192.5 rounded down to 8192
 *    CALIBRATION_COAST_TIME 10080
 *    CALIBRATION_MOVEMENT_DISTANCE 645120
 */

#define CALIBRATION_DATA_SIZE 300
struct calibration_struct {
	int16_t position;
    uint16_t hall1;
    uint16_t hall2;
    uint16_t hall3;
};
struct calibration_struct calibration[CALIBRATION_DATA_SIZE];


struct capture_struct {
    uint8_t capture_type;
    uint8_t avg_counter;
    uint16_t hall1_sum;
    uint16_t hall2_sum;
    uint16_t hall3_sum;
};
struct capture_struct capture = {0};


struct homing_struct {
    uint8_t move_number;
    int8_t direction;
    uint32_t time;
    int16_t velocity;
    int16_t acceleration;
    int32_t start_position;
    int32_t start_six_step_hall_position;
};
struct homing_struct homing = {0};


struct closed_loop_struct {
    uint8_t move_number;
    uint32_t time;
    int16_t velocity;
    int16_t acceleration;
    uint8_t capturing_data;
    uint8_t avg_counter;
    uint32_t hall1_sum;
    uint32_t hall2_sum;
    uint32_t hall3_sum;
    uint16_t max_hall_reading;
    int32_t max_hall_position;
    int32_t max_hall_distance;
};
struct closed_loop_struct closed_loop = {0};


void clear_the_queue_and_stop_no_disable_interrupt(void)
{
    queue_read_position = 0;
    queue_write_position = 0;
    n_items_in_queue = 0;
    movement_end_time = 0;
    movement_end_position = desired_position;
}


/*
delta_t = 3000000
delta_d = int(microsteps_per_rotation * 1.0 + 0.5)
delta_t1 = int(max_velocity / max_acceleration + 0.5)
if 2 * delta_t1 > delta_t:
    print("Doing the special case of the move where the time is very short but so is the distance")
    delta_t1 = delta_t // 2
delta_t2 = delta_t - 2 * delta_t1
numerator = delta_d
denominator = ((delta_t1 + delta_t2) * delta_t1)
acceleration = int(delta_d / ((delta_t1 + delta_t2) * delta_t1) + 0.5)
*/

void compute_trapezoid_move(int32_t total_displacement, uint32_t total_time, int32_t *acceleration_returned, uint32_t *delta_t1_returned, uint32_t *delta_t2_returned)
{
	int64_t delta_d = (int64_t)total_displacement << 24;
//	uint32_t delta_t1 = ((max_acceleration >> 1) + max_velocity) / max_acceleration; // calculating detal_t1 with rounding
	int64_t delta_t1 = max_velocity / max_acceleration; // calculating detal_t1 without rounding
	if((delta_t1 << 1) > total_time) {
	    delta_t1 = total_time >> 1;
	}
	uint32_t delta_t2 = total_time - (delta_t1 << 1);
	int64_t numerator = delta_d;
	int64_t denominator = ((delta_t1 + delta_t2) * delta_t1);
	int64_t acceleration = numerator / denominator;

	print_int64("max_velocity: ", max_velocity);
	print_int64("max_acceleration: ", max_acceleration);
	print_int64("delta_d: ", (int64_t)delta_d);
	print_int64("delta_t: ", (int64_t)total_time);
	print_int64("delta_t1: ", (int64_t)delta_t1);
	print_int64("delta_t2: ", (int64_t)delta_t2);
	print_int64("numerator: ", (int64_t)numerator);
	print_int64("denominator: ", (int64_t)denominator);
	print_int64("acceleration: ", (int64_t)acceleration);

//	acceleration >>= 8;
	*acceleration_returned = acceleration;
	*delta_t1_returned = (uint32_t)delta_t1;
	*delta_t2_returned = (uint32_t)delta_t2;
}


#define CALIBRATION_TIME (get_update_frequency() * 2)
#define CALIBRATION_DISTANCE (N_COMMUTATION_STEPS * N_COMMUTATION_SUB_STEPS * ONE_REVOLUTION_STEPS * 2)
void start_calibration(uint8_t verbose_data)
{
	int32_t acceleration;
	uint32_t delta_t1;
	uint32_t delta_t2;

	if(motor_control_mode != OPEN_LOOP_POSITION_CONTROL) {
		fatal_error("not in open loop", 10);
	}

	if(n_items_in_queue != 0) {
		fatal_error("queue not empty", 9);
	}

	compute_trapezoid_move(CALIBRATION_DISTANCE, CALIBRATION_TIME / 2, &acceleration, &delta_t1, &delta_t2);

	add_to_queue(-acceleration, delta_t1, MOVE_WITH_ACCELERATION);
	add_to_queue(0, delta_t2, MOVE_WITH_ACCELERATION);
	add_to_queue(acceleration, delta_t1 * 2, MOVE_WITH_ACCELERATION);
	add_to_queue(0, delta_t2, MOVE_WITH_ACCELERATION);
	add_to_queue(-acceleration, delta_t1, MOVE_WITH_ACCELERATION);

/*
	max_velocity = MAX_VELOCITY;
	max_acceleration = MAX_ACCELERATION;

	add_trapezoid_move_to_queue(CALIBRATION_DISTANCE, CALIBRATION_TIME / 2);
	add_trapezoid_move_to_queue(-CALIBRATION_DISTANCE, CALIBRATION_TIME / 2);
*/
	calibration_index = 0;
	calibration_active = 1;
}

void handle_calibration_logic(void)
{
	if(n_items_in_queue == 2) {
		if(calibration_index < CALIBRATION_DATA_SIZE) {
			calibration[calibration_index].hall1 = get_hall_sensor1_voltage();
			calibration[calibration_index].hall2 = get_hall_sensor2_voltage();
			calibration[calibration_index].hall3 = get_hall_sensor3_voltage();
			calibration_index++;
		}
	}
	else if(n_items_in_queue == 0) {
		calibration_active = 0;
	}
}


#define MOTOR_PWM_VOLTAGE_LIMIT_MINIMUM 10
#define MOTOR_PWM_VOLTAGE_LIMIT_MAXIMUM 120
#define COMMUTATION_SCAN_MICROSTEPS (256 * 360) // one electrical rotation
#define COMMUTATION_SCAN_STEP_FACTOR 1
//#define COMMUTATION_SCAN_STEP_SIZE (256 * 360 / COMMUTATION_SCAN_STEPS)
#define GO_TO_CLOSED_LOOP_VIBRATION_MAGNITUDE 100
#define MOVING_AVERAGE_SHIFT_RIGHT 7
void start_go_to_closed_loop_mode(void)
{
	transmit("Go to closed loop mode start\n", 29);

	TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation

	clear_the_queue_and_stop_no_disable_interrupt();
	set_motor_control_mode(OPEN_LOOP_PWM_VOLTAGE_CONTROL);
	enable_mosfets();
	commutation_position_offset = UINT32_MIDPOINT;
	vibration_four_step = 0;
	commutation_scan_microsteps = 0;
	desired_motor_pwm_voltage = 0;
	go_to_closed_loop_mode_active = 1;
	motor_pwm_voltage_limit = MOTOR_PWM_VOLTAGE_LIMIT_MINIMUM;
//	sum_abs_delta = 0;
	sum_delta = 0;
	previous_hall_position = hall_position;
	vibration_polarity_moving_average = 0;
	max_motor_pwm_voltage_limit = 0;
	zero_hall_position();

    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

void go_to_closed_loop_mode_logic(void)
{
	char buf[30];
	if(commutation_scan_microsteps < COMMUTATION_SCAN_MICROSTEPS) {
		int32_t hall_position_delta = hall_position - previous_hall_position;
		previous_hall_position = hall_position;
//		if(hall_position_delta < 0) {
//			hall_position_delta = -hall_position_delta;
//		}
//		sum_abs_delta += hall_position_delta;
		switch(vibration_four_step) {
		case 0:
			sum_delta += hall_position_delta;
			desired_motor_pwm_voltage++;
			if(desired_motor_pwm_voltage >= motor_pwm_voltage_limit) {
				vibration_four_step++;
			}
			break;
		case 1:
		case 2:
			sum_delta -= hall_position_delta;
			desired_motor_pwm_voltage--;
			if(desired_motor_pwm_voltage <= -motor_pwm_voltage_limit) {
				vibration_four_step++;
			}
			break;
		case 3:
			sum_delta += hall_position_delta;
			desired_motor_pwm_voltage++;
			if(desired_motor_pwm_voltage >= motor_pwm_voltage_limit) {
				vibration_four_step = 0;
				int32_t step_size = (MOTOR_PWM_VOLTAGE_LIMIT_MAXIMUM - motor_pwm_voltage_limit + 1) * COMMUTATION_SCAN_STEP_FACTOR;
				commutation_scan_microsteps += step_size;
				if(sum_delta > 0) {
					if(vibration_polarity_moving_average >= 0) {
						vibration_polarity_moving_average++;
					}
					else {
						vibration_polarity_moving_average += 2;
					}
				}
				else if(sum_delta < 0) {
					if(vibration_polarity_moving_average <= 0) {
						vibration_polarity_moving_average--;
					}
					else {
						vibration_polarity_moving_average -= 2;
					}
				}
//				vibration_polarity_moving_average = (vibration_polarity_moving_average * ((1 << MOVING_AVERAGE_SHIFT_RIGHT) - 1) + sum_delta) >> MOVING_AVERAGE_SHIFT_RIGHT;
				if(sum_delta >= 0) {
//					print_number("", (uint16_t)sum_delta);
				}
				else {
					sum_delta = -sum_delta;
//					print_number("-", (uint16_t)sum_delta);
				}
				if(sum_delta > GO_TO_CLOSED_LOOP_VIBRATION_MAGNITUDE) {
					if(motor_pwm_voltage_limit > MOTOR_PWM_VOLTAGE_LIMIT_MINIMUM) {
						motor_pwm_voltage_limit--;
					}
				}
				else {
					if(motor_pwm_voltage_limit < MOTOR_PWM_VOLTAGE_LIMIT_MAXIMUM) {
						motor_pwm_voltage_limit++;
					}
				}
				if(motor_pwm_voltage_limit > max_motor_pwm_voltage_limit) {
					max_motor_pwm_voltage_limit = motor_pwm_voltage_limit;
					commutation_position_offset_at_max = commutation_position_offset;
					if(vibration_polarity_moving_average < 0) {
						commutation_position_offset_at_max -= HALL_TO_POSITION_90_DEGREE_OFFSET;
					}
					else {
						commutation_position_offset_at_max += HALL_TO_POSITION_90_DEGREE_OFFSET;
					}
				}
				commutation_position_offset += step_size;
				sprintf(buf, "%hu %ld\n", (uint16_t)motor_pwm_voltage_limit, vibration_polarity_moving_average);
				transmit(buf, strlen(buf));
				sum_delta = 0;
			}
			break;
		default:
			fatal_error("vibration four step", 7);
		}
	}
	else {
		commutation_position_offset = commutation_position_offset_at_max;
		desired_position = 0;
		current_position_i64 = 0;
		current_velocity_i64 = 0;
		movement_end_position = 0;
		movement_end_time = 0;
		motor_pwm_voltage = 0;
		set_motor_control_mode(CLOSED_LOOP_POSITION_CONTROL);
		hall_position = get_hall_position();
//    		sprintf(buf, "desired_position: %d   hall_position: %d\n", (int)desired_position, (int)(hall_position));
//    		transmit(buf, strlen(buf));
		go_to_closed_loop_mode_active = 0;
    }
}


void start_capture(uint8_t capture_type)
{
    transmit("Capture start\n", 14);

	TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation

    memset(&capture, 0, sizeof(capture));
    capture.capture_type = capture_type;

    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

void capture_logic(void)
{
    uint16_t hall_data_buffer[6];
    int32_t adjusted_hall_sensor_readings[3];
    static uint16_t counter = 0;

    if(capture.capture_type == CAPTURE_HALL_SENSOR_READINGS) {
    	if(counter == 0) {
    		counter = 256;

    		hall_data_buffer[0] = (get_hall_sensor1_voltage() << 3) - HALL_SENSOR_SHIFT;
    		hall_data_buffer[1] = (get_hall_sensor2_voltage() << 3) - HALL_SENSOR_SHIFT;
    		hall_data_buffer[2] = (get_hall_sensor3_voltage() << 3) - HALL_SENSOR_SHIFT;
			hall_data_buffer[3] = 65535;
			rs485_transmit((char*)hall_data_buffer, 8);
    	}
    	counter--;
    }
    else if(capture.capture_type == CAPTURE_HALL_POSITION) {
    	if(counter == 0) {
    		counter = 256;
    		int32_t hall_position = get_hall_position();
    		memcpy(hall_data_buffer + 3, &hall_position, sizeof(hall_position));
			rs485_transmit((char*)hall_data_buffer, 12);
    	}
    	counter--;
    }
    else if(capture.capture_type == CAPTURE_ADJUSTED_HALL_SENSOR_READINGS) {
    	if(counter == 0) {
    		counter = 256;
    		int32_t hall_position = get_hall_position();
			adjust_hall_sensor_readings(hall_data_buffer, adjusted_hall_sensor_readings);
			hall_data_buffer[0] = (adjusted_hall_sensor_readings[0] >> 16) + 32768;
			hall_data_buffer[1] = (adjusted_hall_sensor_readings[1] >> 16) + 32768;
			hall_data_buffer[2] = (adjusted_hall_sensor_readings[2] >> 16) + 32768;
    		memcpy(hall_data_buffer + 3, &hall_position, sizeof(hall_position));
			hall_data_buffer[5] = 65535; // magic number to indicate the end of the data
			rs485_transmit((char*)hall_data_buffer, 12);
    	}
    	counter--;
    }
}

void start_homing(int32_t max_homing_displacement, uint32_t max_homing_time)
{
	if(motor_control_mode != CLOSED_LOOP_POSITION_CONTROL) {
		fatal_error("not in closed loop", 8);
	}

	if(n_items_in_queue != 0) {
		fatal_error("queue not empty", 9);
	}

	add_trapezoid_move_to_queue(max_homing_displacement, max_homing_time);

	homing_active = 1;
}

#define HOMING_MAX_POSITION_ERROR 10000
void handle_homing_logic(void)
{
	int32_t position_error;
	position_error = abs(desired_position - hall_position);

	if(position_error > HOMING_MAX_POSITION_ERROR) {
		homing_active = 0;
		clear_the_queue_and_stop_no_disable_interrupt();
		current_velocity_i64 = 0; // detected a colision so stop where we are
		if(desired_position >= hall_position) {
			((int32_t *)&current_position_i64)[1] -= HOMING_MAX_POSITION_ERROR;
		}
		else {
			((int32_t *)&current_position_i64)[1] += HOMING_MAX_POSITION_ERROR;
		}
	}

	if(n_items_in_queue == 0) {
		homing_active = 0;
	}
}


void print_position(void)
{
	char buf[100];
	sprintf(buf, "hall_position: %d   desired_position: %d\n", (int)hall_position, (int)desired_position);
	transmit(buf, strlen(buf));
}

void print_queue_stats(void)
{
	char buf[100];
	sprintf(buf, "n_items_in_queue: %u\n", (unsigned int)n_items_in_queue);
	transmit(buf, strlen(buf));
}

void print_current_movement(void)
{
	char buf[150];
	uint64_t current_time = get_microsecond_time();
	sprintf(buf, "current_time: %lu   movement_start_time: %lu   movement_end_time: %lu\n",
			(unsigned long int)current_time, (unsigned long int)movement_start_time, (unsigned long int)movement_end_time);
	transmit(buf, strlen(buf));
	sprintf(buf, "movement_start_position: %d   movement_end_position: %d   motor_control_mode: %u\n",
			(int)movement_start_position, (int)movement_end_position, (unsigned int)motor_control_mode);
	transmit(buf, strlen(buf));
	sprintf(buf, "debug_counter: %u\n", (unsigned int)debug_counter);
	transmit(buf, strlen(buf));
}


void print_velocity(void)
{
	char buf[150];
//	sprintf(buf, "desired velocity: %ld   actual velocity: %ld\n", desired_velocity, velocity);
	sprintf(buf, "velocity: %ld\n", velocity);
	transmit(buf, strlen(buf));
}


void print_time_difference(void)
{
	char buf[150];
	sprintf(buf, "time_difference1: %hu   max_time_difference1: %hu\n", time_difference1, max_time_difference1);
	transmit(buf, strlen(buf));
	max_time_difference1 = 0;

	sprintf(buf, "time_difference2: %hu   max_time_difference2: %hu\n", time_difference2, max_time_difference2);
	transmit(buf, strlen(buf));
	max_time_difference2 = 0;

	sprintf(buf, "time_difference3: %hu   max_time_difference3: %hu\n", time_difference3, max_time_difference3);
	transmit(buf, strlen(buf));
	max_time_difference3 = 0;

	sprintf(buf, "time_difference4: %hu   max_time_difference4: %hu\n", time_difference4, max_time_difference4);
	transmit(buf, strlen(buf));
	max_time_difference4 = 0;

	sprintf(buf, "time_difference5: %hu   max_time_difference5: %hu\n", time_difference5, max_time_difference5);
	transmit(buf, strlen(buf));
	max_time_difference5 = 0;

	sprintf(buf, "current_time_captured: %u   movement_end_time_captured: %u\n", (unsigned int)current_time_captured, (unsigned int)movement_end_time_captured);
	transmit(buf, strlen(buf));

	sprintf(buf, "motor_control_time_difference: %hu   max_motor_control_time_difference: %hu\n", motor_control_time_difference, max_motor_control_time_difference);
	transmit(buf, strlen(buf));
	max_motor_control_time_difference = 0;

	sprintf(buf, "motor_control_tick_time_difference: %hu   max_motor_control_tick_time_difference: %hu\n", motor_control_tick_time_difference, max_motor_control_tick_time_difference);
	transmit(buf, strlen(buf));
	max_motor_control_tick_time_difference = 0;

//	uint32_t pr = NVIC_GetPriority(TIM1_BRK_UP_TRG_COM_IRQn); // enable the interrupt to this timer
//	sprintf(buf, "interrupt priority: %u\n", (unsigned int)pr);
//	transmit(buf, strlen(buf));

	current_time_captured = 1;
	movement_end_time_captured = 1;
}


void print_motor_current(void)
{
	char buf[100];
	int16_t current = get_motor_current();
	sprintf(buf, "%hd\n", current);
	transmit(buf, strlen(buf));
}


void add_to_queue(int32_t parameter, uint32_t n_time_steps, movement_type_t movement_type)
{	
	if(n_time_steps == 0) {
		return; // in the case that the number if time steps is zero, it makes sense to not anything to the queue
	}
    if(n_items_in_queue < MOVEMENT_QUEUE_SIZE) {
		movement_queue[queue_write_position].movement_type = movement_type;
		if(movement_type == 0) {
	        movement_queue[queue_write_position].acceleration = parameter;
    	    movement_queue[queue_write_position].acceleration <<= ACCELERATION_SHIFT_LEFT;
            if(abs(movement_queue[queue_write_position].acceleration) > max_acceleration) {
	            fatal_error("accel too high", 11);
            }
		}
		else {
	        movement_queue[queue_write_position].velocity = parameter;
    	    movement_queue[queue_write_position].velocity <<= VELOCITY_SHIFT_LEFT;
            if(abs(movement_queue[queue_write_position].velocity) > max_velocity) {
	            fatal_error("vel too high", 12);
            }
		}
        movement_queue[queue_write_position].n_time_steps = n_time_steps;
        queue_write_position = (queue_write_position + 1) & (MOVEMENT_QUEUE_SIZE - 1);
        n_items_in_queue++;
    }
	else {
		fatal_error("queue is full", 6);
	}
}


void move_n_steps_in_m_time(int32_t displacement, uint32_t time_delta)
{
//	uint64_t local_time = get_microsecond_time();
//	add_to_queue(desired_position - displacement, local_time + time_delta);
}


uint8_t get_n_items_in_queue(void)
{
	return n_items_in_queue;
}


void clear_the_queue_and_stop(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    clear_the_queue_and_stop_no_disable_interrupt();
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}


void add_trapezoid_move_to_queue(int32_t total_displacement, uint32_t total_time)
{
	int32_t acceleration;
	uint32_t delta_t1;
	uint32_t delta_t2;

	compute_trapezoid_move(total_displacement, total_time, &acceleration, &delta_t1, &delta_t2);

	add_to_queue(acceleration, delta_t1, MOVE_WITH_ACCELERATION);
	add_to_queue(0, delta_t2, MOVE_WITH_ACCELERATION);
	add_to_queue(-acceleration, delta_t1, MOVE_WITH_ACCELERATION);
}


void compute_velocity(void)
{
	static int32_t previous_hall_position = 0;
	static uint16_t previous_time = 0;
	uint16_t current_time;
	int32_t delta_position;
	uint16_t delta_time;
	static uint16_t count = 0;

	count++;
	if(count >= 20) {
		count = 0;

		current_time = TIM3->CNT;

		delta_position = hall_position - previous_hall_position;
		delta_time = current_time - previous_time;
		delta_position *= VELOCITY_SCALE_FACTOR;
		velocity = delta_position / delta_time;

		previous_hall_position = hall_position;
		previous_time = current_time;
	}
}

uint8_t handle_queued_movements(void)
{
	if(!decelerate_to_stop_active) {
		if(n_items_in_queue > 0) {
			// there is an assumption here that any item in the queue will always have one or more time steps
			// see the add_to_queue function where we make sure to never add an item to the queue with zero time steps
			if(movement_queue[queue_read_position].movement_type == MOVE_WITH_ACCELERATION) {
				current_velocity_i64 += movement_queue[queue_read_position].acceleration; // consume one time step worth of acceleration
				movement_queue[queue_read_position].n_time_steps--;
				if(movement_queue[queue_read_position].n_time_steps == 0) {
					queue_read_position = (queue_read_position + 1) & (MOVEMENT_QUEUE_SIZE - 1);
					n_items_in_queue--;
				}
			}
			else {
				current_velocity_i64 = movement_queue[queue_read_position].velocity; // velocity  is constant during this time step
				movement_queue[queue_read_position].n_time_steps--;
				if(movement_queue[queue_read_position].n_time_steps == 0) {
					queue_read_position = (queue_read_position + 1) & (MOVEMENT_QUEUE_SIZE - 1);
					n_items_in_queue--;
				}
			}
		}
		else {
			decelerate_to_stop_active = 1;
		}
	}
	if(decelerate_to_stop_active) {
		if(current_velocity_i64 >= 0) {
			if(current_velocity_i64 > max_acceleration) {
				current_velocity_i64 -= max_acceleration;
			}
			else {
				current_velocity_i64 = 0;
			}
		}
		else {
			if(-current_velocity_i64 > max_acceleration) {
				current_velocity_i64 += max_acceleration;
			}
			else {
				current_velocity_i64 = 0;
			}
		}
		if(current_velocity_i64 == 0) {
			decelerate_to_stop_active = 0;
		}
	}

	if(current_velocity_i64 > max_velocity) {
		fatal_error("vel too high", 12);
	}
	current_position_i64 += current_velocity_i64;
	desired_position = ((int32_t *)&current_position_i64)[1]; // take the most significant 32 bit number

	return (current_velocity_i64 != 0);

}


#define PID_SHIFT_RIGHT 18
int32_t PID_controller(int32_t error)
{
    int32_t output_value;
    int32_t proportional_term;
    static int32_t integral_term = 0;
    int32_t derivative_term;
    static int32_t previous_error = 0;
    int32_t error_change;
    static int32_t low_pass_filtered_error_change = 0;
#define PROPORTIONAL_CONSTANT_PID 10800 // if exceeding 32767 then need to check whether any math will overflow below in the proportional term
#define INTEGRAL_CONSTANT_PID 0
#define DERIVATIVE_CONSTANT_PID 000000
//#define DERIVATIVE_CONSTANT_PID 250000
//#define DERIVATIVE_CONSTANT_PID 1280000

    if(error < -10000) {
        error = -10000;
    }
    else if(error > 10000) {
        error = 10000;
    }
    integral_term += (error * INTEGRAL_CONSTANT_PID);
    if(integral_term > (CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT)) {
    	integral_term = CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT;
    }
    else if(integral_term < -(CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT)) {
    	integral_term = -(CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT);
    }
    proportional_term = error * PROPORTIONAL_CONSTANT_PID;
    error_change = error - previous_error;
    if(error_change > 5000) {
    	error_change = 5000;
    }
    if(error_change < -5000) {
    	error_change = -5000;
    }

    low_pass_filtered_error_change = (low_pass_filtered_error_change * 15);
    low_pass_filtered_error_change += error_change;
    low_pass_filtered_error_change >>= 4;
    derivative_term = low_pass_filtered_error_change * DERIVATIVE_CONSTANT_PID;
    previous_error = error;
    // maximum value are (approximately):
    // integral term:       66000000
    // proportional term:  250000000
    // derivative term:   1250000000
    // sum:               1510000000
    // Make sure it does not exceed the max int32_t = 2147483647
    // After shifting, the maximum values are:
    // integral term:      250
    // proportional term:  953
    // derivative term:   4768
    // sum:               6971
    output_value = (integral_term + proportional_term + derivative_term) >> PID_SHIFT_RIGHT;

//    if(output_value < -CLOSED_LOOP_PWM_VOLTAGE) {
//        output_value = -CLOSED_LOOP_PWM_VOLTAGE;
//    }
//    else if(output_value > CLOSED_LOOP_PWM_VOLTAGE) {
//        output_value = CLOSED_LOOP_PWM_VOLTAGE;
//    }

    return output_value;
}


void motor_movement_calculations(void)
{
	uint8_t moving = 0; // 1 indicates that the motor is moving, 0 indicates that it is stopped

    if(go_to_closed_loop_mode_active) {
        go_to_closed_loop_mode_logic();
    }
    else if(homing_active) {
        handle_homing_logic();
    }
    else if(calibration_active) {
        handle_calibration_logic();
    }

    moving = handle_queued_movements();

	if(motor_control_mode == OPEN_LOOP_POSITION_CONTROL) {
		commutation_position = desired_position + commutation_position_offset;
		if(moving) {
			motor_pwm_voltage = OPEN_LOOP_DYNAMIC_MOTOR_PWM_VOLTAGE;
		}
		else {
			motor_pwm_voltage = OPEN_LOOP_STATIC_MOTOR_PWM_VOLTAGE;
		}
	}
	else {
		commutation_position = hall_position + commutation_position_offset;
		if(motor_control_mode == CLOSED_LOOP_POSITION_CONTROL) {
			int32_t motor_maximum_allowed_pwm_voltage;

			motor_pwm_voltage = PID_controller(desired_position - hall_position);

			if(motor_pwm_voltage >= 0) {
				motor_maximum_allowed_pwm_voltage = velocity + CLOSED_LOOP_PWM_VOLTAGE;
				if(motor_pwm_voltage > motor_maximum_allowed_pwm_voltage) {
					motor_pwm_voltage = motor_maximum_allowed_pwm_voltage;
				}
				commutation_position += HALL_TO_POSITION_90_DEGREE_OFFSET;
			}
			else {
				motor_maximum_allowed_pwm_voltage = velocity - CLOSED_LOOP_PWM_VOLTAGE;
				if(motor_pwm_voltage < motor_maximum_allowed_pwm_voltage) {
					motor_pwm_voltage = motor_maximum_allowed_pwm_voltage;
				}
				commutation_position -= HALL_TO_POSITION_90_DEGREE_OFFSET;
				motor_pwm_voltage = -motor_pwm_voltage;
			}
		}
		else {
			if(desired_motor_pwm_voltage >= 0) {
				commutation_position += HALL_TO_POSITION_90_DEGREE_OFFSET;
				motor_pwm_voltage = desired_motor_pwm_voltage;
			}
			else {
				commutation_position -= HALL_TO_POSITION_90_DEGREE_OFFSET;
				motor_pwm_voltage = -desired_motor_pwm_voltage;
			}
		}
	}
}


void motor_phase_calculations(void)
{
    static uint16_t commutation_step = 0;
    static uint16_t commutation_sub_step = 0;
    static uint32_t phase1;
    static uint32_t phase2;
    static uint32_t phase3;
    static int32_t phase1_slope;
    static int32_t phase2_slope;
    static int32_t phase3_slope;
    static int32_t tmp32bit;
//    char buf[200];
//    volatile uint32_t delay;

//    sprintf(buf, "commutation_position: %u\n", (unsigned int)commutation_position);
//    transmit(buf, strlen(buf));

    commutation_step = (commutation_position >> N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT) % N_COMMUTATION_STEPS;
    commutation_sub_step = (commutation_position & 0xff) >> (8 - N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT);

//    sprintf(buf, "commutation_step: %u   commutation_sub_step: %u\n", (unsigned int)commutation_step, (unsigned int)commutation_sub_step);
//    transmit(buf, strlen(buf));

//    for(delay = 0; delay < 100000; delay++);

    phase1 = commutation_lookup_table[commutation_step].phase1;
    phase2 = commutation_lookup_table[commutation_step].phase2;
    phase3 = commutation_lookup_table[commutation_step].phase3;
    phase1_slope = commutation_lookup_table[commutation_step].phase1_slope;
    phase2_slope = commutation_lookup_table[commutation_step].phase2_slope;
    phase3_slope = commutation_lookup_table[commutation_step].phase3_slope;

    tmp32bit = phase1_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase1 = phase1 + tmp32bit;

    tmp32bit = phase2_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase2 = phase2 + tmp32bit;

    tmp32bit = phase3_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase3 = phase3 + tmp32bit;

//    sprintf(buf, "Ph: %u %u %u   Motor voltage: %u\n", (unsigned int)phase1, (unsigned int)phase2, (unsigned int)phase3, (unsigned int)motor_pwm_voltage);
//    transmit(buf, strlen(buf));

//    for(delay = 0; delay < 100000; delay++);

    phase1 >>= 8;
    phase1 *= (uint32_t)motor_pwm_voltage;
    phase1 >>= 16;
    phase1 += 13;
    TIM1->CCR1 = phase1;

    phase2 >>= 8;
    phase2 *= (uint32_t)motor_pwm_voltage;
    phase2 >>= 16;
    phase2 += 13;
    TIM1->CCR2 = phase2;

    phase3 >>= 8;
    phase3 *= (uint32_t)motor_pwm_voltage;
    phase3 >>= 16;
    phase3 += 13;
    TIM1->CCR3 = phase3;

//    sprintf(buf, "Ph: %u %u %u   Motor voltage: %u\n", (unsigned int)phase1, (unsigned int)phase2, (unsigned int)phase3, (unsigned int)motor_pwm_voltage);
//    transmit(buf, strlen(buf));
}


void TIM1_BRK_UP_TRG_COM_IRQHandler(void)
{
	uint16_t start_time;
	uint16_t start_time2;
	uint16_t end_time;
	uint16_t end_time2;
	uint16_t motor_control_tick_time;
	static uint16_t previous_motor_control_tick_time;
	uint16_t time_difference_delay;

	start_time = TIM3->CNT;
	start_time2 = start_time;
	hall_position = get_hall_position();
	end_time = TIM3->CNT;
	time_difference1 = end_time - start_time;
	if(time_difference1 > max_time_difference1) {
    	max_time_difference1 = time_difference1;
	}

	start_time = TIM3->CNT;
	compute_velocity();
	end_time = TIM3->CNT;
	time_difference2 = end_time - start_time;
	if(time_difference2 > max_time_difference2) {
    	max_time_difference2 = time_difference2;
	}

	start_time = TIM3->CNT;
	motor_movement_calculations();
	end_time = TIM3->CNT;
	time_difference3 = end_time - start_time;
	if(time_difference3 > max_time_difference3) {
    	max_time_difference3 = time_difference3;
	}

	start_time = TIM3->CNT;
	motor_phase_calculations();
	end_time = TIM3->CNT;
	time_difference4 = end_time - start_time;
	if(time_difference4 > max_time_difference4) {
    	max_time_difference4 = time_difference4;
	}

	motor_control_tick_time = TIM3->CNT;
	motor_control_tick_time_difference = motor_control_tick_time - previous_motor_control_tick_time;
	if(motor_control_tick_time_difference > max_motor_control_tick_time_difference) {
    	max_motor_control_tick_time_difference = motor_control_tick_time_difference;
	}
	previous_motor_control_tick_time = motor_control_tick_time;

	end_time2 = TIM3->CNT;
	motor_control_time_difference = end_time2 - start_time2;
	if(motor_control_time_difference > max_motor_control_time_difference) {
    	max_motor_control_time_difference = motor_control_time_difference;
	}
	if(motor_control_time_difference < 20) { // if the calculation was too fast, introduce an artificial delay here
		start_time = TIM3->CNT;              // let's improve this in the future with a better algorithm, ok?
		do {
			end_time = TIM3->CNT;
			time_difference_delay = end_time - start_time;
		} while(time_difference_delay < 20 - motor_control_time_difference);
	}

	TIM1->SR = 0; // clear the interrupt flag
}


void increase_motor_pwm_voltage(void)
{
	char buf[100];
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	desired_motor_pwm_voltage++;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
	sprintf(buf, "desired_motor_pwm_voltage: %d\n", (int)desired_motor_pwm_voltage);
	transmit(buf, strlen(buf));
}

void decrease_motor_pwm_voltage(void)
{
	char buf[100];
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	desired_motor_pwm_voltage--;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
	sprintf(buf, "desired_motor_pwm_voltage: %d\n", (int)desired_motor_pwm_voltage);
	transmit(buf, strlen(buf));
}

void set_motor_control_mode(uint8_t new_motor_control_mode)
{
	motor_control_mode = new_motor_control_mode;
}

uint8_t get_motor_control_mode(void)
{
	return motor_control_mode;
}

uint32_t get_update_frequency(void)
{
	return PWM_FREQUENCY >> 1;
}

void zero_position_and_hall_sensor(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    clear_the_queue_and_stop_no_disable_interrupt();
	commutation_position_offset = commutation_position_offset - desired_position;
    zero_hall_position();
	desired_position = 0;
	current_position_i64 = 0;
	current_velocity_i64 = 0;
	movement_end_position = 0;
	movement_end_time = 0;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}


void set_max_velocity(uint32_t new_max_velocity)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	max_velocity = new_max_velocity;
	max_velocity <<= VELOCITY_SHIFT_LEFT;
	if(max_velocity > MAX_VELOCITY) {
		max_velocity = MAX_VELOCITY;
	}
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

int32_t get_max_velocity(void)
{
	return max_velocity;
}

void set_max_acceleration(uint32_t new_max_acceleration)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	max_acceleration = new_max_acceleration;
	max_acceleration <<= ACCELERATION_SHIFT_LEFT;
	if(max_acceleration > MAX_ACCELERATION) {
		max_acceleration = MAX_ACCELERATION;
	}
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

int32_t get_max_acceleration(void)
{
	return max_acceleration;
}

int32_t get_desired_position(void)
{
	return desired_position;
}

void reset_time(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    clear_the_queue_and_stop_no_disable_interrupt();
    movement_end_time = 0;
    reset_microsecond_time();
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

void emergency_stop(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    disable_mosfets();
    clear_the_queue_and_stop_no_disable_interrupt();
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}


int32_t get_actual_motor_position(void)
{
	int32_t ret;

    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	if(motor_control_mode == CLOSED_LOOP_POSITION_CONTROL) {
		ret = hall_position;
	}
	else {
		ret = desired_position;
	}
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
    return ret;
}

void get_motor_status(uint8_t *buf)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	buf[0] = motor_control_mode;
	buf[1] = n_items_in_queue;
	buf[2] = homing_active;
	buf[3] = capture.capture_type;
	buf[4] = get_mosfets_enabled();
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

