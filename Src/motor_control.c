#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "stm32g0xx_hal.h"
#include "microsecond_clock.h"
#include "debug_uart.h"
#include "PWM.h"
#include "ADC.h"
#include "hall_sensor_calculations.h"
#include "mosfets.h"
#include "CommutationTable.h"  // generated by a program called process_raw_hall_data.py
#include "error_handling.h"
#include "RS485.h"
#include "motor_control.h"
#include "leds.h"
#include "step_direction_input.h"
#include "LookupTableZ.h"
#include "device_status.h"
#include "global_variables.h"

#define MAX_HOMING_ERROR 50000

#define POWER_MULTIPLIER 1

#define CLOSED_LOOP_PWM_VOLTAGE (80 * POWER_MULTIPLIER)
#define OPEN_LOOP_STATIC_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)
#define OPEN_LOOP_DYNAMIC_MOTOR_PWM_VOLTAGE (125 * POWER_MULTIPLIER)
#define CALIBRATION_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)
#define GO_TO_CLOSED_LOOP_MODE_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)
#define HOMING_MOTOR_PWM_VOLTAGE (100 * POWER_MULTIPLIER)

#define VELOCITY_SCALE_FACTOR 300
#define UINT32_MIDPOINT 2147483648
#define POSITION_OUT_OF_RANGE_FATAL_ERROR_THRESHOLD 2000000000
// This is the number of microsteps to turn the motor through one quarter of one commutation cycle (not one revolution)
#define HALL_TO_POSITION_90_DEGREE_OFFSET ((N_COMMUTATION_STEPS * N_COMMUTATION_SUB_STEPS) >> 2)

#define EXPECTED_MOTOR_CURRENT_BASELINE 1152
#define MOTOR_CURRENT_BASELINE_TOLERANCE 200
#define MIN_MOTOR_CURRENT_BASELINE (EXPECTED_MOTOR_CURRENT_BASELINE - MOTOR_CURRENT_BASELINE_TOLERANCE)
#define MAX_MOTOR_CURRENT_BASELINE (EXPECTED_MOTOR_CURRENT_BASELINE + MOTOR_CURRENT_BASELINE_TOLERANCE)
#define MAX_MOTOR_CURRENT 300 // make sure this number is less than (EXPECTED_MOTOR_CURRENT_BASELINE - MOTOR_CURRENT_BASELINE_TOLERANCE)

const struct three_phase_data_struct commutation_lookup_table[N_COMMUTATION_STEPS] = COMMUTATION_LOOKUP_TABLE_INITIALIZER;

#define ACCELERATION_SHIFT_LEFT 8
#define VELOCITY_SHIFT_LEFT 12
#define MOVEMENT_QUEUE_SIZE 32 // this has to be a power of 2
typedef struct __attribute__((__packed__)) {
	movement_type_t movement_type;
	union {
	    int64_t acceleration; // we use this variable if the movement_type == MOVE_WITH_ACCELERATION
	    int64_t velocity;     // we use this variable if the movement_type == MOVE_WITH_VELOCITY
	};
    uint32_t n_time_steps;
} movement_queue_t;
static movement_queue_t movement_queue[MOVEMENT_QUEUE_SIZE];
static uint8_t queue_write_position = 0;
static uint8_t queue_read_position = 0;
static uint8_t n_items_in_queue = 0;

static int32_t hall_position = 0;
static int32_t previous_hall_position;
static int32_t hall_position_delta;
static int32_t velocity = 0;
static int64_t current_velocity_i64 = 0;
static int64_t current_position_i64 = 0;
static uint32_t commutation_position = 0;
static uint32_t commutation_position_offset = UINT32_MIDPOINT;
static int64_t max_acceleration = MAX_ACCELERATION;
static int64_t max_velocity = MAX_VELOCITY;
static int32_t motor_pwm_voltage = 0;
static int32_t desired_motor_pwm_voltage = 0;
static uint8_t motor_control_mode = OPEN_LOOP_POSITION_CONTROL;

static uint8_t go_to_closed_loop_mode_active = 0;
static int32_t commutation_scan_microsteps;
static uint8_t vibration_four_step;
static int32_t sum_delta;
static int32_t motor_pwm_voltage_limit;
static int32_t vibration_polarity_moving_average;
static int32_t max_motor_pwm_voltage_limit;
static uint32_t commutation_position_offset_at_max;
static uint16_t motor_current_baseline = 1350;
static int32_t position_lower_safety_limit = -2000000000;
static int32_t position_upper_safety_limit = 2000000000;

static uint8_t homing_active = 0;
static int8_t homing_direction = 0; // 1 for positive, -1 for negative
static uint8_t calibration_active = 0;
static uint8_t calibration_print_output;
static uint8_t decelerate_to_stop_active = 0;
static uint8_t motor_busy = 0; // this will be set to 1 while the motor is doing a long action like calibration or homing. other movement commands cannot be executed during this time.

static uint16_t time_difference1 = 0;
static uint16_t time_difference2 = 0;
static uint16_t time_difference3 = 0;
static uint16_t time_difference4 = 0;
static uint16_t time_difference5 = 0;
static uint16_t max_time_difference1 = 0;
static uint16_t max_time_difference2 = 0;
static uint16_t max_time_difference3 = 0;
static uint16_t max_time_difference4 = 0;
static uint16_t max_time_difference5 = 0;
static uint64_t current_time_captured = 0;
static uint16_t motor_control_tick_time_difference = 0;
static uint16_t max_motor_control_tick_time_difference = 0;
static uint16_t motor_control_time_difference = 0;
static uint16_t max_motor_control_time_difference = 0;
static int32_t max_hall_position_delta = -2000000000;
static int32_t min_hall_position_delta = 2000000000;
static int32_t average_hall_position_delta = 0;
static int32_t average_hall_position_delta_count = 0;

static int64_t position_after_last_queue_item = 0;
static int64_t velocity_after_last_queue_item = 0;

// for the following calibration movement calculations, the time unit is one motor calculation cycle. at the time of this
// writing, this is roughly 25 microseconds. it may be noted elsewhere what this is more accurately.

// this is the velocity used during coast phases of the calibration.
// CALIBRATION_MAX_VELOCITY is in units of motor microsteps per time unit.
// for example, 64 means that the motor will take 64 microsteps per time unit.
#define CALIBRATION_MAX_VELOCITY CALIBRATION_CAPTURE_STEP_SIZE

#define CALIBRATION_VELOCITY_SHIFT 7 // this is how many binary decimal places we are keeping for the calibration velocity value

#define CALIBRATION_ACCELERATION 1 // this is the acceleration used during calibration. the units are microsteps divided by
                                   // (1 << CALIBRATION_VELOCITY_SHIFT) per one unit of time squared.

// this is the time to accelerate or decelerate during calibration. careful that this number ends up being an integer.
#define CALIBRATION_ACCELERATION_TIME ((CALIBRATION_MAX_VELOCITY << CALIBRATION_VELOCITY_SHIFT) / CALIBRATION_ACCELERATION)

// this is the distance delta during one acceleration or deceleration move in the unit of microsteps
#define CALIBRATION_ACCELERATION_DISTANCE ((((((uint32_t)CALIBRATION_ACCELERATION_TIME * (uint32_t)(CALIBRATION_ACCELERATION_TIME + 1)) >> 1) * CALIBRATION_ACCELERATION) >> CALIBRATION_VELOCITY_SHIFT))

// this is the time to coast at constant velocity such that the distance covered is CALIBRATION_ACCELERATION_DISTANCE
#define CALIBRATION_SMALL_COAST_TIME ((uint16_t)((uint32_t)CALIBRATION_ACCELERATION_DISTANCE / CALIBRATION_MAX_VELOCITY))

// this is the movement distance to cover exactly one rotation of the hall sensor magnetic disc in the unit of microsteps
#define CALIBRATION_MOVEMENT_DISTANCE ((int32_t)N_COMMUTATION_STEPS * (int32_t)N_COMMUTATION_SUB_STEPS * (int32_t)ONE_REVOLUTION_STEPS)

// this is the time to coast at constant velocity while capturing hall sensor readings. this should be exactly such that after one
// coast phase, the motor will rotate through one hall sensor revolution (ie. moves CALIBRATION_MOVEMENT_DISTANCE).
#define CALIBRATION_COAST_TIME (CALIBRATION_MOVEMENT_DISTANCE / CALIBRATION_MAX_VELOCITY)



#define HOMING_MAX_VELOCITY 32

#define HOMING_VELOCITY_SHIFT 8 // this is how many binary decimal places we are keeping for the homing velocity value

#define HOMING_ACCELERATION 1 // this is the acceleration used during calibration. the units are microsteps divided by
                                   // (1 << HOMING_VELOCITY_SHIFT) per one unit of time squared.

// this is the time to accelerate or decelerate during calibration. careful that this number ends up being an integer.
#define HOMING_ACCELERATION_TIME ((HOMING_MAX_VELOCITY << HOMING_VELOCITY_SHIFT) / HOMING_ACCELERATION)

// this is the distance delta during one acceleration or deceleration move in the unit of microsteps
#define HOMING_ACCELERATION_DISTANCE ((((((uint32_t)HOMING_ACCELERATION_TIME * (uint32_t)(HOMING_ACCELERATION_TIME + 1)) >> 1) * HOMING_ACCELERATION) >> HOMING_VELOCITY_SHIFT))

// this is the time to coast at constant velocity such that the distance covered is HOMING_ACCELERATION_DISTANCE
#define HOMING_SMALL_COAST_TIME ((uint16_t)((uint32_t)HOMING_ACCELERATION_DISTANCE / HOMING_MAX_VELOCITY))

#define HOMING_MAX_REVOLUTIONS 300

// this is the movement distance to cover exactly one rotation of the hall sensor magnetic disc in the unit of microsteps
#define HOMING_MOVEMENT_DISTANCE (N_COMMUTATION_STEPS * N_COMMUTATION_SUB_STEPS * ONE_REVOLUTION_STEPS * HOMING_MAX_REVOLUTIONS)

// this is the time to coast at constant velocity while capturing hall sensor readings. this should be exactly such that after one
// coast phase, the motor will rotate through one hall sensor revolution (ie. moves HOMING_MOVEMENT_DISTANCE).
#define HOMING_COAST_TIME (HOMING_MOVEMENT_DISTANCE / HOMING_MAX_VELOCITY)


/*
 * Example:
 *    CALIBRATION_MAX_VELOCITY 64
 *    CALIBRATION_VELOCITY_SHIFT 8
 *    CALIBRATION_ACCELERATION 1
 *    CALIBRATION_ACCELERATION_TIME 16384
 *    CALIBRATION_ACCELERATION_DISTANCE 524320
 *    CALIBRATION_SMALL_COAST_TIME 8192.5 rounded down to 8192
 *    CALIBRATION_COAST_TIME 10080
 *    CALIBRATION_MOVEMENT_DISTANCE 645120
 */

#define CALIBRATION_DATA_COLLECTION_SHIFT_RIGHT 8
#define CALIBRATION_DATA_COLLECTION_N_TURNS_TIMES_256 (384)
#define CALIBRATION_DATA_SIZE ((TOTAL_NUMBER_OF_SEGMENTS / 3 * CALIBRATION_DATA_COLLECTION_N_TURNS_TIMES_256 >> CALIBRATION_DATA_COLLECTION_SHIFT_RIGHT))
struct calibration_struct {
	uint16_t local_min_or_max;
	int32_t local_min_or_max_position;
};
struct calibration_struct calibration[3][CALIBRATION_DATA_SIZE];

struct __attribute__((__packed__)) fast_capture_data_struct {
	uint16_t hall1;
	uint16_t hall2;
	uint16_t hall3;
	uint16_t hall_position_16bit;
};
struct fast_capture_data_struct *fast_capture_data = (void*)&calibration;
uint16_t fast_capture_data_size = sizeof(calibration) / sizeof(struct fast_capture_data_struct);
uint16_t fast_capture_data_index;
uint8_t fast_capture_data_active = 0;
uint8_t fast_capture_data_result_ready = 0;
static uint32_t calibration_index[3];


struct capture_struct {
    uint8_t capture_type;
    uint8_t avg_counter;
    uint16_t hall1_sum;
    uint16_t hall2_sum;
    uint16_t hall3_sum;
};
struct capture_struct capture = {0};


struct homing_struct {
    uint8_t move_number;
    int8_t direction;
    uint32_t time;
    int16_t velocity;
    int16_t acceleration;
    int32_t start_position;
    int32_t start_six_step_hall_position;
};
struct homing_struct homing = {0};


struct closed_loop_struct {
    uint8_t move_number;
    uint32_t time;
    int16_t velocity;
    int16_t acceleration;
    uint8_t capturing_data;
    uint8_t avg_counter;
    uint32_t hall1_sum;
    uint32_t hall2_sum;
    uint32_t hall3_sum;
    uint16_t max_hall_reading;
    int32_t max_hall_position;
    int32_t max_hall_distance;
};
struct closed_loop_struct closed_loop = {0};


void clear_the_queue_and_stop_no_disable_interrupt(void)
{
    queue_read_position = 0;
    queue_write_position = 0;
    n_items_in_queue = 0;
}


/*
delta_t = 3000000
delta_d = int(microsteps_per_rotation * 1.0 + 0.5)
delta_t1 = int(max_velocity / max_acceleration + 0.5)
if 2 * delta_t1 > delta_t:
    print("Doing the special case of the move where the time is very short but so is the distance")
    delta_t1 = delta_t // 2
delta_t2 = delta_t - 2 * delta_t1
numerator = delta_d
denominator = ((delta_t1 + delta_t2) * delta_t1)
acceleration = int(delta_d / ((delta_t1 + delta_t2) * delta_t1) + 0.5)
*/

void compute_trapezoid_move(int32_t total_displacement, uint32_t total_time, int32_t *acceleration_returned, uint32_t *delta_t1_returned, uint32_t *delta_t2_returned)
{
	int64_t delta_d = (int64_t)total_displacement << 24;
//	uint32_t delta_t1 = ((max_acceleration >> 1) + max_velocity) / max_acceleration; // calculating detal_t1 with rounding
	int64_t delta_t1 = max_velocity / max_acceleration; // calculating detal_t1 without rounding
	if((delta_t1 << 1) > total_time) {
	    delta_t1 = total_time >> 1;
	}
	uint32_t delta_t2 = total_time - (delta_t1 << 1);
	int64_t numerator = delta_d;
	int64_t denominator = ((delta_t1 + delta_t2) * delta_t1);
	int64_t acceleration = numerator / denominator;

	print_int64("max_velocity: ", max_velocity);
	print_int64("max_acceleration: ", max_acceleration);
	print_int64("delta_d: ", (int64_t)delta_d);
	print_int64("delta_t: ", (int64_t)total_time);
	print_int64("delta_t1: ", (int64_t)delta_t1);
	print_int64("delta_t2: ", (int64_t)delta_t2);
	print_int64("numerator: ", (int64_t)numerator);
	print_int64("denominator: ", (int64_t)denominator);
	print_int64("acceleration: ", (int64_t)acceleration);

//	acceleration >>= 8;
	*acceleration_returned = acceleration;
	*delta_t1_returned = (uint32_t)delta_t1;
	*delta_t2_returned = (uint32_t)delta_t2;
}


uint32_t hall1_sum;
uint32_t hall2_sum;
uint32_t hall3_sum;
uint8_t avg_counter;
uint16_t hall_data_buffer[3];

#define CALIBRATION_TIME (get_update_frequency() * 1)
#define CALIBRATION_DISTANCE (N_COMMUTATION_STEPS * N_COMMUTATION_SUB_STEPS * ONE_REVOLUTION_STEPS * 3 / 2)
#define HALL_PEAK_FIND_THREASHOLD 150
uint8_t hall_rising_flag[3];
uint16_t hall_local_maximum[3];
uint16_t hall_local_minimum[3];
int32_t hall_calibration_start_position;
int32_t hall_local_maximum_position[3];
int32_t hall_local_minimum_position[3];
uint8_t calibration_data_available = 0;

void start_calibration(uint8_t print_output)
{
	int32_t acceleration;
	uint32_t delta_t1;
	uint32_t delta_t2;
	uint8_t j;

	if(motor_control_mode != OPEN_LOOP_POSITION_CONTROL) {
		fatal_error(7); // "not in open loop" (all error text is defined in error_text.c)
	}

	if(n_items_in_queue != 0) {
		fatal_error(8); // "queue not empty" (all error text is defined in error_text.c)
	}

	if(print_output) {
	   	rs485_transmit("Calibration start\n", 18);
	}
	calibration_print_output = print_output;

	enable_mosfets();

	compute_trapezoid_move(CALIBRATION_DISTANCE, CALIBRATION_TIME / 2, &acceleration, &delta_t1, &delta_t2);

	add_to_queue(-acceleration, delta_t1, MOVE_WITH_ACCELERATION);
	add_to_queue(0, delta_t2, MOVE_WITH_ACCELERATION);
	add_to_queue(acceleration, delta_t1 * 2, MOVE_WITH_ACCELERATION);
	add_to_queue(0, delta_t2, MOVE_WITH_ACCELERATION);
	add_to_queue(-acceleration, delta_t1, MOVE_WITH_ACCELERATION);

	motor_busy = 1;

/*
	max_velocity = MAX_VELOCITY;
	max_acceleration = MAX_ACCELERATION;

	add_trapezoid_move_to_queue(CALIBRATION_DISTANCE, CALIBRATION_TIME / 2);
	add_trapezoid_move_to_queue(-CALIBRATION_DISTANCE, CALIBRATION_TIME / 2);
*/
	hall_calibration_start_position = ((int32_t *)&current_position_i64)[1];
	for(j = 0; j < 3; j++) {
		hall_rising_flag[j] = 1;
		hall_local_maximum[j] = 0;
		hall_local_minimum[j] = 65535;
		hall_local_maximum_position[j] = 0;
		hall_local_minimum_position[j] = 0;
		calibration_index[j] = 0;
	}

	hall1_sum = 0;
	hall2_sum = 0;
	hall3_sum = 0;
	avg_counter = 0;

	calibration_data_available = 0;
	calibration_active = 1;
}


void handle_calibration_logic(void)
{
	uint16_t hall_reading;
	int32_t calibration_relative_position = ((int32_t *)&current_position_i64)[1] - hall_calibration_start_position;
	uint8_t j;

	if(n_items_in_queue == 2) {
		if(calibration_print_output) {
			hall1_sum += get_hall_sensor1_voltage();
			hall2_sum += get_hall_sensor2_voltage();
			hall3_sum += get_hall_sensor3_voltage();
//			hall1_sum = get_hall_sensor1_voltage();
//			hall2_sum = get_hall_sensor2_voltage();
//			hall3_sum = get_hall_sensor3_voltage();
			avg_counter++;
			if(avg_counter == 16) {
				hall_data_buffer[0] = (hall1_sum >> 1) - HALL_SENSOR_SHIFT;
				hall_data_buffer[1] = (hall2_sum >> 1) - HALL_SENSOR_SHIFT;
				hall_data_buffer[2] = (hall3_sum >> 1) - HALL_SENSOR_SHIFT;
//				hall_data_buffer[0] = (hall1_sum << 3) - HALL_SENSOR_SHIFT;
//				hall_data_buffer[1] = (hall2_sum << 3) - HALL_SENSOR_SHIFT;
//				hall_data_buffer[2] = (hall3_sum << 3) - HALL_SENSOR_SHIFT;
				rs485_transmit((void*)hall_data_buffer, 6);
				avg_counter = 0;
				hall1_sum = 0;
				hall2_sum = 0;
				hall3_sum = 0;
			}
		}
		else {
			for(j = 0; j < 3; j++) {
				if(calibration_index[j] < CALIBRATION_DATA_SIZE) {
					switch(j) {
					case 0:
						hall_reading = get_hall_sensor1_voltage();
						break;
					case 1:
						hall_reading = get_hall_sensor2_voltage();
						break;
					case 2:
						hall_reading = get_hall_sensor3_voltage();
						break;
					}
		//			if((hall_reading > 10000) || (hall_reading < 7000)) {
		//				fatal_error(9); // "hall sensor error" (all error text is defined in error_text.c)
		//			}
					if(hall_rising_flag[j]) {
						if(hall_reading > hall_local_maximum[j]) {
							hall_local_maximum[j] = hall_reading;
							hall_local_maximum_position[j] = calibration_relative_position;
						}
						if(hall_local_maximum[j] - hall_reading > HALL_PEAK_FIND_THREASHOLD) {
							calibration[j][calibration_index[j]].local_min_or_max = hall_local_maximum[j];
							calibration[j][calibration_index[j]].local_min_or_max_position = hall_local_maximum_position[j];
							calibration_index[j]++;
							hall_local_minimum[j] = hall_reading;
							hall_local_minimum_position[j] = calibration_relative_position;
							hall_rising_flag[j] = 0;
						}
					}
					else {
						if(hall_reading < hall_local_minimum[j]) {
							hall_local_minimum[j] = hall_reading;
							hall_local_minimum_position[j] = calibration_relative_position;
						}
						if(hall_reading - hall_local_minimum[j] > HALL_PEAK_FIND_THREASHOLD) {
							calibration[j][calibration_index[j]].local_min_or_max = hall_local_minimum[j];
							calibration[j][calibration_index[j]].local_min_or_max_position = hall_local_minimum_position[j];
							calibration_index[j]++;
							hall_local_maximum[j] = hall_reading;
							hall_local_maximum_position[j] = calibration_relative_position;
							hall_rising_flag[j] = 1;
						}
					}
				}
				else {
					fatal_error(10); // "calibration overflow" (all error text is defined in error_text.c)
				}
			}
		}
	}
	else if(n_items_in_queue == 0) {
		calibration_active = 0;
		disable_mosfets();
		if(calibration_print_output) {
	       	rs485_transmit("Calibration capture done\n", 25);
	   		motor_busy = 0;
		}
		else {
			calibration_data_available = 1;
		}
	}
}

uint8_t is_calibration_data_available(void)
{
	return calibration_data_available;
}

void process_calibration_data(void)
{
	uint16_t i;
	int32_t position_delta;
	uint16_t peak_to_peak;
	int32_t min_position_delta;
	int32_t max_position_delta;
	uint16_t min_peak_to_peak;
	uint16_t max_peak_to_peak;
	uint8_t min_or_max;
	char buf[150];
	uint8_t j;

	for(j = 0; j < 3; j++) {
		for(i = 0; i < calibration_index[j]; i++) {
			sprintf(buf, "index: %u  local_min_or_max: %u  position: %ld\n",
					i, calibration[j][i].local_min_or_max, calibration[j][i].local_min_or_max_position);
			transmit(buf, strlen(buf));
		}

		min_or_max = 0;
		min_position_delta = 2147483640;
		max_position_delta = -2147483640;
		min_peak_to_peak = 65535;
		max_peak_to_peak = 0;
		for(i = 1; i < calibration_index[j]; i++) {
			position_delta = calibration[j][i].local_min_or_max_position - calibration[j][i - 1].local_min_or_max_position;
			if(position_delta > max_position_delta) {
				max_position_delta = position_delta;
			}
			if(position_delta < min_position_delta) {
				min_position_delta = position_delta;
			}

			if(min_or_max == 0) {
				peak_to_peak = calibration[j][i - 1].local_min_or_max - calibration[j][i].local_min_or_max;
				min_or_max = 1;
			}
			else {
				peak_to_peak = calibration[j][i].local_min_or_max - calibration[j][i - 1].local_min_or_max;
				min_or_max = 0;
			}
			if(peak_to_peak > max_peak_to_peak) {
				max_peak_to_peak = peak_to_peak;
			}
			if(peak_to_peak < min_peak_to_peak) {
				min_peak_to_peak = peak_to_peak;
			}

			sprintf(buf, "i: %u  max to min delta: %u  position delta: %ld\n", i, peak_to_peak, position_delta);
			transmit(buf, strlen(buf));
		}

		sprintf(buf, "min_position_delta: %ld  max_position_delta: %ld\n", min_position_delta, max_position_delta);
		transmit(buf, strlen(buf));
		sprintf(buf, "min_peak_to_peak: %u  max_peak_to_peak: %u\n", min_peak_to_peak, max_peak_to_peak);
		transmit(buf, strlen(buf));
	}

	#define N_POLES (TOTAL_NUMBER_OF_SEGMENTS / 3)
	#define MIN_CALIBRATION_LOCAL_MINIMA_OR_MAXIMA 70  // make sure this is larger than N_POLES
	uint32_t minima_and_maxima_avg[3] = {0, 0, 0};
	uint16_t midline[3];
	for(j = 0; j < 3; j++) {
		if(calibration_index[j] < MIN_CALIBRATION_LOCAL_MINIMA_OR_MAXIMA) {
			fatal_error(11); // "not enough minima or maxima" (all error text is defined in error_text.c)
		}

		uint16_t start_calibration_index = (calibration_index[j] - N_POLES);
		for(i = start_calibration_index; i < calibration_index[j]; i++) {
			minima_and_maxima_avg[j] += (uint32_t)calibration[j][i].local_min_or_max;
			sprintf(buf, "Averaging: index: %u  local_min_or_max: %u\n", i, calibration[j][i].local_min_or_max);
			transmit(buf, strlen(buf));
		}
		minima_and_maxima_avg[j] /= N_POLES;
		midline[j] = (uint16_t)(((int32_t)minima_and_maxima_avg[j] << 3) - HALL_SENSOR_SHIFT);
	}

	global_settings.hall1_midline = midline[0];
	global_settings.hall2_midline = midline[1];
	global_settings.hall3_midline = midline[2];

	for(j = 0; j < 3; j++) {
		sprintf(buf, "The average and midline for hall sensor %hu are: %lu  %u\n", j + 1, minima_and_maxima_avg[j], midline[j]);
		transmit(buf, strlen(buf));
	}

	calibration_data_available = 0;
	motor_busy = 0;
}

#define MOTOR_PWM_VOLTAGE_LIMIT_MINIMUM 10
#define MOTOR_PWM_VOLTAGE_LIMIT_MAXIMUM 120
#define COMMUTATION_SCAN_MICROSTEPS (256 * 360) // one electrical rotation
#define COMMUTATION_SCAN_STEP_FACTOR 1
#define COMMUTATION_SCAN_MIN_STEP_SIZE 100
//#define COMMUTATION_SCAN_STEP_SIZE (256 * 360 / COMMUTATION_SCAN_STEPS)
#define GO_TO_CLOSED_LOOP_VIBRATION_MAGNITUDE 100
#define MOVING_AVERAGE_SHIFT_RIGHT 7
void start_go_to_closed_loop_mode(void)
{
	motor_busy = 1;

	transmit("Go to closed loop mode start\n", 29);

	TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation

	clear_the_queue_and_stop_no_disable_interrupt();
	set_motor_control_mode(OPEN_LOOP_PWM_VOLTAGE_CONTROL);
	enable_mosfets();
	commutation_position_offset = UINT32_MIDPOINT;
	vibration_four_step = 0;
	commutation_scan_microsteps = 0;
	desired_motor_pwm_voltage = 0;
	go_to_closed_loop_mode_active = 1;
	motor_pwm_voltage_limit = MOTOR_PWM_VOLTAGE_LIMIT_MINIMUM;
	sum_delta = 0;
	vibration_polarity_moving_average = 0;
	max_motor_pwm_voltage_limit = 0;
	zero_hall_position();
	previous_hall_position = 0;

    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

void go_to_closed_loop_mode_logic(void)
{
//	char buf[30];
	if(commutation_scan_microsteps < COMMUTATION_SCAN_MICROSTEPS) {
		switch(vibration_four_step) {
		case 0:
			sum_delta += hall_position_delta;
			desired_motor_pwm_voltage++;
			if(desired_motor_pwm_voltage >= motor_pwm_voltage_limit) {
				vibration_four_step++;
			}
			break;
		case 1:
		case 2:
			sum_delta -= hall_position_delta;
			desired_motor_pwm_voltage--;
			if(desired_motor_pwm_voltage <= -motor_pwm_voltage_limit) {
				vibration_four_step++;
			}
			break;
		case 3:
			sum_delta += hall_position_delta;
			desired_motor_pwm_voltage++;
			if(desired_motor_pwm_voltage >= motor_pwm_voltage_limit) {
				vibration_four_step = 0;
				int32_t step_size = (MOTOR_PWM_VOLTAGE_LIMIT_MAXIMUM - motor_pwm_voltage_limit + 1) * COMMUTATION_SCAN_STEP_FACTOR;
				if(step_size < COMMUTATION_SCAN_MIN_STEP_SIZE) {
					step_size = COMMUTATION_SCAN_MIN_STEP_SIZE;
				}
				commutation_scan_microsteps += step_size;
				if(sum_delta > 0) {
					if(vibration_polarity_moving_average >= 0) {
						vibration_polarity_moving_average++;
					}
					else {
						vibration_polarity_moving_average += 2;
					}
				}
				else if(sum_delta < 0) {
					if(vibration_polarity_moving_average <= 0) {
						vibration_polarity_moving_average--;
					}
					else {
						vibration_polarity_moving_average -= 2;
					}
				}
//				vibration_polarity_moving_average = (vibration_polarity_moving_average * ((1 << MOVING_AVERAGE_SHIFT_RIGHT) - 1) + sum_delta) >> MOVING_AVERAGE_SHIFT_RIGHT;
				if(sum_delta >= 0) {
//					print_number("", (uint16_t)sum_delta);
				}
				else {
					sum_delta = -sum_delta;
//					print_number("-", (uint16_t)sum_delta);
				}
				if(sum_delta > GO_TO_CLOSED_LOOP_VIBRATION_MAGNITUDE) {
					if(motor_pwm_voltage_limit > MOTOR_PWM_VOLTAGE_LIMIT_MINIMUM) {
						motor_pwm_voltage_limit--;
					}
				}
				else {
					if(motor_pwm_voltage_limit < MOTOR_PWM_VOLTAGE_LIMIT_MAXIMUM) {
						motor_pwm_voltage_limit++;
					}
				}
				if(motor_pwm_voltage_limit > max_motor_pwm_voltage_limit) {
					max_motor_pwm_voltage_limit = motor_pwm_voltage_limit;
					commutation_position_offset_at_max = commutation_position_offset;
					if(vibration_polarity_moving_average < 0) {
						commutation_position_offset_at_max -= HALL_TO_POSITION_90_DEGREE_OFFSET;
					}
					else {
						commutation_position_offset_at_max += HALL_TO_POSITION_90_DEGREE_OFFSET;
					}
				}
				commutation_position_offset += step_size;
//				sprintf(buf, "%hu %ld\n", (uint16_t)motor_pwm_voltage_limit, vibration_polarity_moving_average);
//				transmit(buf, strlen(buf));
				sum_delta = 0;
			}
			break;
		default:
			fatal_error(12); // "vibration four step" (all error text is defined in error_text.c)
		}
	}
	else {
		commutation_position_offset = commutation_position_offset_at_max;
		current_position_i64 = 0;
		current_velocity_i64 = 0;
		motor_pwm_voltage = 0;
		set_motor_control_mode(CLOSED_LOOP_POSITION_CONTROL);
		hall_position = get_hall_position();
		go_to_closed_loop_mode_active = 0;
		motor_busy = 0;
    }
}


void start_capture(uint8_t capture_type)
{
    transmit("Capture start\n", 14);

	TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation

    memset(&capture, 0, sizeof(capture));
    capture.capture_type = capture_type;

    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

void capture_logic(void)
{
    uint16_t hall_data_buffer[6];
    int32_t adjusted_hall_sensor_readings[3];
    static uint16_t counter = 0;

    if(capture.capture_type == CAPTURE_HALL_SENSOR_READINGS) {
    	if(counter == 0) {
    		counter = 256;

    		hall_data_buffer[0] = (get_hall_sensor1_voltage() << 3) - HALL_SENSOR_SHIFT;
    		hall_data_buffer[1] = (get_hall_sensor2_voltage() << 3) - HALL_SENSOR_SHIFT;
    		hall_data_buffer[2] = (get_hall_sensor3_voltage() << 3) - HALL_SENSOR_SHIFT;
			hall_data_buffer[3] = 65535;
			rs485_transmit((char*)hall_data_buffer, 8);
    	}
    	counter--;
    }
    else if(capture.capture_type == CAPTURE_HALL_POSITION) {
    	if(counter == 0) {
    		counter = 256;
    		int32_t hall_position = get_hall_position();
    		memcpy(hall_data_buffer + 3, &hall_position, sizeof(hall_position));
			rs485_transmit((char*)hall_data_buffer, 12);
    	}
    	counter--;
    }
    else if(capture.capture_type == CAPTURE_ADJUSTED_HALL_SENSOR_READINGS) {
    	if(counter == 0) {
    		counter = 256;
    		int32_t hall_position = get_hall_position();
			adjust_hall_sensor_readings(hall_data_buffer, adjusted_hall_sensor_readings);
			hall_data_buffer[0] = (adjusted_hall_sensor_readings[0] >> 16) + 32768;
			hall_data_buffer[1] = (adjusted_hall_sensor_readings[1] >> 16) + 32768;
			hall_data_buffer[2] = (adjusted_hall_sensor_readings[2] >> 16) + 32768;
    		memcpy(hall_data_buffer + 3, &hall_position, sizeof(hall_position));
			hall_data_buffer[5] = 65535; // magic number to indicate the end of the data
			rs485_transmit((char*)hall_data_buffer, 12);
    	}
    	counter--;
    }
}

void start_homing(int32_t max_homing_displacement, uint32_t max_homing_time)
{
	if(motor_control_mode != CLOSED_LOOP_POSITION_CONTROL) {
		fatal_error(13); // "not in closed loop" (all error text is defined in error_text.c)
	}

	if(n_items_in_queue != 0) {
		fatal_error(8); // "queue not empty" (all error text is defined in error_text.c)
	}

	add_trapezoid_move_to_queue(max_homing_displacement, max_homing_time);

	motor_busy = 1;

	homing_active = 1;
}

#define HOMING_MAX_POSITION_ERROR 50000
void handle_homing_logic(void)
{
	int32_t position_error;
	position_error = abs(((int32_t *)&current_position_i64)[1] - hall_position);

	if(position_error > HOMING_MAX_POSITION_ERROR) {
		homing_active = 0;
		clear_the_queue_and_stop_no_disable_interrupt();
		current_velocity_i64 = 0; // detected a colision so stop where we are
		if(((int32_t *)&current_position_i64)[1] >= hall_position) {
			((int32_t *)&current_position_i64)[1] -= HOMING_MAX_POSITION_ERROR;
		}
		else {
			((int32_t *)&current_position_i64)[1] += HOMING_MAX_POSITION_ERROR;
		}
	}

	if(n_items_in_queue == 0) {
		homing_active = 0;
//		if(homing_direction == -1) {
//			position_lower_safety_limit = ((int32_t *)&current_position_i64)[1];
//		}
//		else {
//			position_upper_safety_limit = ((int32_t *)&current_position_i64)[1];
//		}
		motor_busy = 0;
	}
}


void start_fast_capture_data(void)
{
	transmit("Fast capture data\n", 18);
	fast_capture_data_index = 0;
	fast_capture_data_active = 1;
}


void fast_capture_until_trigger(void)
{
	memset(fast_capture_data, 0, fast_capture_data_size * sizeof(struct fast_capture_data_struct));
	fast_capture_data_index = 0;
	fast_capture_data_active = 2;
}


void print_position(void)
{
	char buf[100];
	sprintf(buf, "current_position: %ld\n", ((int32_t *)&current_position_i64)[1]);
	transmit(buf, strlen(buf));
}

void print_queue_stats(void)
{
	char buf[100];
	sprintf(buf, "n_items_in_queue: %u\n", (unsigned int)n_items_in_queue);
	transmit(buf, strlen(buf));
}

void print_current_movement(void)
{
	char buf[150];
	uint64_t current_time = get_microsecond_time();
	print_int64("max acceleration:", (int64_t)max_acceleration);
	print_int64("max velocity:", (int64_t)max_velocity);
	sprintf(buf, "current_time: %lu\n", (unsigned long int)current_time);
	transmit(buf, strlen(buf));
	sprintf(buf, "motor_control_mode: %u\n", (unsigned int)motor_control_mode);
	transmit(buf, strlen(buf));
}


void print_velocity(void)
{
	char buf[150];
//	sprintf(buf, "desired velocity: %ld   actual velocity: %ld\n", desired_velocity, velocity);
	sprintf(buf, "velocity: %ld\n", velocity);
	transmit(buf, strlen(buf));
}


void print_time_difference(void)
{
	char buf[150];
	sprintf(buf, "time_difference1: %hu   max_time_difference1: %hu\n", time_difference1, max_time_difference1);
	transmit(buf, strlen(buf));
	max_time_difference1 = 0;

	sprintf(buf, "time_difference2: %hu   max_time_difference2: %hu\n", time_difference2, max_time_difference2);
	transmit(buf, strlen(buf));
	max_time_difference2 = 0;

	sprintf(buf, "time_difference3: %hu   max_time_difference3: %hu\n", time_difference3, max_time_difference3);
	transmit(buf, strlen(buf));
	max_time_difference3 = 0;

	sprintf(buf, "time_difference4: %hu   max_time_difference4: %hu\n", time_difference4, max_time_difference4);
	transmit(buf, strlen(buf));
	max_time_difference4 = 0;

	sprintf(buf, "time_difference5: %hu   max_time_difference5: %hu\n", time_difference5, max_time_difference5);
	transmit(buf, strlen(buf));
	max_time_difference5 = 0;

	sprintf(buf, "current_time_captured: %u\n", (unsigned int)current_time_captured);
	transmit(buf, strlen(buf));

	sprintf(buf, "motor_control_time_difference: %hu   max_motor_control_time_difference: %hu\n", motor_control_time_difference, max_motor_control_time_difference);
	transmit(buf, strlen(buf));
	max_motor_control_time_difference = 0;

	sprintf(buf, "motor_control_tick_time_difference: %hu   max_motor_control_tick_time_difference: %hu\n", motor_control_tick_time_difference, max_motor_control_tick_time_difference);
	transmit(buf, strlen(buf));
	max_motor_control_tick_time_difference = 0;

//	uint32_t pr = NVIC_GetPriority(TIM1_BRK_UP_TRG_COM_IRQn); // enable the interrupt to this timer
//	sprintf(buf, "interrupt priority: %u\n", (unsigned int)pr);
//	transmit(buf, strlen(buf));

	current_time_captured = 1;
}


void print_hall_position_delta_stats(void)
{
	char buf[150];
	int32_t ahpd = average_hall_position_delta;
	int32_t ahpd_count = average_hall_position_delta_count;
	ahpd /= ahpd_count;
	sprintf(buf, "max_hall_position_delta: %ld   min_hall_position_delta: %ld  avg_hall_position_delta: %ld\n", max_hall_position_delta, min_hall_position_delta, ahpd);
	transmit(buf, strlen(buf));
	max_hall_position_delta = -2000000000;
	min_hall_position_delta = 2000000000;
	average_hall_position_delta = 0;
	average_hall_position_delta_count = 0;
}

void print_max_motor_current_settings(void)
{
	char buf[150];
	sprintf(buf, "Maximum motor current: %hu   Maximum motor regeneration current: %hu\n", global_settings.max_motor_current, global_settings.max_motor_regen_current);
	transmit(buf, strlen(buf));
}

void print_motor_current(void)
{
	char buf[150];
	int16_t current = get_motor_current();
	sprintf(buf, "current: %hd   motor_current_baseline: %hu\n", current, motor_current_baseline);
	transmit(buf, strlen(buf));
}


void print_hall_sensor_data(void)
{
	char buf[100];
	uint16_t hall1 = get_hall_sensor1_voltage();
	uint16_t hall2 = get_hall_sensor2_voltage();
	uint16_t hall3 = get_hall_sensor3_voltage();

	sprintf(buf, "hall1: %hu   hall2: %hu   hall3: %hu\n", hall1, hall2, hall3);
	transmit(buf, strlen(buf));

	sprintf(buf, "hall_position: %ld   commutation_position_offset: %lu\n", hall_position, commutation_position_offset);
	transmit(buf, strlen(buf));
}


void print_motor_status(void)
{
	char buf[100];

	uint8_t motor_status_flags = get_motor_status_flags();
	sprintf(buf, "status: %hu\n", motor_status_flags);
	transmit(buf, strlen(buf));
}


uint8_t is_fast_capture_data_result_ready(void)
{
	return fast_capture_data_result_ready;
}


void print_fast_capture_data_result(void)
{
	uint16_t i;
	char buf[100];

	for(i = 0; i < fast_capture_data_size; i++) {
		sprintf(buf, "%hu %hu %hu %hu\n", fast_capture_data[fast_capture_data_index].hall1, fast_capture_data[fast_capture_data_index].hall2,
		                                  fast_capture_data[fast_capture_data_index].hall3, fast_capture_data[fast_capture_data_index].hall_position_16bit);
		transmit(buf, strlen(buf));
		fast_capture_data_index++;
		if(fast_capture_data_index >= fast_capture_data_size) {
			fast_capture_data_index = 0;
		}
	}

	fast_capture_data_result_ready = 0;
}

#define TURN_POINT_CALCULATION_SHIFT 4

void add_to_queue(int32_t parameter, uint32_t n_time_steps, movement_type_t movement_type)
{	
	int64_t predicted_final_velocity;
	int64_t predicted_final_position;
	char buf[150];

	if(motor_busy) {
		fatal_error(19); // "motor busy" (all error text is defined in error_text.c)
	}

	if(n_time_steps == 0) {
		return; // in the case that the number if time steps is zero, it makes sense to not add anything to the queue
	}
    if(n_items_in_queue < MOVEMENT_QUEUE_SIZE) {
		movement_queue[queue_write_position].movement_type = movement_type;
		if(movement_type == MOVE_WITH_ACCELERATION) {
	        movement_queue[queue_write_position].acceleration = parameter;
    	    movement_queue[queue_write_position].acceleration <<= ACCELERATION_SHIFT_LEFT;
            if(abs(movement_queue[queue_write_position].acceleration) > max_acceleration) {
	            fatal_error(15); // "accel too high" (all error text is defined in error_text.c)
            }
			predicted_final_velocity = velocity_after_last_queue_item + movement_queue[queue_write_position].acceleration * n_time_steps;
//			sprintf(buf, "Predicted final velocity: %ld\n", (int32_t)(predicted_final_velocity >> 32));
//			transmit(buf, strlen(buf));
			if(abs(predicted_final_velocity) > max_velocity) {
				fatal_error(28); // "predicted velocity too high" (all error text is defined in error_text.c)
			}
			predicted_final_position = position_after_last_queue_item + velocity_after_last_queue_item * n_time_steps + movement_queue[queue_write_position].acceleration * (((uint64_t)n_time_steps * (n_time_steps + 1)) >> 1);
//			sprintf(buf, "Predicted final position: %ld\n", (int32_t)(predicted_final_position >> 32));
//			transmit(buf, strlen(buf));
			if((((int32_t*)&predicted_final_position)[1] < position_lower_safety_limit) || (((int32_t*)&predicted_final_position)[1] > position_upper_safety_limit)) {
				fatal_error(27); // "predicted position out of safety zone" (all error text is defined in error_text.c)
			}
			if(movement_queue[queue_write_position].acceleration == 0) {
//				transmit("No turn point (acceleration == 0)\n", 34);
			}
			else {
				int64_t time_step_at_turn_point_shifted = -(int64_t)((velocity_after_last_queue_item << TURN_POINT_CALCULATION_SHIFT) / movement_queue[queue_write_position].acceleration);
//				sprintf(buf, "time_at_turn_point: %lu\n", (uint32_t)(time_step_at_turn_point_shifted >> TURN_POINT_CALCULATION_SHIFT));
//				transmit(buf, strlen(buf));
				if((time_step_at_turn_point_shifted > 0) && ((time_step_at_turn_point_shifted >> TURN_POINT_CALCULATION_SHIFT) < n_time_steps)) {
					int64_t relative_position_at_turn_point = (int64_t)(velocity_after_last_queue_item * (int64_t)((int64_t)time_step_at_turn_point_shifted - (int64_t)(1 << TURN_POINT_CALCULATION_SHIFT))) >> (TURN_POINT_CALCULATION_SHIFT + 1);
//					sprintf(buf, "relative_position_at_turn_point: %ld\n", (int32_t)(relative_position_at_turn_point >> 32));
//					transmit(buf, strlen(buf));
					int64_t absolute_position_at_turn_point = position_after_last_queue_item + relative_position_at_turn_point;
					if((((int32_t*)&absolute_position_at_turn_point)[1] < position_lower_safety_limit) || (((int32_t*)&absolute_position_at_turn_point)[1] > position_upper_safety_limit)) {
						fatal_error(26); // "turn point out of safety zone" (all error text is defined in error_text.c)
					}
				}
				else {
//					transmit("No turn point\n", 14);
				}
			}
		}
		else {
	        movement_queue[queue_write_position].velocity = parameter;
    	    movement_queue[queue_write_position].velocity <<= VELOCITY_SHIFT_LEFT;
			predicted_final_velocity = movement_queue[queue_write_position].velocity;
//			sprintf(buf, "Predicted final velocity: %ld\n", ((int32_t*)&predicted_final_velocity)[1]);
//			transmit(buf, strlen(buf));
            if(abs(movement_queue[queue_write_position].velocity) > max_velocity) {
	            fatal_error(16); // "vel too high" (all error text is defined in error_text.c)
            }
			predicted_final_position = position_after_last_queue_item + movement_queue[queue_write_position].velocity * n_time_steps;
//			sprintf(buf, "Predicted final position: %ld\n", (int32_t)(predicted_final_position >> 32));
//			transmit(buf, strlen(buf));
		}
		position_after_last_queue_item = predicted_final_position;
		velocity_after_last_queue_item = predicted_final_velocity;
        movement_queue[queue_write_position].n_time_steps = n_time_steps;
        queue_write_position = (queue_write_position + 1) & (MOVEMENT_QUEUE_SIZE - 1);
        n_items_in_queue++;
    }
	else {
		fatal_error(17); // "queue is full" (all error text is defined in error_text.c)
	}
}


void add_to_queue_test(int32_t parameter, uint32_t n_time_steps, movement_type_t movement_type, add_to_queue_test_results_t *results)
{	
	int64_t movement_queue_queue_write_position_acceleration;
	int64_t movement_queue_queue_write_position_velocity;
	int64_t predicted_final_velocity;
	int64_t predicted_final_position;
	int64_t time_step_at_turn_point_shifted = 0;
	int64_t relative_position_at_turn_point = 0;
	char buf[150];

	memset(results, 0, sizeof(add_to_queue_test_results_t));

	if(n_time_steps == 0) {
		return; // in the case that the number if time steps is zero, it makes sense to not add anything to the queue
	}
	if(movement_type == MOVE_WITH_ACCELERATION) {
		movement_queue_queue_write_position_acceleration = parameter;
		movement_queue_queue_write_position_acceleration <<= ACCELERATION_SHIFT_LEFT;
		if(abs(movement_queue_queue_write_position_acceleration) > max_acceleration) {
			fatal_error(15); // "accel too high" (all error text is defined in error_text.c)
		}
		predicted_final_velocity = velocity_after_last_queue_item + movement_queue_queue_write_position_acceleration * n_time_steps;
		sprintf(buf, "Predicted final velocity: %ld\n", (int32_t)(predicted_final_velocity >> 32));
		transmit(buf, strlen(buf));
		if(abs(predicted_final_velocity) > max_velocity) {
			fatal_error(28); // "predicted velocity too high" (all error text is defined in error_text.c)
		}
		predicted_final_position = position_after_last_queue_item + velocity_after_last_queue_item * n_time_steps + movement_queue_queue_write_position_acceleration * (((uint64_t)n_time_steps * (n_time_steps + 1)) >> 1);
		sprintf(buf, "Predicted final position: %ld\n", (int32_t)(predicted_final_position >> 32));
		transmit(buf, strlen(buf));
		if((((int32_t*)&predicted_final_position)[1] < position_lower_safety_limit) || (((int32_t*)&predicted_final_position)[1] > position_upper_safety_limit)) {
			fatal_error(27); // "predicted position out of safety zone" (all error text is defined in error_text.c)
		}
		if(movement_queue_queue_write_position_acceleration == 0) {
			transmit("No turn point (acceleration == 0)\n", 34);
		}
		else {
			time_step_at_turn_point_shifted = -(int64_t)((velocity_after_last_queue_item << TURN_POINT_CALCULATION_SHIFT) / movement_queue_queue_write_position_acceleration);
			sprintf(buf, "time_at_turn_point: %lu\n", (uint32_t)(time_step_at_turn_point_shifted >> TURN_POINT_CALCULATION_SHIFT));
			transmit(buf, strlen(buf));
			if((time_step_at_turn_point_shifted > 0) && ((time_step_at_turn_point_shifted >> TURN_POINT_CALCULATION_SHIFT) < n_time_steps)) {
				relative_position_at_turn_point = (int64_t)(velocity_after_last_queue_item * (int64_t)((int64_t)time_step_at_turn_point_shifted - (int64_t)(1 << TURN_POINT_CALCULATION_SHIFT))) >> (TURN_POINT_CALCULATION_SHIFT + 1);
				sprintf(buf, "relative_position_at_turn_point: %ld\n", (int32_t)(relative_position_at_turn_point >> 32));
				transmit(buf, strlen(buf));
				int64_t absolute_position_at_turn_point = position_after_last_queue_item + relative_position_at_turn_point;
				if((((int32_t*)&absolute_position_at_turn_point)[1] < position_lower_safety_limit) || (((int32_t*)&absolute_position_at_turn_point)[1] > position_upper_safety_limit)) {
					fatal_error(26); // "turn point out of safety zone" (all error text is defined in error_text.c)
				}
			}
			else {
				transmit("No turn point\n", 14);
			}
		}
	}
	else {
		movement_queue_queue_write_position_velocity = parameter;
		movement_queue_queue_write_position_velocity <<= VELOCITY_SHIFT_LEFT;
		predicted_final_velocity = movement_queue_queue_write_position_velocity;
		sprintf(buf, "Predicted final velocity: %ld\n", ((int32_t*)&predicted_final_velocity)[1]);
		transmit(buf, strlen(buf));
		if(abs(movement_queue_queue_write_position_velocity) > max_velocity) {
			fatal_error(16); // "vel too high" (all error text is defined in error_text.c)
		}
		predicted_final_position = position_after_last_queue_item + movement_queue_queue_write_position_velocity * n_time_steps;
		sprintf(buf, "Predicted final position: %ld\n", (int32_t)(predicted_final_position >> 32));
		transmit(buf, strlen(buf));
	}
	position_after_last_queue_item = predicted_final_position;
	velocity_after_last_queue_item = predicted_final_velocity;

	results->predicted_final_velocity = ((int32_t*)&predicted_final_velocity)[1];
	results->predicted_final_position = ((int32_t*)&predicted_final_position)[1];
	results->time_step_at_turn_point = (time_step_at_turn_point_shifted >> TURN_POINT_CALCULATION_SHIFT);
	results->relative_position_at_turn_point = ((int32_t*)&relative_position_at_turn_point)[1];
}

void move_n_steps_in_m_time(int32_t displacement, uint32_t time_delta)
{
//	uint64_t local_time = get_microsecond_time();
//	add_to_queue(desired_position - displacement, local_time + time_delta);
}


uint8_t get_n_items_in_queue(void)
{
	return n_items_in_queue;
}


void clear_the_queue_and_stop(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    clear_the_queue_and_stop_no_disable_interrupt();
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}


void add_trapezoid_move_to_queue(int32_t total_displacement, uint32_t total_time)
{
	int32_t acceleration;
	uint32_t delta_t1;
	uint32_t delta_t2;

	compute_trapezoid_move(total_displacement, total_time, &acceleration, &delta_t1, &delta_t2);

	add_to_queue(acceleration, delta_t1, MOVE_WITH_ACCELERATION);
	add_to_queue(0, delta_t2, MOVE_WITH_ACCELERATION);
	add_to_queue(-acceleration, delta_t1, MOVE_WITH_ACCELERATION);
}

#define VELOCITY_AVERAGING_SHIFT_RIGHT 8
#define VELOCITY_AVERAGING_TIME_STEPS ((1 << VELOCITY_AVERAGING_SHIFT_RIGHT) - 1)

void compute_velocity(void)
{
	static int32_t velocity_moving_average = 0;

	velocity_moving_average = (VELOCITY_AVERAGING_TIME_STEPS * velocity_moving_average + (hall_position_delta << 8) + (1 << (VELOCITY_AVERAGING_SHIFT_RIGHT - 1))) >> VELOCITY_AVERAGING_SHIFT_RIGHT;
	velocity = ((velocity_moving_average + (1 << (8 - 1))) >> 8);
}

uint8_t handle_queued_movements(void)
{
	if(!decelerate_to_stop_active) {
		if(n_items_in_queue > 0) {
			// there is an assumption here that any item in the queue will always have one or more time steps
			// see the add_to_queue function where we make sure to never add an item to the queue with zero time steps
			if(movement_queue[queue_read_position].movement_type == MOVE_WITH_ACCELERATION) {
				current_velocity_i64 += movement_queue[queue_read_position].acceleration; // consume one time step worth of acceleration
				movement_queue[queue_read_position].n_time_steps--;
				if(movement_queue[queue_read_position].n_time_steps == 0) {
					queue_read_position = (queue_read_position + 1) & (MOVEMENT_QUEUE_SIZE - 1);
					n_items_in_queue--;
				}
			}
			else {
				current_velocity_i64 = movement_queue[queue_read_position].velocity; // velocity is constant during this time step
				movement_queue[queue_read_position].n_time_steps--;
				if(movement_queue[queue_read_position].n_time_steps == 0) {
					queue_read_position = (queue_read_position + 1) & (MOVEMENT_QUEUE_SIZE - 1);
					n_items_in_queue--;
				}
			}
		}
		else {
			decelerate_to_stop_active = 1;
		}
	}
	if(decelerate_to_stop_active) {
		if(current_velocity_i64 != 0) {
			fatal_error(18); // "run out of queue items" (all error text is defined in error_text.c)
		}
//		if(current_velocity_i64 >= 0) {
//			if(current_velocity_i64 > max_acceleration) {
//				current_velocity_i64 -= max_acceleration;
//			}
//			else {
//				current_velocity_i64 = 0;
//			}
//		}
//		else {
//			if(-current_velocity_i64 > max_acceleration) {
//				current_velocity_i64 += max_acceleration;
//			}
//			else {
//				current_velocity_i64 = 0;
//			}
//		}
		if(current_velocity_i64 == 0) {
			decelerate_to_stop_active = 0;
		}
	}

	if((current_velocity_i64 > max_velocity) || (current_velocity_i64 < -max_velocity)) {
		fatal_error(16); // "vel too high" (all error text is defined in error_text.c)
	}
	current_position_i64 += current_velocity_i64;

	return (current_velocity_i64 != 0);

}


#define PID_SHIFT_RIGHT 18
#define ERROR_HYSTERESIS_P 0
#define ERROR_HYSTERESIS_D 0

#define PROPORTIONAL_CONSTANT_PID 5000
#define INTEGRAL_CONSTANT_PID     1
#define DERIVATIVE_CONSTANT_PID   5000

#define MAX_INT32         2147483647
#define MAX_INTEGRAL_TERM (CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT)
#define MAX_OTHER_TERMS   ((MAX_INT32 - MAX_INTEGRAL_TERM) / 2)
#define MAX_ERROR         ((MAX_OTHER_TERMS / PROPORTIONAL_CONSTANT_PID) - ERROR_HYSTERESIS_P)
#define MAX_ERROR_CHANGE  ((MAX_OTHER_TERMS / DERIVATIVE_CONSTANT_PID) - ERROR_HYSTERESIS_D)
//#define DERIVATIVE_CONSTANT_PID 250000
//#define DERIVATIVE_CONSTANT_PID 1280000

int32_t PID_controller(int32_t error)
{
    int32_t output_value;
    int32_t proportional_term;
    static int32_t integral_term = 0;
    int32_t derivative_term;
    static int32_t previous_error = 0;
    int32_t error_change;
    static int32_t low_pass_filtered_error_change = 0;

    if(error < -MAX_ERROR) {
        error = -MAX_ERROR;
    }
    else if(error > MAX_ERROR) {
        error = MAX_ERROR;
    }
    integral_term += (error * INTEGRAL_CONSTANT_PID);
    if(integral_term > (CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT)) {
    	integral_term = CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT;
    }
    else if(integral_term < -(CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT)) {
    	integral_term = -(CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT);
    }
    proportional_term = error * PROPORTIONAL_CONSTANT_PID;

    error_change = error - previous_error;
    if(error_change > MAX_ERROR_CHANGE) {
    	error_change = MAX_ERROR_CHANGE;
    }
    if(error_change < -MAX_ERROR_CHANGE) {
    	error_change = -MAX_ERROR_CHANGE;
    }

    low_pass_filtered_error_change = (low_pass_filtered_error_change * 15);
    low_pass_filtered_error_change += error_change;
    low_pass_filtered_error_change >>= 4;
    derivative_term = low_pass_filtered_error_change * DERIVATIVE_CONSTANT_PID;
    previous_error = error;
    output_value = (integral_term + proportional_term + derivative_term) >> PID_SHIFT_RIGHT;

//    if(output_value < -CLOSED_LOOP_PWM_VOLTAGE) {
//        output_value = -CLOSED_LOOP_PWM_VOLTAGE;
//    }
//    else if(output_value > CLOSED_LOOP_PWM_VOLTAGE) {
//        output_value = CLOSED_LOOP_PWM_VOLTAGE;
//    }

    return output_value;
}


int32_t PID_controller_with_hysteresis(int32_t error)
{
	static int32_t error_with_hysteresis_p;
	static int32_t error_with_hysteresis_d;
    int32_t output_value;
    int32_t proportional_term;
    static int32_t integral_term = 0;
    int32_t derivative_term;
    static int32_t previous_error = 0;
    int32_t error_change;
    static int32_t low_pass_filtered_error_change = 0;

	// make sure the error is winin some range to prevent overlow of the math
    if(error < -MAX_ERROR) {
        error = -MAX_ERROR;
    }
    else if(error > MAX_ERROR) {
        error = MAX_ERROR;
    }

	// calculate the error with hysteresis to be used in the proportional term of the PID controller
	if(error - (ERROR_HYSTERESIS_P >> 1) > error_with_hysteresis_p) {
		error_with_hysteresis_p = error - (ERROR_HYSTERESIS_P >> 1);
	}
	else if(error + (ERROR_HYSTERESIS_P >> 1) < error_with_hysteresis_p) {
		error_with_hysteresis_p = error + (ERROR_HYSTERESIS_P >> 1);
	}

	// calculate the error with hysteresis to be used in the derivative term of the PID controller
	if(error - (ERROR_HYSTERESIS_D >> 1) > error_with_hysteresis_d) {
		error_with_hysteresis_d = error - (ERROR_HYSTERESIS_D >> 1);
	}
	else if(error + (ERROR_HYSTERESIS_D >> 1) < error_with_hysteresis_d) {
		error_with_hysteresis_d = error + (ERROR_HYSTERESIS_D >> 1);
	}

	// calculate the integral term of the PID controller
    integral_term += (error * INTEGRAL_CONSTANT_PID);
    if(integral_term > (CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT)) {
    	integral_term = CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT;
    }
    else if(integral_term < -(CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT)) {
    	integral_term = -(CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT);
    }

	// calculate the proportional term of the PID controller
    proportional_term = error_with_hysteresis_p * PROPORTIONAL_CONSTANT_PID;
    
	// calculate the derivative term of the PID controller
	error_change = error_with_hysteresis_d - previous_error;
    previous_error = error_with_hysteresis_d;
    if(error_change > MAX_ERROR_CHANGE) {
    	error_change = MAX_ERROR_CHANGE;
    }
    if(error_change < -MAX_ERROR_CHANGE) {
    	error_change = -MAX_ERROR_CHANGE;
    }
    low_pass_filtered_error_change = (low_pass_filtered_error_change * 15);
    low_pass_filtered_error_change += error_change;
    low_pass_filtered_error_change >>= 4;
    derivative_term = low_pass_filtered_error_change * DERIVATIVE_CONSTANT_PID;

    // maximum value are (approximately):
    // integral term:       66000000
    // proportional term:  250000000
    // derivative term:   1250000000
    // sum:               1510000000
    // Make sure it does not exceed the max int32_t = 2147483647
    // After shifting, the maximum values are:
    // integral term:      250
    // proportional term:  953
    // derivative term:   4768
    // sum:               6971
	// sum together the P, I, and D terms to get the final output value
    output_value = (integral_term + proportional_term + derivative_term) >> PID_SHIFT_RIGHT;

//    if(output_value < -CLOSED_LOOP_PWM_VOLTAGE) {
//        output_value = -CLOSED_LOOP_PWM_VOLTAGE;
//    }
//    else if(output_value > CLOSED_LOOP_PWM_VOLTAGE) {
//        output_value = CLOSED_LOOP_PWM_VOLTAGE;
//    }

    return output_value;
}


void motor_movement_calculations(void)
{
	uint8_t moving = 0; // 1 indicates that the motor is moving, 0 indicates that it is stopped

    if(go_to_closed_loop_mode_active) {
        go_to_closed_loop_mode_logic();
    }
    else if(homing_active) {
        handle_homing_logic();
    }
    else if(calibration_active) {
        handle_calibration_logic();
    }

    moving = handle_queued_movements();

	if( (((int32_t *)&current_position_i64)[1] > position_upper_safety_limit) || (((int32_t *)&current_position_i64)[1] < position_lower_safety_limit) ) {
		fatal_error(25); // "safety limit exceeded" (all error text is defined in error_text.c)
	}

	if(motor_control_mode == OPEN_LOOP_POSITION_CONTROL) {
		commutation_position = ((int32_t *)&current_position_i64)[1] + commutation_position_offset;
		if(moving) {
			motor_pwm_voltage = OPEN_LOOP_DYNAMIC_MOTOR_PWM_VOLTAGE;
		}
		else {
			motor_pwm_voltage = OPEN_LOOP_STATIC_MOTOR_PWM_VOLTAGE;
		}
	}
	else {
		commutation_position = hall_position + commutation_position_offset;
		if(motor_control_mode == CLOSED_LOOP_POSITION_CONTROL) {
			int32_t motor_maximum_allowed_pwm_voltage;

			motor_pwm_voltage = PID_controller(((int32_t *)&current_position_i64)[1] - hall_position);
			int32_t velocity_divided_by_KV = (velocity * VELOCITY_SCALE_FACTOR) >> 8; 
//			velocity_divided_by_KV = 0;
			if(motor_pwm_voltage >= 0) {
				motor_maximum_allowed_pwm_voltage = velocity_divided_by_KV + CLOSED_LOOP_PWM_VOLTAGE;
				if(motor_pwm_voltage > motor_maximum_allowed_pwm_voltage) {
					motor_pwm_voltage = motor_maximum_allowed_pwm_voltage;
				}
				commutation_position += HALL_TO_POSITION_90_DEGREE_OFFSET;
			}
			else {
				motor_maximum_allowed_pwm_voltage = velocity_divided_by_KV - CLOSED_LOOP_PWM_VOLTAGE;
				if(motor_pwm_voltage < motor_maximum_allowed_pwm_voltage) {
					motor_pwm_voltage = motor_maximum_allowed_pwm_voltage;
				}
				commutation_position -= HALL_TO_POSITION_90_DEGREE_OFFSET;
				motor_pwm_voltage = -motor_pwm_voltage;
			}
		}
		else {
			if(desired_motor_pwm_voltage >= 0) {
				commutation_position += HALL_TO_POSITION_90_DEGREE_OFFSET;
				motor_pwm_voltage = desired_motor_pwm_voltage;
			}
			else {
				commutation_position -= HALL_TO_POSITION_90_DEGREE_OFFSET;
				motor_pwm_voltage = -desired_motor_pwm_voltage;
			}
		}
	}
}


void motor_phase_calculations(void)
{
    static uint16_t commutation_step = 0;
    static uint16_t commutation_sub_step = 0;
    static uint32_t phase1;
    static uint32_t phase2;
    static uint32_t phase3;
    static int32_t phase1_slope;
    static int32_t phase2_slope;
    static int32_t phase3_slope;
    static int32_t tmp32bit;
//    char buf[200];
//    volatile uint32_t delay;

//    sprintf(buf, "commutation_position: %u\n", (unsigned int)commutation_position);
//    transmit(buf, strlen(buf));

    commutation_step = (commutation_position >> N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT) % N_COMMUTATION_STEPS;
    commutation_sub_step = (commutation_position & 0xff) >> (8 - N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT);

//    sprintf(buf, "commutation_step: %u   commutation_sub_step: %u\n", (unsigned int)commutation_step, (unsigned int)commutation_sub_step);
//    transmit(buf, strlen(buf));

//    for(delay = 0; delay < 100000; delay++);

    phase1 = commutation_lookup_table[commutation_step].phase1;
    phase2 = commutation_lookup_table[commutation_step].phase2;
    phase3 = commutation_lookup_table[commutation_step].phase3;
    phase1_slope = commutation_lookup_table[commutation_step].phase1_slope;
    phase2_slope = commutation_lookup_table[commutation_step].phase2_slope;
    phase3_slope = commutation_lookup_table[commutation_step].phase3_slope;

    tmp32bit = phase1_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase1 = phase1 + tmp32bit;

    tmp32bit = phase2_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase2 = phase2 + tmp32bit;

    tmp32bit = phase3_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase3 = phase3 + tmp32bit;

//    sprintf(buf, "Ph: %u %u %u   Motor voltage: %u\n", (unsigned int)phase1, (unsigned int)phase2, (unsigned int)phase3, (unsigned int)motor_pwm_voltage);
//    transmit(buf, strlen(buf));

//    for(delay = 0; delay < 100000; delay++);

    phase1 >>= 8;
    phase1 *= (uint32_t)motor_pwm_voltage;
    phase1 >>= 16;
    phase1 += 13;
    TIM1->CCR1 = phase1;

    phase2 >>= 8;
    phase2 *= (uint32_t)motor_pwm_voltage;
    phase2 >>= 16;
    phase2 += 13;
    TIM1->CCR2 = phase2;

    phase3 >>= 8;
    phase3 *= (uint32_t)motor_pwm_voltage;
    phase3 >>= 16;
    phase3 += 13;
    TIM1->CCR3 = phase3;

//    sprintf(buf, "Ph: %u %u %u   Motor voltage: %u\n", (unsigned int)phase1, (unsigned int)phase2, (unsigned int)phase3, (unsigned int)motor_pwm_voltage);
//    transmit(buf, strlen(buf));
}

#define MAX_HALL_POSITION_DELTA_FATAL_ERROR_THRESHOLD 9000
void TIM1_BRK_UP_TRG_COM_IRQHandler(void)
{
	uint16_t start_time;
	uint16_t start_time2;
	uint16_t end_time;
	uint16_t end_time2;
	uint16_t motor_control_tick_time;
	static uint16_t previous_motor_control_tick_time;
	uint16_t time_difference_delay;

	start_time = TIM3->CNT;
	start_time2 = start_time;
	hall_position = get_hall_position();
	end_time = TIM3->CNT;
	time_difference1 = end_time - start_time;
	if(time_difference1 > max_time_difference1) {
    	max_time_difference1 = time_difference1;
	}

	hall_position_delta = hall_position - previous_hall_position;
	previous_hall_position = hall_position;

	if(hall_position_delta > max_hall_position_delta) {
		max_hall_position_delta = hall_position_delta;
	}
	if(hall_position_delta < min_hall_position_delta) {
		min_hall_position_delta = hall_position_delta;
	}
	average_hall_position_delta += hall_position_delta;
	average_hall_position_delta_count++;

	if(fast_capture_data_active != 0) {
		fast_capture_data[fast_capture_data_index].hall1 = get_hall_sensor1_voltage();
		fast_capture_data[fast_capture_data_index].hall2 = get_hall_sensor2_voltage();
		fast_capture_data[fast_capture_data_index].hall3 = get_hall_sensor3_voltage();
		fast_capture_data[fast_capture_data_index].hall_position_16bit = (uint16_t)hall_position;
		fast_capture_data_index++;
		if(fast_capture_data_index >= fast_capture_data_size) {
			if(fast_capture_data_active == 1) {
				fast_capture_data_active = 0;
				fast_capture_data_result_ready = 1;
			}
			else {
				fast_capture_data_index = 0;
			}
		}
	}

	// check that the hall position didn't change too much in one cycle. if it did then there is something very wrong.
	if((hall_position_delta < -MAX_HALL_POSITION_DELTA_FATAL_ERROR_THRESHOLD) || (hall_position_delta > MAX_HALL_POSITION_DELTA_FATAL_ERROR_THRESHOLD)) {
		disable_mosfets();
		if(fast_capture_data_active) {
			fast_capture_data_active = 0;
			fast_capture_data_result_ready = 1;
		}
	}

	start_time = TIM3->CNT;
	compute_velocity();
	end_time = TIM3->CNT;
	time_difference2 = end_time - start_time;
	if(time_difference2 > max_time_difference2) {
    	max_time_difference2 = time_difference2;
	}

	start_time = TIM3->CNT;
	motor_movement_calculations();
	end_time = TIM3->CNT;
	time_difference3 = end_time - start_time;
	if(time_difference3 > max_time_difference3) {
    	max_time_difference3 = time_difference3;
	}

	// check that the position values don't go out of range (overflow)
	if((((int32_t *)&current_position_i64)[1] > POSITION_OUT_OF_RANGE_FATAL_ERROR_THRESHOLD) || (((int32_t *)&current_position_i64)[1] < -POSITION_OUT_OF_RANGE_FATAL_ERROR_THRESHOLD)) {
		fatal_error(20); // "position out of range" (all error text is defined in error_text.c)
	}

	// check that the hall sensor position doesn't go out of range (overflow)
	if((hall_position > POSITION_OUT_OF_RANGE_FATAL_ERROR_THRESHOLD) || (hall_position < -POSITION_OUT_OF_RANGE_FATAL_ERROR_THRESHOLD)) {
		fatal_error(21); // "hall position out of range" (all error text is defined in error_text.c)
	}

	start_time = TIM3->CNT;
	motor_phase_calculations();
	end_time = TIM3->CNT;
	time_difference4 = end_time - start_time;
	if(time_difference4 > max_time_difference4) {
    	max_time_difference4 = time_difference4;
	}

	motor_control_tick_time = TIM3->CNT;
	motor_control_tick_time_difference = motor_control_tick_time - previous_motor_control_tick_time;
	if(motor_control_tick_time_difference > max_motor_control_tick_time_difference) {
    	max_motor_control_tick_time_difference = motor_control_tick_time_difference;
	}
	previous_motor_control_tick_time = motor_control_tick_time;

	end_time2 = TIM3->CNT;
	motor_control_time_difference = end_time2 - start_time2;
	if(motor_control_time_difference > max_motor_control_time_difference) {
    	max_motor_control_time_difference = motor_control_time_difference;
	}
	if(motor_control_time_difference < 20) { // if the calculation was too fast, introduce an artificial delay here
		start_time = TIM3->CNT;              // let's improve this in the future with a better algorithm, ok?
		do {
			end_time = TIM3->CNT;
			time_difference_delay = end_time - start_time;
		} while(time_difference_delay < 20 - motor_control_time_difference);
	}

	TIM1->SR = 0; // clear the interrupt flag
}


void increase_motor_pwm_voltage(void)
{
	char buf[100];
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	desired_motor_pwm_voltage++;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
	sprintf(buf, "desired_motor_pwm_voltage: %d\n", (int)desired_motor_pwm_voltage);
	transmit(buf, strlen(buf));
}

void decrease_motor_pwm_voltage(void)
{
	char buf[100];
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	desired_motor_pwm_voltage--;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
	sprintf(buf, "desired_motor_pwm_voltage: %d\n", (int)desired_motor_pwm_voltage);
	transmit(buf, strlen(buf));
}

void set_motor_control_mode(uint8_t new_motor_control_mode)
{
	motor_control_mode = new_motor_control_mode;
}

uint8_t get_motor_control_mode(void)
{
	return motor_control_mode;
}

uint32_t get_update_frequency(void)
{
	return PWM_FREQUENCY >> 1;
}

void zero_position_and_hall_sensor(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    clear_the_queue_and_stop_no_disable_interrupt();
	commutation_position_offset = commutation_position_offset - ((int32_t *)&current_position_i64)[1];
    zero_hall_position();
	current_position_i64 = 0;
	current_velocity_i64 = 0;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}


void set_max_velocity(uint32_t new_max_velocity)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	max_velocity = new_max_velocity;
	max_velocity <<= VELOCITY_SHIFT_LEFT;
	if(max_velocity > MAX_VELOCITY) {
		max_velocity = MAX_VELOCITY;
	}
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

int32_t get_max_velocity(void)
{
	return max_velocity;
}

void set_max_acceleration(uint32_t new_max_acceleration)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	max_acceleration = new_max_acceleration;
	max_acceleration <<= ACCELERATION_SHIFT_LEFT;
	if(max_acceleration > MAX_ACCELERATION) {
		max_acceleration = MAX_ACCELERATION;
	}
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

int32_t get_max_acceleration(void)
{
	return max_acceleration;
}

int32_t get_current_position(void)
{
	return ((int32_t *)&current_position_i64)[1];
}

void reset_time(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    clear_the_queue_and_stop_no_disable_interrupt();
    reset_microsecond_time();
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}

void emergency_stop(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    disable_mosfets();
    clear_the_queue_and_stop_no_disable_interrupt();
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}


int32_t get_actual_motor_position(void)
{
	int32_t ret;

    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	if(motor_control_mode == CLOSED_LOOP_POSITION_CONTROL) {
		ret = hall_position;
	}
	else {
		ret = ((int32_t *)&current_position_i64)[1];
	}
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
    return ret;
}

uint8_t get_motor_status_flags(void)
{
	uint8_t motor_status_flags = 0;
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
	if(get_mosfets_enabled()) {
		motor_status_flags |= (1 << STATUS_MOSFETS_ENABLED_FLAG_BIT);
	}
	if(motor_control_mode == CLOSED_LOOP_POSITION_CONTROL) {
		motor_status_flags |= (1 << STATUS_CLOSED_LOOP_FLAG_BIT);
	}
	if(calibration_active) {
		motor_status_flags |= (1 << STATUS_CALIBRATING_FLAG_BIT);
	}
	if(homing_active) {
		motor_status_flags |= (1 << STATUS_HOMING_FLAG_BIT);
	}
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt

	return motor_status_flags;
}

// This needs to be called before the MOSFETs are activated, so that the current flow through them is 0
void set_motor_current_baseline(void)
{
	motor_current_baseline = get_motor_current();
	if((motor_current_baseline < MIN_MOTOR_CURRENT_BASELINE) || (motor_current_baseline > MAX_MOTOR_CURRENT_BASELINE)) {
		fatal_error(22);
	}
}

void set_max_motor_current(uint16_t new_max_motor_current, uint16_t new_max_motor_regen_current)
{
	if((new_max_motor_current > MAX_MOTOR_CURRENT) || (new_max_motor_regen_current > MAX_MOTOR_CURRENT)) {
		fatal_error(23);
	}
	global_settings.max_motor_current = new_max_motor_current;
	global_settings.max_motor_regen_current = new_max_motor_regen_current;
	set_analog_watchdog_limits(motor_current_baseline - global_settings.max_motor_current, motor_current_baseline + global_settings.max_motor_regen_current);
}

void set_movement_limits(int32_t lower_limit, int32_t upper_limit)
{
	position_lower_safety_limit = lower_limit;
	position_upper_safety_limit = upper_limit;
}
