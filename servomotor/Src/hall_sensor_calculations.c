#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "stm32g0xx_hal.h"
#include "CommutationTable.h"  // generated by a program called process_raw_hall_data.py
#include "hall_sensor_calculations.h"
#include "error_handling.h"
#include "ADC.h"
#include "debug_uart.h"
#ifdef PRODUCT_NAME_M1
#include "LookupTable_M1.h"
#endif
#ifdef PRODUCT_NAME_M2
#include "LookupTable_M2.h"
#endif
#include "global_variables.h"

#define UINT32_MIDPOINT 2147483648
#define HALL_POSITION_HYSTERESIS 100

static const struct hall_weights_struct hall_weights = HALL_WEIGHTS_INITIALIZER;

extern uint16_t ADC_buffer[DMA_ADC_BUFFER_SIZE];

static int8_t previous_largest_sensor = -1;
static int32_t sensor_incremental_position = 0;
static int32_t hall_sensor_offset = 0;
static uint16_t time_difference_div = 0;
static int32_t hall_position_with_hysteresis = 0;
static uint8_t hall_sensor_statitics_active = 0;
static hall_sensor_statistics_t hall_sensor_statistics;

void adjust_hall_sensor_readings(uint16_t hall_sensor_readings[3], int32_t adjusted_hall_sensor_readings[3])
{
	int32_t d0_shifted = (int32_t)hall_sensor_readings[0] - (int32_t)global_settings.hall1_midline;
	int32_t d1_shifted = (int32_t)hall_sensor_readings[1] - (int32_t)global_settings.hall2_midline;
	int32_t d2_shifted = (int32_t)hall_sensor_readings[2] - (int32_t)global_settings.hall3_midline;
    int32_t d0 = (d0_shifted * hall_weights.h1[0] + d1_shifted * hall_weights.h1[1] + d2_shifted * hall_weights.h1[2]);
    int32_t d1 = (d1_shifted * hall_weights.h2[0] + d2_shifted * hall_weights.h2[1] + d0_shifted * hall_weights.h2[2]);
    int32_t d2 = (d2_shifted * hall_weights.h3[0] + d0_shifted * hall_weights.h3[1] + d1_shifted * hall_weights.h3[2]);
    adjusted_hall_sensor_readings[0] = d0;
    adjusted_hall_sensor_readings[1] = d1;
    adjusted_hall_sensor_readings[2] = d2;
}

int32_t get_hall_position(void)
{
    uint16_t hall_sensor_readings[3];
	int32_t d[3];
    int8_t largest_sensor;
    int32_t numerator;
    int32_t denominator;
    int32_t fraction;
    static uint16_t start_time;
	static uint16_t end_time;


	hall_sensor_readings[0] = ((ADC_buffer[HALL1_ADC_CYCLE_INDEX] + ADC_buffer[HALL1_ADC_CYCLE_INDEX + 8] +
                                ADC_buffer[HALL1_ADC_CYCLE_INDEX + 16] + ADC_buffer[HALL1_ADC_CYCLE_INDEX + 24]) << 3) - HALL_SENSOR_SHIFT;
	hall_sensor_readings[1] = ((ADC_buffer[HALL2_ADC_CYCLE_INDEX] + ADC_buffer[HALL2_ADC_CYCLE_INDEX + 8] +
                                ADC_buffer[HALL2_ADC_CYCLE_INDEX + 16] + ADC_buffer[HALL2_ADC_CYCLE_INDEX + 24]) << 3) - HALL_SENSOR_SHIFT;
	hall_sensor_readings[2] = ((ADC_buffer[HALL3_ADC_CYCLE_INDEX] + ADC_buffer[HALL3_ADC_CYCLE_INDEX + 8] +
                                ADC_buffer[HALL3_ADC_CYCLE_INDEX + 16] + ADC_buffer[HALL3_ADC_CYCLE_INDEX + 24]) << 3) - HALL_SENSOR_SHIFT;

    if(hall_sensor_statitics_active) {
        for(uint8_t h = 0; h < 3; h++) {
            if(hall_sensor_readings[h] > hall_sensor_statistics.max_value[h]) {
                hall_sensor_statistics.max_value[h] = hall_sensor_readings[h];
            }
            if(hall_sensor_readings[h] < hall_sensor_statistics.min_value[h]) {
                hall_sensor_statistics.min_value[h] = hall_sensor_readings[h];
            }
            if(hall_sensor_statistics.n < 0xFFFFFFFF) {
                hall_sensor_statistics.sum[h] += hall_sensor_readings[h];
            }
        }
        if(hall_sensor_statistics.n < 0xFFFFFFFF) {
            hall_sensor_statistics.n++;
        }
    }

	adjust_hall_sensor_readings(hall_sensor_readings, d);

    if((d[0] >= d[1]) && (d[0] >= d[2])) { // check if d[0] is the highest
        largest_sensor = 0;
        numerator = d[1] - d[2];
        if(d[2] > d[1]) {
            denominator = d[0] - d[1];
        }
        else {
            denominator = d[0] - d[2];
        }
    }
    else if ((d[1] >= d[2]) && (d[1] >= d[0])) { // check if d[1] is the highest
        largest_sensor = 1;
        numerator = d[2] - d[0];
        if(d[0] > d[2]) {
            denominator = d[1] - d[2];
        }
        else {
            denominator = d[1] - d[0];
        }
    }
    else {                                    // otherwise d[2] is the highest
        largest_sensor = 2;
        numerator = d[0] - d[1];
        if(d[1] > d[0]) {
            denominator = d[2] - d[0];
        }
        else {
            denominator = d[2] - d[1];
        }
    }

//    numerator >>= 10;
//    denominator >>= 10;

    while((numerator > 32767) || (numerator < -32767)) {
        numerator >>= 1;
        denominator >>= 1;
    }

    start_time = TIM14->CNT;
    // watch out: it seems that this division will give the wrong result if the denominator exceeds the int16_t range
//    #ifdef PRODUCT_NAME_M1
    fraction = numerator * SENSOR_SEGMENT_RESOLUTION_DIV_2 / denominator;
//    #endif
//    #ifdef PRODUCT_NAME_M2
//    fraction = ((numerator * (SENSOR_SEGMENT_RESOLUTION_DIV_2 >> 3) / denominator) << 3);
//    #endif
    end_time = TIM14->CNT;
    time_difference_div = end_time - start_time;
    fraction = fraction + SENSOR_SEGMENT_RESOLUTION_DIV_2;

    if(previous_largest_sensor == -1) {
        previous_largest_sensor = largest_sensor;
    }
    else if (largest_sensor != previous_largest_sensor) {
        if (largest_sensor - previous_largest_sensor == 1) {
            sensor_incremental_position = sensor_incremental_position + (int32_t)SENSOR_SEGMENT_RESOLUTION;
        }
        else if (largest_sensor - previous_largest_sensor == -1) {
            sensor_incremental_position = sensor_incremental_position - (int32_t)SENSOR_SEGMENT_RESOLUTION;
        }
        else if (largest_sensor - previous_largest_sensor == -2) {
            sensor_incremental_position = sensor_incremental_position + (int32_t)SENSOR_SEGMENT_RESOLUTION;
        }
        else {
            sensor_incremental_position = sensor_incremental_position - (int32_t)SENSOR_SEGMENT_RESOLUTION;
        }
        previous_largest_sensor = largest_sensor;
    }

	return sensor_incremental_position + fraction - hall_sensor_offset;
}


int32_t get_hall_position_with_hysteresis(void)
{
	int32_t hall_position;

	hall_position = get_hall_position();
	if(hall_position > hall_position_with_hysteresis) {
		hall_position_with_hysteresis = hall_position;
	}
	else if(hall_position + HALL_POSITION_HYSTERESIS < hall_position_with_hysteresis) {
		hall_position_with_hysteresis = hall_position + HALL_POSITION_HYSTERESIS;
	}

	return hall_position_with_hysteresis;
}


int32_t zero_hall_position(void)
{
//	previous_largest_sensor = -1;
//	sensor_incremental_position = 0;
//    int32_t hall_sensor_offset_saved = hall_sensor_offset;
	int32_t hall_position = get_hall_position();
    int32_t hall_position_adjustment = hall_position;
	hall_sensor_offset += hall_position_adjustment;
    return hall_position_adjustment;
}


void print_hall_position(void)
{
	char buf[100];
	int32_t hall_position = get_hall_position();
	sprintf(buf, "hall_position: %d   time_difference_div: %hu\n", (int)hall_position, time_difference_div);
	transmit(buf, strlen(buf));
}


void print_hall_midlines(void)
{
    char buf[100];
    sprintf(buf, "Hall sensor midlines: %u %u %u\n", global_settings.hall1_midline, global_settings.hall2_midline, global_settings.hall3_midline);
    transmit(buf, strlen(buf));
}


void get_hall_sensor_statistics(hall_sensor_statistics_t *hall_sensor_statistics_output)
{
	TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    memcpy(hall_sensor_statistics_output, &hall_sensor_statistics, sizeof(hall_sensor_statistics));
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}


void hall_sensor_turn_off_statistics(void)
{
    hall_sensor_statitics_active = 0;
}


void hall_sensor_turn_on_and_reset_statistics(void)
{
	TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    for(uint8_t h = 0; h < 3; h++) {
        hall_sensor_statistics.min_value[h] = 0xFFFF;
        hall_sensor_statistics.max_value[h] = 0;
        hall_sensor_statistics.sum[h] = 0;
        hall_sensor_statistics.n = 0;
    }
    hall_sensor_statitics_active = 1;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}