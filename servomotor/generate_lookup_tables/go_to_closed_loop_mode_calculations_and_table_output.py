#!/usr/bin/env python3
import glob
import numpy as np
import math
import cmath
import matplotlib.pyplot as plt

GO_TO_CLOSED_LOOP_MOTOR_PWM_VOLTAGE = 80
DESIRED_MOTOR_PWM_VOLTAGE_STEP = 8
GO_TO_CLOSED_LOOP_SHIFT_RIGHT = 1
VIBRATION_QUARTER_CYCLE_DURATION = 40
GO_TO_CLOSED_LOOP_N_DATA_ITEMS = (int(VIBRATION_QUARTER_CYCLE_DURATION * 4) >> GO_TO_CLOSED_LOOP_SHIFT_RIGHT)
GO_TO_CLOSED_LOOP_PHASE_ADJUSTMENT_SAMPLES = 9 # positive number makes the plot of imaginary vs. real become rotated counter-clockwise around the origin
GO_TO_CLOSED_LOOP_AVERAGE_SAMPLES = 100

go_to_closed_loop_phase_adjustment_samples = GO_TO_CLOSED_LOOP_PHASE_ADJUSTMENT_SAMPLES
if go_to_closed_loop_phase_adjustment_samples < 0:
    go_to_closed_loop_phase_adjustment_samples += GO_TO_CLOSED_LOOP_N_DATA_ITEMS


HASH_DEFINES_SAVE_FILENAME = "../Src/goertzel_algorithm_constants.h"
#HASH_DEFINES_SAVE_FILENAME = "goertzel_algorithm_constants.h"

DATA_FOLDER = "go_to_closed_loop_sensor_data"
FILE_PATTERN = "d?"
FINAL_DATA_FILE = "final_data"

MIN_INT32 = -(1 << 31)
MAX_INT32 = (1 << 31) - 1
MIN_INT64 = -(1 << 63)
MAX_INT64 = (1 << 63) - 1

min_int32 = MAX_INT32
max_int32 = MIN_INT32
min_int64 = MAX_INT64
max_int64 = MIN_INT64
max_percent_error = 0
normalized_phase_list = []
color_list = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']  # Add more colors if there are more than 8 datasets 
color_index = 0

MAX_INT_PERCENTAGE_ALLOWED = 30.0
MAX_PERCENT_ERROR_ALLOWED = 1.0

def record_min_and_max(x, n_bits):
    global min_int32
    global max_int32
    global min_int64
    global max_int64
    if n_bits == 32:
        if x < min_int32:
            min_int32 = x
        if x > max_int32:
            max_int32 = x
    elif n_bits == 64:
        if x < min_int64:
            min_int64 = x
        if x > max_int64:
            max_int64 = x
    else:
        print("This many bits is not supported by the record_min_and_max function:", n_bits)
        exit(1)


def record_min_and_max_error(x, x_ref):
    global max_percent_error
    if x_ref != 0:
        percent_error = abs((x - x_ref) / x_ref * 100)
        if percent_error > max_percent_error:
            max_percent_error = percent_error


def read_data_file(filename):
    data_list = []
    with open(filename, 'r') as file:
        data = file.readlines()
    for line in data:
        fields = line.split(":")
        if len(fields) == 2:
            value = int(line.split(":")[1])
            data_list.append(value)
    return data_list


def save_hash_defines(filename, goertzel_constants):
    with open(filename, "w") as fh:
        fh.write("#ifndef __GOERTZEL_ALGORITHM_CONSTANTS__\n")
        fh.write("#define __GOERTZEL_ALGORITHM_CONSTANTS__\n")
        fh.write("\n")
        fh.write("// This file is autogenerated by the program called go_to_closed_loop_mode_calculations_and_table_output.py\n")
        fh.write("// * * * DO NOT EDIT * * * Instead, edit the program that autogenerates this\n")
        fh.write("\n")
        fh.write("#define GO_TO_CLOSED_LOOP_MOTOR_PWM_VOLTAGE " + str(GO_TO_CLOSED_LOOP_MOTOR_PWM_VOLTAGE) + "\n")
        fh.write("#define DESIRED_MOTOR_PWM_VOLTAGE_STEP " + str(DESIRED_MOTOR_PWM_VOLTAGE_STEP) + "\n")
        fh.write("#define GO_TO_CLOSED_LOOP_SHIFT_RIGHT " + str(GO_TO_CLOSED_LOOP_SHIFT_RIGHT) + "\n")
        fh.write("#define VIBRATION_QUARTER_CYCLE_DURATION " + str(VIBRATION_QUARTER_CYCLE_DURATION) + "\n")
        fh.write("#define GO_TO_CLOSED_LOOP_PHASE_ADJUSTMENT_SAMPLES " + str(go_to_closed_loop_phase_adjustment_samples) + " // positive number makes the plot of imaginary vs. real become rotated counter-clockwise around the origin\n")
        fh.write("#define GO_TO_CLOSED_LOOP_AVERAGE_SAMPLES " + str(GO_TO_CLOSED_LOOP_AVERAGE_SAMPLES) + "\n")
        fh.write("\n")
        fh.write("#define W_REAL_MULTIPLIER " + str(goertzel_constants.w_real_multiplier) + "\n")
        fh.write("#define W_REAL_SHIFT " + str(goertzel_constants.w_real_shift) + "\n")
        fh.write("#define W_IMAG_MULTIPLIER " + str(goertzel_constants.w_imag_multiplier) + "\n")
        fh.write("#define W_IMAG_SHIFT " + str(goertzel_constants.w_imag_shift) + "\n")
        fh.write("\n")
        fh.write("#endif\n")


class calculate_constants:
    def calculate(self, n_samples):
        print("Calculating the constants:")
        self.n_samples = n_samples
        sample_rate = n_samples
        frequency = 1.0
        f = frequency / sample_rate
        print("f: " + str(f))
        w_real = 2.0 * math.cos(2.0 * math.pi * f)
        w_imag = math.sin(2.0 * math.pi * f)
        print("   w_real: " + str(w_real))
        print("   w_imag: " + str(w_imag))
        self.w_real_shift = 20
        self.w_real_multiplier = int(w_real * (1 << self.w_real_shift) + 0.5)
        self.w_imag_shift = 20
        self.w_imag_multiplier = int(w_imag * (1 << self.w_imag_shift) + 0.5)
        print("w_real_multiplier:", self.w_real_multiplier)
        print("w_real_shift:", self.w_real_shift)
        print("w_imag_multiplier:", self.w_imag_multiplier)
        print("w_imag_shift:", self.w_imag_shift)

    def get_constants(self):
        return (self.w_real_multiplier, self.w_real_shift, self.w_imag_multiplier, self.w_imag_shift)

    def print_hash_defines(self):
        print("#define W_REAL_MULTIPLIER", self.w_real_multiplier)
        print("#define W_REAL_SHIFT", self.w_real_shift)
        print("#define W_IMAG_MULTIPLIER", self.w_imag_multiplier)
        print("#define W_IMAG_SHIFT", self.w_imag_shift)



def goertzel_algorithm(samples, sample_rate, frequency):
    n_samples = len(samples)
    print("n_samples: " + str(n_samples))
    f = frequency / sample_rate
    print("f: " + str(f))
    w_real = 2.0 * math.cos(2.0 * math.pi * f)
    w_imag = math.sin(2.0 * math.pi * f)
    print("w_real: " + str(w_real))
    print("w_imag: " + str(w_imag))
    d1, d2 = 0.0, 0.0
    for n in range(n_samples):
        y = samples[n] + w_real * d1 - d2
        d2 = d1
        d1 = y
    result = (0.5 * w_real * d1 - d2, w_imag * d1)
    return result


def goertzel_algorithm_integer_math(samples, constants):
    (w_real_multiplier, w_real_shift, w_imag_multiplier, w_imag_shift) = constants
    n_samples = len(samples)
    print("n_samples: " + str(n_samples))
    d1 = 0
    d2 = 0
    for n in range(n_samples):
        d1_times_w_real_multiplier_64bit = d1 * w_real_multiplier
        y = samples[n] + (d1_times_w_real_multiplier_64bit >> w_real_shift) - d2
        d2 = d1
        d1 = y
        print("n: %d, d1_times_w_real_multiplier_64bit: %d, y: %d, d1: %d, d2: %d" % (n, d1_times_w_real_multiplier_64bit, y, d1, d2))
        record_min_and_max(d1_times_w_real_multiplier_64bit, 64)
        record_min_and_max(y, 32)
        record_min_and_max(d1, 32)
        record_min_and_max(d2, 32)
    d1_times_w_real_multiplier_64bit = w_real_multiplier * d1
    d1_times_w_imag_multiplier_64bit = d1 * w_imag_multiplier
    record_min_and_max(d1_times_w_real_multiplier_64bit, 64)
    record_min_and_max(d1_times_w_imag_multiplier_64bit, 64)
    d1_times_w_real_multiplier_32bit = (d1_times_w_real_multiplier_64bit >> w_real_shift)
    d1_times_w_imag_multiplier_32bit = (d1_times_w_imag_multiplier_64bit >> w_imag_shift)
    record_min_and_max(d1_times_w_real_multiplier_32bit, 32)
    record_min_and_max(d1_times_w_imag_multiplier_32bit, 32)
    result = ((d1_times_w_real_multiplier_32bit >> 1) - d2, d1_times_w_imag_multiplier_32bit)
    return result


def get_magnitude_and_phase(complex_number):
    magnitude = abs(complex_number)
    phase = cmath.phase(complex_number)
    return magnitude, phase


def process_file(filename):
    global normalized_phase_list
    global color_index
    print(f'Reading file: {filename}...')
    data_list = read_data_file(filename)
    n_samples = len(data_list)
    print("N samples: " + str(n_samples))

    sampling_time = 1.0
    frequency = 1.0
    sample_rate = n_samples / sampling_time
    sampling_period = 1.0 / sample_rate
    time_list = np.arange(0, sampling_time, sampling_period)

    color = color_list[color_index % len(color_list)]  # Get color for this dataset
    color_index += 1  # Move to next color
    plt.plot(time_list, data_list, label=filename, color=color)

    cc = calculate_constants()
    cc.calculate(n_samples)

    result_reference = goertzel_algorithm(data_list, sample_rate, frequency)
    result = goertzel_algorithm_integer_math(data_list, cc.get_constants())
    print("--------------------------------------------------")
    print("Result reference: " + str(result_reference))
    print("Result: " + str(result))
    print("--------------------------------------------------")
    real_part_reference = result_reference[0]
    imag_part_reference = result_reference[1]
    real_part = result[0]
    imag_part = result[1]
    record_min_and_max_error(real_part, real_part_reference)
    record_min_and_max_error(imag_part, imag_part_reference)
    magnitude = math.sqrt(real_part**2 + imag_part**2) / n_samples
    phase = math.atan2(imag_part, real_part)
    print("Real: " + str(real_part) + ", Imag: " + str(imag_part))
    print("Magnitude: " + str(magnitude))
    print("Phase (radians): " + str(phase))
    print("Phase (degrees): " + str(phase * 180 / math.pi))
    normalized_phase = phase / (2 * math.pi)
    if normalized_phase < 0.0:
        normalized_phase += 1.0
    print("Phase normalized: " + str(normalized_phase))
    normalized_phase_list.append(normalized_phase)
    sine_wave = []
    for t in time_list:
        omega = 2 * math.pi * frequency
        y_value = magnitude * math.cos(omega * t + phase)
        sine_wave.append(y_value)
    plt.plot(time_list, sine_wave, label=f'Sine wave {filename}', color=color)


def read_all_data_files():
    file_pattern = 'd*'
    files = glob.glob(DATA_FOLDER + "/" + FILE_PATTERN)
    timescale = np.arange(0, 1, 1/48000) 

    for filename in files:
        process_file(filename)
    process_file(DATA_FOLDER + "/" + FINAL_DATA_FILE)

    print("The normalized phase list is:")
    for p in normalized_phase_list:
        print("  ", p)

    print("min_int32:", min_int32)
    print("max_int32:", max_int32)
    print("min_int64:", min_int64)
    print("max_int64:", max_int64)
    int32_percentage_of_full_range_used_neg = min_int32 / MIN_INT32 * 100
    int32_percentage_of_full_range_used_pos = max_int32 / MAX_INT32 * 100
    int64_percentage_of_full_range_used_neg = min_int64 / MIN_INT64 * 100
    int64_percentage_of_full_range_used_pos = max_int64 / MAX_INT64 * 100
    print("Percentage of the full range of the 32 and 64 bit integers used:")
    print("   32-bit (negative side):", int32_percentage_of_full_range_used_neg)
    print("   32-bit (positive side):", int32_percentage_of_full_range_used_pos)
    print("   64-bit (negative side):", int64_percentage_of_full_range_used_neg)
    print("   64-bit (positive side):", int64_percentage_of_full_range_used_pos)
    print("max_percent_error:", max_percent_error)

    failed = False
    if int32_percentage_of_full_range_used_neg > MAX_INT_PERCENTAGE_ALLOWED:
        print(f"Error: we exceeded the maximim allowed percentage of the interger (on negative side): {int32_percentage_of_full_range_used_neg} > {MAX_INT_PERCENTAGE_ALLOWED}")
        failed = True
    if int32_percentage_of_full_range_used_pos > MAX_INT_PERCENTAGE_ALLOWED:
        print(f"Error: we exceeded the maximim allowed percentage of the interger (on positive side): {int32_percentage_of_full_range_used_pos} > {MAX_INT_PERCENTAGE_ALLOWED}")
        faile = True
    if max_percent_error > MAX_PERCENT_ERROR_ALLOWED:
        print(f"Error: we exceeded the maximim allowed percent error: {max_percent_error} > {MAX_PERCENT_ERROR_ALLOWED}")
        failed = True

    plt.title("Data and Sine Waves from Files")
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude")
    plt.legend()
    plt.grid(True)
    plt.show()

    if failed:
        print("* * * FAILED * * *")
        exit(1)

    filename = DATA_FOLDER + "/" + FINAL_DATA_FILE
    print(f'Reading file, {filename} again...')
    data_list = read_data_file(filename)
    n_samples = GO_TO_CLOSED_LOOP_N_DATA_ITEMS
    print("N samples: " + str(n_samples))
    cc = calculate_constants()
    cc.calculate(n_samples)
    cc.print_hash_defines()
    save_hash_defines(HASH_DEFINES_SAVE_FILENAME, cc)
    print(f"The file called {HASH_DEFINES_SAVE_FILENAME} was written. Now, recompile your project.")

    if len(data_list) != n_samples:
        print(f"Error: the number of samples in the file {filename} is {len(data_list)} but it should be {n_samples}")
        print("What you might need to do now is recompile your project, upload that firmware to the device, and then capture new data")
        print("using the program called test_go_to_closed_loop_mode.py. Then run this script again.")
        print("* * * FAILED * * *")
        exit(1)
    print("* * * PASSED * * *")

if __name__ == '__main__':
    read_all_data_files()
