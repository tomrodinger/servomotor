#!/usr/bin/env python3
"""
Main script to generate code files for the Servomotor library.

This script loads data from JSON files, processes templates by calling
functions in the generate_command_code_module, and writes the results
to output files.
"""

import json
import os
import re
import sys
import importlib
from datetime import datetime
from pathlib import Path

# Import the module functions
from generate_command_code_module.generate_commands_header import generate_commands_header
from generate_command_code_module.generate_payload_structures import generate_payload_structures

# Get the absolute path of the Arduino library directory
ARDUINO_LIB_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../Arduino_library/"))
# Get the absolute path of the python_programs directory
PYTHON_PROGRAMS_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../python_programs/servomotor/"))
# Get the absolute path of the templates directory
TEMPLATES_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "generate_command_code_module/templates/"))

# Paths to JSON files
MOTOR_COMMANDS_JSON_FILE = os.path.join(PYTHON_PROGRAMS_DIR, "motor_commands.json")
DATA_TYPES_JSON_FILE = os.path.join(PYTHON_PROGRAMS_DIR, "data_types.json")
UNIT_CONVERSIONS_JSON_FILE = os.path.join(PYTHON_PROGRAMS_DIR, "unit_conversions_M3.json")

# Output file paths
COMMANDS_H_FILE = os.path.join(ARDUINO_LIB_DIR, "Commands.h")
SERVOMOTOR_CPP_FILE = os.path.join(ARDUINO_LIB_DIR, "Servomotor.cpp")
SERVOMOTOR_H_FILE = os.path.join(ARDUINO_LIB_DIR, "Servomotor.h")

# Template file paths
COMMANDS_H_TEMPLATE = os.path.join(TEMPLATES_DIR, "Commands.h.template")
SERVOMOTOR_H_TEMPLATE = os.path.join(TEMPLATES_DIR, "Servomotor.h.template")


def back_up_files(files):
    """Create timestamped backups of files."""
    for file in files:
        try:
            with open(file, 'r') as f:
                contents = f.read()
            backup_filename = f"{file}.{datetime.now().strftime('%b-%-d-%Y-%H-%M-%S')}.bak"
            with open(backup_filename, 'w') as bf:
                bf.write(contents)
            print(f"Backed up {file} to {backup_filename}")
        except FileNotFoundError:
            pass  # If it doesn't exist, skip
    sys.stdout.flush()


def add_autogen_header(content, filename):
    """
    Add the autogeneration header to a file.
    
    Args:
        content: The file content
        filename: The filename for the header
        
    Returns:
        The content with the header added
    """
    # Get just the basename of the file
    basename = os.path.basename(filename)
    
    # Get the current date and time
    current_date = datetime.now().strftime('%b %-d %Y %H:%M:%S')
    
    # Create the header
    header = f"""// {basename}
// This file was autogenerated by generate_command_code_new2.py on {current_date}
// Do not edit manually. If changes are needed, modify the generator program instead.

"""
    
    # Add the header to the content
    return header + content


def process_template(template_file, output_file, context):
    """
    Process a template file by replacing function call markers with function output.
    
    Args:
        template_file: Path to the template file
        output_file: Path to write the processed template
        context: Dictionary of data to pass to the functions
    """
    # Read the template
    with open(template_file, 'r') as f:
        template_content = f.read()
    
    # Find all function call markers like {{function_name}}
    function_calls = re.findall(r'{{(\w+)}}', template_content)
    
    # Process each function call
    for func_name in function_calls:
        # Try to get the function from the current module
        try:
            # Import the module
            module = importlib.import_module(f"generate_command_code_module.{func_name}")
            func = getattr(module, func_name)
            
            # Call the function with all the context data
            # Each function will use what it needs from the context
            result = func(**context)
        except (ImportError, AttributeError, TypeError) as e:
            print(f"Warning: Error calling function '{func_name}': {e}")
            print("Trying with specific imports...")
            
            # Fallback to specific functions we know about
            if func_name == 'generate_commands_header':
                result = generate_commands_header(context['commands_data'])
            elif func_name == 'generate_payload_structures':
                result = generate_payload_structures(context['commands_data'], context['data_types_data'])
            else:
                print(f"Warning: Function '{func_name}' not implemented. Skipping.")
                result = f"// Function {func_name} not implemented"
        
        # Replace the marker with the function result
        template_content = template_content.replace(f"{{{{{func_name}}}}}", result)
    
    # Add the autogeneration header
    final_content = add_autogen_header(template_content, output_file)
    
    # Write the processed template to the output file
    with open(output_file, 'w') as f:
        f.write(final_content)
    
    print(f"Generated {output_file} successfully.")


def main():
    """Execute the code generation process."""
    print(f"This script will generate the following files:")
    print(f"  {COMMANDS_H_FILE}")
    print(f"  {SERVOMOTOR_H_FILE}")
    
    # The existing files will be backed up unless --no-backup is given
    if '--no-backup' not in sys.argv:
        print("The existing files will be backed up and then overwritten.")
        print("You can give the --no-backup command line option to not make any backups.")
        backup_flag = True
    else:
        print("The --no-backup command line option was given. No backups will be made.")
        backup_flag = False
    
    # We also handle the -y prompt logic
    if '-y' in sys.argv:
        print("The -y command line option was given. Skipping the prompt and proceeding.")
    else:
        print("You can give the -y command line option to skip the following prompt.")
        print("Do you want to continue? (y/n)")
        ans = input()
        if ans.lower() != 'y':
            print("Exiting.")
            sys.exit(0)
    
    # Create backups of the files
    if backup_flag:
        back_up_files([COMMANDS_H_FILE, SERVOMOTOR_H_FILE])
    
    # Load JSON data
    try:
        with open(MOTOR_COMMANDS_JSON_FILE, 'r') as f:
            commands_data = json.load(f)
    except FileNotFoundError:
        print(f"Error: Could not find {MOTOR_COMMANDS_JSON_FILE}")
        print(f"Make sure that file exists in the Python programs directory.")
        sys.exit(1)
    
    # Create the context with all data that might be needed by template functions
    context = {
        'commands_data': commands_data,
    }
    
    # Try to load additional data files if they exist
    try:
        with open(DATA_TYPES_JSON_FILE, 'r') as f:
            context['data_types_data'] = json.load(f)
    except FileNotFoundError:
        print(f"Warning: Could not find {DATA_TYPES_JSON_FILE}")
        context['data_types_data'] = []
    
    try:
        with open(UNIT_CONVERSIONS_JSON_FILE, 'r') as f:
            context['unit_conversions_data'] = json.load(f)
    except FileNotFoundError:
        print(f"Warning: Could not find {UNIT_CONVERSIONS_JSON_FILE}")
        context['unit_conversions_data'] = {'units': {}}
    
    # Process the Commands.h template
    process_template(COMMANDS_H_TEMPLATE, COMMANDS_H_FILE, context)
    
    # Process the Servomotor.h template
    process_template(SERVOMOTOR_H_TEMPLATE, SERVOMOTOR_H_FILE, context)


if __name__ == '__main__':
    main()