#include "Servomotor.h"
#include "Commands.h"
#include "Utils.h"
#include <sstream> // For std::stringstream
#include <iomanip> // For std::setw, std::setfill

Servomotor::Servomotor(uint8_t alias, HardwareSerial& serialPort)
    : _alias(alias), _uniqueId(0), _useExtendedAddressing(false), _comm(serialPort), _errno(0),
      m_positionUnit(PositionUnit::SHAFT_ROTATIONS),
      m_velocityUnit(VelocityUnit::ROTATIONS_PER_SECOND),
      m_accelerationUnit(AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED),
      m_timeUnit(TimeUnit::SECONDS),
      m_temperatureUnit(TemperatureUnit::CELSIUS),
      m_voltageUnit(VoltageUnit::VOLTS),
      m_currentUnit(CurrentUnit::AMPS) {
    
    Serial.print("[Motor] Initialized with standard addressing, Alias: ");
    Serial.println(_alias);
    
    openSerialPort();
}

void Servomotor::setAlias(uint8_t new_alias) {
    _alias = new_alias;
    _useExtendedAddressing = false;
    Serial.print("[Motor] Set alias to ");
    Serial.println(_alias);
}

uint8_t Servomotor::getAlias() {
    return _alias;
}

void Servomotor::setUniqueId(uint64_t uniqueId) {
    _uniqueId = uniqueId;
    _useExtendedAddressing = true;
    // Use stringstream for reliable hex formatting
    std::stringstream ss;
    ss << std::hex << std::setw(16) << std::setfill('0') << _uniqueId; // Use the member variable _uniqueId
    Serial.print("[Motor] Set Unique ID to 0x");
    Serial.println(ss.str().c_str()); // Use c_str() for ConsoleSerial compatibility
}

uint64_t Servomotor::getUniqueId() const {
    return _uniqueId;
}

bool Servomotor::isUsingExtendedAddressing() const {
    return _useExtendedAddressing;
}

void Servomotor::openSerialPort() {
    _comm.openSerialPort();
}

void Servomotor::enableCRC32() {
    _comm.enableCRC32();
    Serial.println("[Motor] CRC32 enabled");
}

void Servomotor::disableCRC32() {
    _comm.disableCRC32();
    Serial.println("[Motor] CRC32 disabled");
}

bool Servomotor::isCRC32Enabled() const {
    return _comm.isCRC32Enabled();
}

int Servomotor::getError() const {
    return _errno;
}

// Helper method to send commands using the appropriate addressing mode
void Servomotor::sendCommand(uint8_t commandID, const uint8_t* payload, uint16_t payloadSize) {
    if (_useExtendedAddressing) {
        _comm.sendCommandExtended(_uniqueId, commandID, payload, payloadSize);
    } else {
        _comm.sendCommand(_alias, commandID, payload, payloadSize);
    }
}

void Servomotor::setDeviceAliasByUniqueId(uint64_t uniqueId, uint8_t alias) {
    // Direct implementation using extended addressing
    const uint8_t commandID = SET_DEVICE_ALIAS;
    setDeviceAliasPayload payload;
    payload.alias = alias;
    
    // Directly call sendCommandExtended with the provided uniqueId
    _comm.sendCommandExtended(uniqueId, commandID, (uint8_t*)&payload, sizeof(payload));
    
    uint16_t receivedSize;
    _errno = _comm.getResponse(nullptr, 0, receivedSize);
}

// AUTO-GENERATED UNIT SETTER IMPLEMENTATIONS
{{generate_unit_setters}}

// AUTO-GENERATED COMMAND IMPLEMENTATIONS
{{generate_command_implementations}}