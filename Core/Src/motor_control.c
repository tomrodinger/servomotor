#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "stm32g0xx_hal.h"
#include "CommutationTable.h"  // generated by a program called process_raw_hall_data.py
#include "error_handling.h"
#include "RS485.h"
#include "mosfets.h"
#include "debug_uart.h"
#include "ADC.h"
#include "hall_sensor_calculations.h"
#include "motor_control.h"
#include "microsecond_clock.h"

// set which axis this motor is controlling
#ifdef X_AXIS
	#include "LookupTableX.h" // generated by a program called BLDC_sin_lookup_table.py
#else
	#ifdef Y_AXIS
		#include "LookupTableY.h"
	#else
		#ifdef Z_AXIS
			#include "LookupTableZ.h"
		#else
			#ifdef SMALL_Z_AXIS
				#include "LookupTableSmallZ.h"
			#else
				#ifdef E_AXIS
					#include "LookupTableE.h"
				#else
					#error "You need to set an axis"
				#endif
			#endif
		#endif
	#endif
#endif

#define DISABLE_MOSFETS_COMMAND 0
#define ENABLE_MOSFETS_COMMAND 1
#define SET_POSITION_AND_MOVE_COMMAND 2
#define SET_VELOCITY_COMMAND 3
#define SET_POSITION_AND_FINISH_TIME_COMMAND 4
#define SET_ACCELERATION_COMMAND 5
#define START_CALIBRATION_COMMAND 6
#define CAPTURE_HALL_SENSOR_DATA_COMMAND 7
#define RESET_TIME_COMMAND 8
#define GET_CURRENT_TIME_COMMAND 9
#define TIME_SYNC_COMMAND 10
#define GET_N_ITEMS_IN_QUEUE_COMMAND 11
#define EMERGENCY_STOP_COMMAND 12
#define ZERO_POSITION_COMMAND 13
#define HOMING_COMMAND 14
#define GET_POSITION_COMMAND 15
#define GET_STATUS_COMMAND 16
#define GO_TO_CLOSED_LOOP_COMMAND 17

#define NO_ERROR_RESPONSE "R\x00\x00"

#define UINT32_MIDPOINT 2147483648
#define MOVEMENT_QUEUE_SIZE 16 // this has to be a power of 2
#define MIN_HSI_TRIM_VALUE 62
#define MAX_HSI_TRIM_VALUE 66
#define MAX_HOMING_ERROR 100000

#define CLOSED_LOOP_PWM_VOLTAGE 250
#define OPEN_LOOP_STATIC_MOTOR_PWM_VOLTAGE 100
#define OPEN_LOOP_DYNAMIC_MOTOR_PWM_VOLTAGE 175
#define CALIBRATION_MOTOR_PWM_VOLTAGE 100
#define GO_TO_CLOSED_LOOP_MODE_MOTOR_PWM_VOLTAGE 100
#define HOMING_MOTOR_PWM_VOLTAGE 100

#define VELOCITY_SCALE_FACTOR 29
#define MAX_PWM_VOLTAGE_ADJUSTMENT 400

uint8_t motor_control_mode = OPEN_LOOP_POSITION_CONTROL;

const struct three_phase_data_struct commutation_lookup_table[N_COMMUTATION_STEPS] = COMMUTATION_LOOKUP_TABLE_INITIALIZER;
extern uint16_t ADC_buffer[DMA_ADC_BUFFER_SIZE];

static int32_t hall_position = 0;

typedef struct {
    int32_t movement_end_position;
    uint64_t movement_end_time;
} movement_queue_t;
static movement_queue_t movement_queue[MOVEMENT_QUEUE_SIZE];
static uint8_t queue_write_position = 0;
static uint8_t queue_read_position = 0;
static uint8_t n_items_in_queue = 0;

static uint32_t commutation_position = 0;
static int32_t desired_position = 0; // this is the target position
static uint32_t commutation_position_offset = UINT32_MIDPOINT;
static uint64_t movement_start_time = 0;
static int32_t movement_start_position = 0;
static int32_t movement_end_position = 0;
uint16_t max_acceleration = 1;
#define MAX_VELOCITY 1
int32_t max_velocity = MAX_VELOCITY;
static int32_t motor_pwm_voltage = 0;
static uint64_t movement_end_time = 0;
static int32_t desired_velocity = 0;
static int32_t velocity = 0;
static uint32_t debug_counter = 0;
static uint16_t time_difference = 0;
static uint16_t time_difference_mod = 0;


// for the following calibration movement calculations, the time unit is one motor calculation cycle. at the time of this
// writing, this is roughly 25 microseconds. it may be noted elsewhere what this is more accurately.

// this is the velocity used during coast phases of the calibration.
// CALIBRATION_MAX_VELOCITY is in units of motor microsteps per time unit.
// for example, 64 means that the motor will take 64 microsteps per time unit.
#define CALIBRATION_MAX_VELOCITY CALIBRATION_CAPTURE_STEP_SIZE

#define CALIBRATION_VELOCITY_SHIFT 7 // this is how many binary decimal places we are keeping for the calibration velocity value

#define CALIBRATION_ACCELERATION 1 // this is the acceleration used during calibration. the units are microsteps divided by
                                   // (1 << CALIBRATION_VELOCITY_SHIFT) per one unit of time squared.

// this is the time to accelerate or decelerate during calibration. careful that this number ends up being an integer.
#define CALIBRATION_ACCELERATION_TIME ((CALIBRATION_MAX_VELOCITY << CALIBRATION_VELOCITY_SHIFT) / CALIBRATION_ACCELERATION)

// this is the distance delta during one acceleration or deceleration move in the unit of microsteps
#define CALIBRATION_ACCELERATION_DISTANCE ((((((uint32_t)CALIBRATION_ACCELERATION_TIME * (uint32_t)(CALIBRATION_ACCELERATION_TIME + 1)) >> 1) * CALIBRATION_ACCELERATION) >> CALIBRATION_VELOCITY_SHIFT))

// this is the time to coast at constant velocity such that the distance covered is CALIBRATION_ACCELERATION_DISTANCE
#define CALIBRATION_SMALL_COAST_TIME ((uint16_t)((uint32_t)CALIBRATION_ACCELERATION_DISTANCE / CALIBRATION_MAX_VELOCITY))

// this is the movement distance to cover exactly one rotation of the hall sensor magnetic disc in the unit of microsteps
#define CALIBRATION_MOVEMENT_DISTANCE ((int32_t)N_COMMUTATION_STEPS * (int32_t)N_COMMUTATION_SUB_STEPS * (int32_t)ONE_REVOLUTION_STEPS)

// this is the time to coast at constant velocity while capturing hall sensor readings. this should be exactly such that after one
// coast phase, the motor will rotate through one hall sensor revolution (ie. moves CALIBRATION_MOVEMENT_DISTANCE).
#define CALIBRATION_COAST_TIME (CALIBRATION_MOVEMENT_DISTANCE / CALIBRATION_MAX_VELOCITY)


// this is the peak velocity reached during the movements related to going into closed loop mode.
// it is in units of motor microsteps per time unit.
// for example, 64 means that the motor will take 64 microsteps per time unit.
#define GO_TO_CLOSED_LOOP_MODE_MAX_VELOCITY 64

#define GO_TO_CLOSED_LOOP_MODE_VELOCITY_SHIFT 7 // this is how many binary decimal places we are keeping for the velocity value

#define GO_TO_CLOSED_LOOP_MODE_ACCELERATION 1 // this is the acceleration used during the processof going into closed loop mode. the units are microsteps divided by
                                              // (1 << CALIBRATION_VELOCITY_SHIFT) per one unit of time squared.

// this is the time to accelerate or decelerate during calibration. careful that this number ends up being an integer.
#define GO_TO_CLOSED_LOOP_MODE_ACCELERATION_TIME ((GO_TO_CLOSED_LOOP_MODE_MAX_VELOCITY << GO_TO_CLOSED_LOOP_MODE_VELOCITY_SHIFT) / GO_TO_CLOSED_LOOP_MODE_ACCELERATION)


// This is the number of microsteps to turn the motor through one quarter of one commutation cycle (not one revolution)
#define HALL_TO_POSITION_90_DEGREE_OFFSET ((N_COMMUTATION_STEPS * N_COMMUTATION_SUB_STEPS) >> 2)

#define CAPTURE_HALL_SENSOR_READINGS 1
#define CAPTURE_HALL_POSITION 2
#define CAPTURE_ADJUSTED_HALL_SENSOR_READINGS 3


#define HOMING_MAX_VELOCITY 32

#define HOMING_VELOCITY_SHIFT 8 // this is how many binary decimal places we are keeping for the homing velocity value

#define HOMING_ACCELERATION 1 // this is the acceleration used during calibration. the units are microsteps divided by
                                   // (1 << HOMING_VELOCITY_SHIFT) per one unit of time squared.

// this is the time to accelerate or decelerate during calibration. careful that this number ends up being an integer.
#define HOMING_ACCELERATION_TIME ((HOMING_MAX_VELOCITY << HOMING_VELOCITY_SHIFT) / HOMING_ACCELERATION)

// this is the distance delta during one acceleration or deceleration move in the unit of microsteps
#define HOMING_ACCELERATION_DISTANCE ((((((uint32_t)HOMING_ACCELERATION_TIME * (uint32_t)(HOMING_ACCELERATION_TIME + 1)) >> 1) * HOMING_ACCELERATION) >> HOMING_VELOCITY_SHIFT))

// this is the time to coast at constant velocity such that the distance covered is HOMING_ACCELERATION_DISTANCE
#define HOMING_SMALL_COAST_TIME ((uint16_t)((uint32_t)HOMING_ACCELERATION_DISTANCE / HOMING_MAX_VELOCITY))

#define HOMING_MAX_REVOLUTIONS 300

// this is the movement distance to cover exactly one rotation of the hall sensor magnetic disc in the unit of microsteps
#define HOMING_MOVEMENT_DISTANCE (N_COMMUTATION_STEPS * N_COMMUTATION_SUB_STEPS * ONE_REVOLUTION_STEPS * HOMING_MAX_REVOLUTIONS)

// this is the time to coast at constant velocity while capturing hall sensor readings. this should be exactly such that after one
// coast phase, the motor will rotate through one hall sensor revolution (ie. moves HOMING_MOVEMENT_DISTANCE).
#define HOMING_COAST_TIME (HOMING_MOVEMENT_DISTANCE / HOMING_MAX_VELOCITY)


/*
 * Example:
 *    CALIBRATION_MAX_VELOCITY 64
 *    CALIBRATION_VELOCITY_SHIFT 8
 *    CALIBRATION_ACCELERATION 1
 *    CALIBRATION_ACCELERATION_TIME 16384
 *    CALIBRATION_ACCELERATION_DISTANCE 524320
 *    CALIBRATION_SMALL_COAST_TIME 8192.5 rounded down to 8192
 *    CALIBRATION_COAST_TIME 10080
 *    CALIBRATION_MOVEMENT_DISTANCE 645120
 */


struct calibration_struct {
    uint8_t move_number;
    uint16_t time;
    int16_t velocity;
    int16_t acceleration;
    uint8_t capturing_data;
    uint8_t verbose_data;
    uint8_t avg_counter;
    uint32_t hall1_sum;
    uint32_t hall2_sum;
    uint32_t hall3_sum;
};
struct calibration_struct calibration = {0};

struct go_to_closed_loop_mode_struct {
    uint8_t move_number;
    uint16_t time;
    int16_t velocity;
    int16_t acceleration;
};
struct go_to_closed_loop_mode_struct go_to_closed_loop_mode = {0};

struct capture_struct {
    uint8_t capture_type;
    uint8_t avg_counter;
    uint16_t hall1_sum;
    uint16_t hall2_sum;
    uint16_t hall3_sum;
};
struct capture_struct capture = {0};


struct homing_struct {
    uint8_t move_number;
    int8_t direction;
    uint32_t time;
    int16_t velocity;
    int16_t acceleration;
    int32_t start_position;
    int32_t start_six_step_hall_position;
};
struct homing_struct homing = {0};


struct closed_loop_struct {
    uint8_t move_number;
    uint32_t time;
    int16_t velocity;
    int16_t acceleration;
    uint8_t capturing_data;
    uint8_t avg_counter;
    uint32_t hall1_sum;
    uint32_t hall2_sum;
    uint32_t hall3_sum;
    uint16_t max_hall_reading;
    int32_t max_hall_position;
    int32_t max_hall_distance;
};
struct closed_loop_struct closed_loop = {0};


uint8_t PI_controller(int32_t error)
{
    int32_t output_value;
    int32_t proportional_term;
    static int32_t integral_term = 64 << 16;
#define PROPORTIONAL_CONSTANT 40
#define INTEGRAL_CONSTANT 1

    if(error < -32768) {
        error = -32768;
    }
    else if(error > 32767) {
        error = 32767;
    }
    integral_term += (error * INTEGRAL_CONSTANT);
    proportional_term = error * PROPORTIONAL_CONSTANT;
    output_value = (integral_term + proportional_term) >> 16;
    if(output_value < MIN_HSI_TRIM_VALUE) {
        output_value = MIN_HSI_TRIM_VALUE;
    }
    else if(output_value > MAX_HSI_TRIM_VALUE) {
        output_value = MAX_HSI_TRIM_VALUE;
    }

    return (uint8_t)output_value;
}

#define PID_SHIFT_RIGHT 18
int32_t PID_controller(int32_t error)
{
    int32_t output_value;
    int32_t proportional_term;
    static int32_t integral_term = 0;
    int32_t derivative_term;
    static int32_t previous_error = 0;
    int32_t error_change;
    static int32_t low_pass_filtered_error_change = 0;
#define PROPORTIONAL_CONSTANT_PID 25000
#define INTEGRAL_CONSTANT_PID 30
//#define DERIVATIVE_CONSTANT_PID 0
#define DERIVATIVE_CONSTANT_PID 250000
//#define DERIVATIVE_CONSTANT_PID 1280000

    if(error < -10000) {
        error = -10000;
    }
    else if(error > 10000) {
        error = 10000;
    }
    integral_term += (error * INTEGRAL_CONSTANT_PID);
    if(integral_term > (CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT)) {
    	integral_term = CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT;
    }
    else if(integral_term < -(CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT)) {
    	integral_term = -(CLOSED_LOOP_PWM_VOLTAGE << PID_SHIFT_RIGHT);
    }
    proportional_term = error * PROPORTIONAL_CONSTANT_PID;
    error_change = error - previous_error;
    low_pass_filtered_error_change = (low_pass_filtered_error_change * 31);
    low_pass_filtered_error_change += error_change;
    low_pass_filtered_error_change >>= 5;
    derivative_term = low_pass_filtered_error_change * DERIVATIVE_CONSTANT_PID;
    previous_error = error;
    output_value = (integral_term + proportional_term + derivative_term) >> PID_SHIFT_RIGHT;
    if(output_value < -CLOSED_LOOP_PWM_VOLTAGE) {
        output_value = -CLOSED_LOOP_PWM_VOLTAGE;
    }
    else if(output_value > CLOSED_LOOP_PWM_VOLTAGE) {
        output_value = CLOSED_LOOP_PWM_VOLTAGE;
    }

    return output_value;
}

void print_position(void)
{
	char buf[100];
	sprintf(buf, "hall_position: %d   desired_position: %d\n", (int)hall_position, (int)desired_position);
	transmit(buf, strlen(buf));
}

void print_queue_stats(void)
{
	char buf[100];
	sprintf(buf, "n_items_in_queue: %u\n", (unsigned int)n_items_in_queue);
	transmit(buf, strlen(buf));
}

void print_current_movement(void)
{
	char buf[150];
	uint64_t current_time = get_microsecond_time();
	sprintf(buf, "current_time: %lu   movement_start_time: %lu   movement_end_time: %lu\n",
			(unsigned long int)current_time, (unsigned long int)movement_start_time, (unsigned long int)movement_end_time);
	transmit(buf, strlen(buf));
	sprintf(buf, "movement_start_position: %d   movement_end_position: %d   motor_control_mode: %u\n",
			(int)movement_start_position, (int)movement_end_position, (unsigned int)motor_control_mode);
	transmit(buf, strlen(buf));
	sprintf(buf, "debug_counter: %u\n", (unsigned int)debug_counter);
	transmit(buf, strlen(buf));
}


void print_velocity(void)
{
	char buf[150];
	sprintf(buf, "desired velocity: %ld   actual velocity: %ld\n", desired_velocity, velocity);
	transmit(buf, strlen(buf));
}


void print_time_difference(void)
{
	char buf[150];
	sprintf(buf, "time_difference: %u   time_difference_mod: %hu\n", (unsigned int)time_difference, time_difference_mod);
	transmit(buf, strlen(buf));
}


void print_motor_current(void)
{
	char buf[100];
	uint16_t current = ADC_buffer[0]; // + ADC_buffer[2] + ADC_buffer[4] + ADC_buffer[6];
	sprintf(buf, "%hu\n", current);
	transmit(buf, strlen(buf));
}


void add_to_queue(int32_t position, uint64_t time)
{
    if(n_items_in_queue < MOVEMENT_QUEUE_SIZE) {
        movement_queue[queue_write_position].movement_end_position = position;
        movement_queue[queue_write_position].movement_end_time = time;
        queue_write_position = (queue_write_position + 1) & (MOVEMENT_QUEUE_SIZE - 1);
        n_items_in_queue++;
    }
}

uint8_t take_from_queue(int32_t *end_position, uint64_t *end_time)
{
    if(n_items_in_queue == 0) {
        return 0;
    }
    *end_position = movement_queue[queue_read_position].movement_end_position;
    *end_time = movement_queue[queue_read_position].movement_end_time;
    queue_read_position = (queue_read_position + 1) & (MOVEMENT_QUEUE_SIZE - 1);
    n_items_in_queue--;
    return 1;
}

void clear_the_queue(void)
{
    queue_read_position = 0;
    queue_write_position = 0;
    n_items_in_queue = 0;
    movement_end_time = 0;
}

void stop_movement(void)
{
    movement_end_time = 0;
    movement_end_position = desired_position;
}

void start_calibration(uint8_t verbose_data)
{
	char buf[200];
    clear_the_queue();
    stop_movement();
    if(verbose_data) {
    	rs485_transmit("Calibration start\n", 18);
    }
    memset(&calibration, 0, sizeof(calibration));
    calibration.verbose_data = verbose_data;
    enable_mosfets();
    calibration.move_number = 1;
    calibration.time = CALIBRATION_ACCELERATION_TIME;
    calibration.velocity = 0;
    calibration.acceleration = -CALIBRATION_ACCELERATION;
    motor_pwm_voltage = CALIBRATION_MOTOR_PWM_VOLTAGE;
    if(verbose_data) {
    	sprintf(buf, "Cal start pos: %d   time: %hu   vel: %hd   accel: %hd\n", (int)desired_position, calibration.time, calibration.velocity, calibration.acceleration);
    	transmit(buf, strlen(buf));
    }
}


void handle_calibration_logic(void)
{
    uint16_t hall_data_buffer[3];
	char buf[200];
	volatile uint32_t i;

	calibration.hall1_sum += ADC_buffer[1] + ADC_buffer[1 + 8] + ADC_buffer[1 + 16] + ADC_buffer[1 + 24];
	calibration.hall2_sum += ADC_buffer[3] + ADC_buffer[3 + 8] + ADC_buffer[3 + 16] + ADC_buffer[3 + 24];
	calibration.hall3_sum += ADC_buffer[5] + ADC_buffer[5 + 8] + ADC_buffer[5 + 16] + ADC_buffer[5 + 24];
	calibration.avg_counter++;
	if(calibration.avg_counter == HALL_SAMPLES_PER_PRINT) {
		if(calibration.capturing_data) {
			hall_data_buffer[0] = calibration.hall1_sum - HALL_SENSOR_SHIFT;
			hall_data_buffer[1] = calibration.hall2_sum - HALL_SENSOR_SHIFT;
			hall_data_buffer[2] = calibration.hall3_sum - HALL_SENSOR_SHIFT;
		}
		else {
			hall_data_buffer[0] = 0;
			hall_data_buffer[1] = 0;
			hall_data_buffer[2] = 0;
		}
	    if(calibration.verbose_data) {
	    	rs485_transmit((void*)hall_data_buffer, 6);
	    }
	    else {
	    	for(i = 0; i < 1000; i++); // a delay to make up that we aren't transmitting anything
	    }
		calibration.avg_counter = 0;
		calibration.hall1_sum = 0;
		calibration.hall2_sum = 0;
		calibration.hall3_sum = 0;
	}

/*
#define CALIBRATION_MAX_VELOCITY 64
#define CALIBRATION_VELOCITY_SHIFT 8
#define CALIBRATION_ACCELERATION 1
#define CALIBRATION_ACCELERATION_TIME = ((CALIBRATION_VELOCITY << CALIBRATION_VELOCITY_SHIFT) / CALIBRATION_ACCELERATION)
#define CALIBRATION_ACCELERATION_DISTANCE = ((CALIBRATION_ACCELERATION_TIME * (CALIBRATION_ACCELERATION_TIME + 1)) >> 1)
#define CALIBRATION_SMALL_COAST_TIME (CALIBRATION_ACCELERATION_DISTANCE / CALIBRATION_MAX_VELOCITY)
*/

/*
| Move Number | Position Before Move                | Velocity at Beginning of Move | Acceleration                   | Movement Time                     | Velocity at End of Move   | Position Delta                     | Position After Move                  |
==================================================================================================================================================================================================================================================================
| 1           | 0                                   | 0                             | -CALIBRATION_ACCELERATION      | CALIBRATION_ACCELERATION_TIME     | -CALIBRATION_MAX_VELOCITY | -CALIBRATION_ACCELERATION_DISTANCE | -CALIBRATION_ACCELERATION_DISTANCE   |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 2           | -CALIBRATION_ACCELERATION_DISTANCE  | -CALIBRATION_MAX_VELOCITY     | 0                              | CALIBRATION_COAST_TIME / 2        | -CALIBRATION_MAX_VELOCITY | -CALIBRATION_MOVEMENT_DISTANCE / 2 | -CALIBRATION_ACCELERATION_DISTANCE   |
|             |                                     |                               |                                |                                   |                           |                                    | -CALIBRATION_MOVEMENT_DISTANCE / 2   |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 3           | -CALIBRATION_ACCELERATION_DISTANCE  | -CALIBRATION_MAX_VELOCITY     | +CALIBRATION_ACCELERATION      | CALIBRATION_ACCELERATION_TIME * 2 | CALIBRATION_MAX_VELOCITY  | 0                                  | -CALIBRATION_ACCELERATION_DISTANCE   |
|             | -CALIBRATION_MOVEMENT_DISTANCE / 2  |                               |                                |                                   |                           |                                    | -CALIBRATION_MOVEMENT_DISTANCE / 2   |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 4           | -CALIBRATION_ACCELERATION_DISTANCE  | CALIBRATION_MAX_VELOCITY      | 0                              | CALIBRATION_SMALL_COAST_TIME      | CALIBRATION_MAX_VELOCITY  | CALIBRATION_ACCELERATION_DISTANCE  | -CALIBRATION_MOVEMENT_DISTANCE / 2   |
|             | -CALIBRATION_MOVEMENT_DISTANCE / 2  |                               |                                |                                   |                           |                                    |                                      |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 5           | -CALIBRATION_MOVEMENT_DISTANCE / 2  | CALIBRATION_MAX_VELOCITY      | 0                              | CALIBRATION_COAST_TIME            | CALIBRATION_MAX_VELOCITY  | CALIBRATION_MOVEMENT_DISTANCE      | CALIBRATION_MOVEMENT_DISTANCE / 2    |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 6           | CALIBRATION_MOVEMENT_DISTANCE / 2   | CALIBRATION_MAX_VELOCITY      | 0                              | CALIBRATION_SMALL_COAST_TIME      | CALIBRATION_MAX_VELOCITY  | CALIBRATION_ACCELERATION_DISTANCE  | CALIBRATION_MOVEMENT_DISTANCE / 2    |
|             |                                     |                               |                                |                                   |                           |                                    | +CALIBRATION_ACCELERATION_DISTANCE   |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 7           | CALIBRATION_MOVEMENT_DISTANCE / 2   | CALIBRATION_MAX_VELOCITY      | -CALIBRATION_ACCELERATION      | CALIBRATION_ACCELERATION_TIME * 2 | -CALIBRATION_MAX_VELOCITY | 0                                  | CALIBRATION_MOVEMENT_DISTANCE / 2    |
|             | +CALIBRATION_ACCELERATION_DISTANCE  |                               |                                |                                   |                           |                                    | +CALIBRATION_ACCELERATION_DISTANCE   |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 8           | CALIBRATION_MOVEMENT_DISTANCE / 2   | -CALIBRATION_MAX_VELOCITY     | 0                              | calibration_max_hall_position /   | -CALIBRATION_MAX_VELOCITY | -calibration_max_hall_position     | CALIBRATION_MOVEMENT_DISTANCE / 2    |
|             | +CALIBRATION_ACCELERATION_DISTANCE  |                               |                                | CALIBRATION_MAX_VELOCITY          |                           |                                    | +CALIBRATION_ACCELERATION_DISTANCE   |
|             |                                     |                               |                                |                                   |                           |                                    | -calibration_max_hall_position       |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 9           | CALIBRATION_MOVEMENT_DISTANCE / 2   | -CALIBRATION_MAX_VELOCITY     | +CALIBRATION_ACCELERATION      | CALIBRATION_ACCELERATION_TIME     | 0                         | -CALIBRATION_ACCELERATION_DISTANCE | CALIBRATION_MOVEMENT_DISTANCE / 2    |
|             | +CALIBRATION_ACCELERATION_DISTANCE  |                               |                                |                                   |                           |                                    | -calibration_max_hall_position       |
|             | -calibration_max_hall_position      |                               |                                |                                   |                           |                                    |                                      |
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------> Position
|
|Move Number                                                                                                 START        MAX HALL SENSOR MAX POSITION
| 1                                                                              <    <    <   <   <  <  < < <<|                      M
| 2                                 <    <    <    <    <    <    <    <    <    <
| 3   |<< < <  <  <   <   <    <    <
|     |>> > >  >  >   >   >    >    >
| 4                                 >    >    >    >    >    >    >
| 5                                                               >....>....>....>....>....>....>....>....>....>....>....>....>....>..m.>....>....>....>...>
| 6                                                                                                                                                        >....>....>....>....>....>....>
| 7                                                                                                                                                                                      >    >    >   >   >  >  > > >>|
|                                                                                                                                                                                        <    <    <   <   <  <  < < <<|
| 8                                                                                                                                                                  <    <    <    <    <
| 9                                                                                                                                   |<<< < <  <  <   <   <    <    <
\/
TIME
DOWNWARD

                                     <------------------------------------------> <--------------------------->
                                           CALIBRATION_MOVEMENT_DISTANCE / 2    CALIBRATION_ACCELERATION_DISTANCE
	   <---------------------------> <---------------------------> <--------------------------------------------------------------------------------------> <---------------------------> <--------------------------->
	                               CALIBRATION_ACCELERATION_DISTANCE                               CALIBRATION_MOVEMENT_DISTANCE                          CALIBRATION_ACCELERATION_DISTANCE
     CALIBRATION_ACCELERATION_DISTANCE                                                                                                                                                  CALIBRATION_ACCELERATION_DISTANCE
                                                                                                                                       <------------------->
                                                                                                                                  calibration.max_hall_distance
                                                                                                                                                                     <------------------->
                                                                                                                                                                  calibration.max_hall_distance
                                                                                                                                       <--------------------------->
                                                                                                                                     CALIBRATION_ACCELERATION_DISTANCE

|         Stopped (possibly briefly)
>         Movement tot he right
<         Movement to the left
>> > >  > Accelerating, moving right
<  < < << Accelerating, moving left
<< < <  < Decelerating, moving left
>  > > >> Decelerating, moving right
>   >   > Constant velocity coasting
....      Recording the hall sensor readings needed for position calibration
M         position of the maximum hall sensor reading
m         position of the maximum hall sensor reading found here
<------>  Distance covered by various movements (as labeled)

*/
    if(calibration.time == 0) {
        calibration.move_number++;
        switch(calibration.move_number) {
        case 2:
            calibration.time = CALIBRATION_COAST_TIME >> 1;
            calibration.acceleration = 0;
            break;
        case 3:
            calibration.time = CALIBRATION_ACCELERATION_TIME * 2;
            calibration.acceleration = CALIBRATION_ACCELERATION;
            break;
        case 4:
            calibration.time = CALIBRATION_SMALL_COAST_TIME;
            calibration.acceleration = 0;
            break;
        case 5:
            calibration.capturing_data = 1;
            calibration.time = CALIBRATION_COAST_TIME;
            calibration.acceleration = 0;
            break;
        case 6:
            calibration.time = CALIBRATION_SMALL_COAST_TIME;
            calibration.acceleration = 0;
//            sprintf(buf, "actual_position: %d   calibration.max_hall_position: %d\n", (int)actual_position, (int)calibration.max_hall_position);
//            transmit(buf, strlen(buf));
            break;
        case 7:
            calibration.capturing_data = 0;
            if(calibration.verbose_data) {
            	rs485_transmit("Calibration capture done\n", 25);
            }
            calibration.time = CALIBRATION_ACCELERATION_TIME * 2;
            calibration.acceleration = -CALIBRATION_ACCELERATION;
            break;
        case 8:
            calibration.time = CALIBRATION_MOVEMENT_DISTANCE / CALIBRATION_MAX_VELOCITY;
            sprintf(buf, "FIX THIS moving for this amount of distance: %d\n", (int)CALIBRATION_MOVEMENT_DISTANCE);
            transmit(buf, strlen(buf));
            calibration.acceleration = 0;
            break;
        case 9:
            calibration.time = CALIBRATION_ACCELERATION_TIME;
            calibration.acceleration = CALIBRATION_ACCELERATION;
            break;
        case 10:
			calibration.time = CALIBRATION_ACCELERATION_TIME >> 1; // this can be changed to any small value. the purpose is to allow the motor to settle after stopping moving
			calibration.acceleration = 0;
			calibration.velocity = 0;
			stop_movement();
		    if(calibration.verbose_data) {
		    	rs485_transmit("Calibration done\n", 17);
		    }
			break;
        default:
//    		zero_hall_position();
//    		int32_t hall_position = get_hall_position();
//    		sprintf(buf, "desired_position: %d   hall_position: %d\n", (int)desired_position, (int)(hall_position));
//    		transmit(buf, strlen(buf));
    		motor_pwm_voltage = 0;
    		movement_end_position = desired_position;
//    		motor_control_mode = CLOSED_LOOP_POSITION_CONTROL;
            calibration.move_number = 0; // this signals that calibration is no longer in progress
            break;
        }
        sprintf(buf, "%u: pos: %d   time: %hu   vel: %hd   accel: %hd\n", (unsigned int)calibration.move_number, (int)desired_position, calibration.time, calibration.velocity, calibration.acceleration);
        transmit(buf, strlen(buf));
    }

    calibration.velocity += calibration.acceleration;
    desired_position += (((int32_t)calibration.velocity + (1 << (CALIBRATION_VELOCITY_SHIFT - 1))) >> CALIBRATION_VELOCITY_SHIFT); // implements rounding for better accuracy
    calibration.time--;
}


void start_go_to_closed_loop_mode(void)
{
	clear_the_queue();
	stop_movement();
	set_motor_control_mode(OPEN_LOOP_POSITION_CONTROL);
	enable_mosfets();
	transmit("Go to closed loop mode start\n", 29);
	memset(&go_to_closed_loop_mode, 0, sizeof(go_to_closed_loop_mode));
	go_to_closed_loop_mode.move_number = 1;
	go_to_closed_loop_mode.time = GO_TO_CLOSED_LOOP_MODE_ACCELERATION_TIME;
	go_to_closed_loop_mode.velocity = 0;
	go_to_closed_loop_mode.acceleration = -GO_TO_CLOSED_LOOP_MODE_ACCELERATION;
	motor_pwm_voltage = GO_TO_CLOSED_LOOP_MODE_MOTOR_PWM_VOLTAGE;
}


void go_to_closed_loop_mode_logic(void)
{
	char buf[200];

    if(go_to_closed_loop_mode.time == 0) {
    	go_to_closed_loop_mode.move_number++;
        switch(go_to_closed_loop_mode.move_number) {
        case 2:
        	go_to_closed_loop_mode.time = GO_TO_CLOSED_LOOP_MODE_ACCELERATION_TIME * 2;
        	go_to_closed_loop_mode.acceleration = GO_TO_CLOSED_LOOP_MODE_ACCELERATION;
            break;
        case 3:
        	go_to_closed_loop_mode.time = GO_TO_CLOSED_LOOP_MODE_ACCELERATION_TIME;
        	go_to_closed_loop_mode.acceleration = -GO_TO_CLOSED_LOOP_MODE_ACCELERATION;
            break;
        case 4:
        	go_to_closed_loop_mode.time = GO_TO_CLOSED_LOOP_MODE_ACCELERATION_TIME; // let some time for the motor to settle the position
        	go_to_closed_loop_mode.acceleration = 0;
            break;
        default:
        	commutation_position_offset = commutation_position_offset - desired_position;
        	zero_hall_position();
        	desired_position = 0;
        	movement_end_position = 0;
        	movement_end_time = 0;
       		motor_pwm_voltage = 0;
			set_motor_control_mode(CLOSED_LOOP_POSITION_CONTROL);
        	hall_position = get_hall_position();
    		sprintf(buf, "desired_position: %d   hall_position: %d\n", (int)desired_position, (int)(hall_position));
    		transmit(buf, strlen(buf));
    		go_to_closed_loop_mode.move_number = 0; // finished all the steps
            break;
        }
        sprintf(buf, "%hhu: pos: %ld   time: %u   vel: %d   accel: %d\n", go_to_closed_loop_mode.move_number, desired_position, go_to_closed_loop_mode.time, go_to_closed_loop_mode.velocity, go_to_closed_loop_mode.acceleration);
        transmit(buf, strlen(buf));
    }

    go_to_closed_loop_mode.velocity += go_to_closed_loop_mode.acceleration;
    desired_position += (((int32_t)go_to_closed_loop_mode.velocity + (1 << (GO_TO_CLOSED_LOOP_MODE_VELOCITY_SHIFT - 1))) >> GO_TO_CLOSED_LOOP_MODE_VELOCITY_SHIFT); // implements rounding for better accuracy
    go_to_closed_loop_mode.time--;
}


void start_capture(uint8_t capture_type)
{
    transmit("Capture start\n", 14);
    memset(&capture, 0, sizeof(capture));
    capture.capture_type = capture_type;
}

void capture_logic(void)
{
    uint16_t hall_data_buffer[6];
    int32_t adjusted_hall_sensor_readings[3];
    static uint16_t counter = 0;

    if(capture.capture_type == CAPTURE_HALL_SENSOR_READINGS) {
    	if(counter == 0) {
    		counter = 256;

    		hall_data_buffer[0] = ((ADC_buffer[1] + ADC_buffer[1 + 8] + ADC_buffer[1 + 16] + ADC_buffer[1 + 24]) << 3) - HALL_SENSOR_SHIFT;
    		hall_data_buffer[1] = ((ADC_buffer[3] + ADC_buffer[3 + 8] + ADC_buffer[3 + 16] + ADC_buffer[3 + 24]) << 3) - HALL_SENSOR_SHIFT;
    		hall_data_buffer[2] = ((ADC_buffer[5] + ADC_buffer[5 + 8] + ADC_buffer[5 + 16] + ADC_buffer[5 + 24]) << 3) - HALL_SENSOR_SHIFT;
			hall_data_buffer[3] = 65535;
			rs485_transmit((char*)hall_data_buffer, 8);
    	}
    	counter--;
    }
    else if(capture.capture_type == CAPTURE_HALL_POSITION) {
    	if(counter == 0) {
    		counter = 256;
    		int32_t hall_position = get_hall_position();
    		memcpy(hall_data_buffer + 3, &hall_position, sizeof(hall_position));
			rs485_transmit((char*)hall_data_buffer, 12);
    	}
    	counter--;
    }
    else if(capture.capture_type == CAPTURE_ADJUSTED_HALL_SENSOR_READINGS) {
    	if(counter == 0) {
    		counter = 256;
    		int32_t hall_position = get_hall_position();
			adjust_hall_sensor_readings(hall_data_buffer, adjusted_hall_sensor_readings);
			hall_data_buffer[0] = (adjusted_hall_sensor_readings[0] >> 16) + 32768;
			hall_data_buffer[1] = (adjusted_hall_sensor_readings[1] >> 16) + 32768;
			hall_data_buffer[2] = (adjusted_hall_sensor_readings[2] >> 16) + 32768;
    		memcpy(hall_data_buffer + 3, &hall_position, sizeof(hall_position));
			hall_data_buffer[5] = 65535; // magic number to indicate the end of the data
			rs485_transmit((char*)hall_data_buffer, 12);
    	}
    	counter--;
    }
}

/*
void start_homing(int32_t max_homing_displacement)
{
	char buf[200];
	motor_control_mode = OPEN_LOOP_POSITION_CONTROL;
    clear_the_queue();
    stop_movement();
    transmit("Homing start\n", 13);
    memset(&homing, 0, sizeof(homing));
    enable_mosfets();
    reset_six_step_sequence();
	int32_t six_step_hall_position = get_six_step_hall_position();
    homing.move_number = 1;
	homing.time = HOMING_ACCELERATION_TIME;
    homing.velocity = 0;
    if(max_homing_displacement >= 0) {
    	homing.direction = 1;
        homing.acceleration = HOMING_ACCELERATION;
    }
    else {
    	homing.direction = -1;
        homing.acceleration = -HOMING_ACCELERATION;
    }
    homing.start_position = actual_position;
    homing.start_six_step_hall_position = six_step_hall_position;
    motor_pwm_voltage = HOMING_MOTOR_PWM_VOLTAGE;
    sprintf(buf, "Home start pos: %d   time: %u   vel: %hd   accel: %hd\n", (int)desired_position, (unsigned int)homing.time, homing.velocity, homing.acceleration);
    transmit(buf, strlen(buf));
}


void handle_homing_logic(void)
{
	int32_t six_step_hall_position = get_six_step_hall_position();
    static int32_t previous_six_step_hall_position = 0;
    char buf[200];
    int32_t delta_position;
    int32_t delta_six_step_hall_position;

	if(six_step_hall_position != previous_six_step_hall_position) {
//		sprintf(buf, "delta_position: %d   delta_six_step_hall_position: %d   min_expected_delta_position: %d\n  min_expected",
//			    (int)delta_position, (int)delta_six_step_hall_position, (int)min_expected_delta_position);
//		transmit(buf, strlen(buf));
		previous_six_step_hall_position = six_step_hall_position;


	}

	if(homing.direction == 1) {
		delta_position = actual_position - homing.start_position;
		delta_six_step_hall_position = six_step_hall_position - homing.start_six_step_hall_position;
	}
	else {
		delta_position = homing.start_position - actual_position;
		delta_six_step_hall_position = homing.start_six_step_hall_position - six_step_hall_position;
	}
	int32_t position_error = delta_position - delta_six_step_hall_position * 21502;
	if(abs(position_error) > MAX_HOMING_ERROR) {
		homing.time = 0;
		homing.move_number = 4;
		transmit("Crash detected\n", 15);
	}

    if(homing.time == 0) {
        homing.move_number++;
        switch(homing.move_number) {
        case 2:
            homing.time = HOMING_COAST_TIME;
            homing.acceleration = 0;
            break;
        case 3:
            homing.time = HOMING_ACCELERATION_TIME;
            homing.acceleration = HOMING_ACCELERATION;
            break;
        default:
			stop_movement();
			homing.time = 0;
			homing.acceleration = 0;
			homing.velocity = 0;
            homing.move_number = 0; // this signals that homing is no longer in progress
            break;
        }
        sprintf(buf, "%u: pos: %d   time: %u   vel: %hd   accel: %hd\n", (unsigned int)homing.move_number, (int)desired_position, (unsigned int)homing.time, homing.velocity, homing.acceleration);
        transmit(buf, strlen(buf));
    }

    homing.velocity += homing.acceleration;
    actual_position += (((int32_t)homing.velocity + (1 << (HOMING_VELOCITY_SHIFT - 1))) >> HOMING_VELOCITY_SHIFT); // implements rounding for better accuracy
    homing.time--;
}
*/

void compute_velocity(void)
{
	static int32_t previous_hall_position = 0;
	static uint16_t previous_time = 0;
	uint16_t current_time;
	int32_t delta_position;
	uint16_t delta_time;
	static uint16_t count = 0;

	count++;
	if(count == 50) {
		count = 0;

		current_time = TIM3->CNT;

		delta_position = hall_position - previous_hall_position;
		delta_time = current_time - previous_time;
		delta_position *= VELOCITY_SCALE_FACTOR;
		velocity = delta_position / delta_time;

		previous_hall_position = hall_position;
		previous_time = current_time;
	}
}

uint8_t handle_queued_movements(void)
{
	uint64_t current_time = get_microsecond_time();
	int32_t end_position;
	uint64_t end_time;
	uint8_t has_queued_item;

	if(current_time >= movement_end_time) {
		debug_counter++;
		has_queued_item = take_from_queue(&end_position, &end_time);

		if(has_queued_item) {
			movement_start_time = movement_end_time;
			movement_start_position = movement_end_position;
			movement_end_position = end_position;
			movement_end_time = end_time;
			desired_velocity = ((movement_end_position - movement_start_position) << 8) / (int32_t)(movement_end_time - movement_start_time);
		}
		else {
			desired_position = movement_end_position;
			movement_end_time = current_time;
			desired_velocity = 0;
		}
	}

	if(current_time < movement_end_time) {
		desired_position = (int64_t)(current_time - movement_start_time) * ((int64_t)movement_end_position - (int64_t)movement_start_position) /
						   (int32_t)(movement_end_time - movement_start_time) + movement_start_position;
		desired_velocity = ((movement_end_position - desired_position) * VELOCITY_SCALE_FACTOR) / (int32_t)(movement_end_time - current_time);
		return 1;
	}
	else {
		return 0;
	}
}


void motor_movement_calculations(void)
{
	uint8_t moving = 0; // 1 indicates that the motor is moving, 0 indicates that it is stopped

	hall_position = get_hall_position();

    if(calibration.move_number > 0) {
        handle_calibration_logic();
        moving = 1;
    }
    else if(go_to_closed_loop_mode.move_number > 0) {
        go_to_closed_loop_mode_logic();
        moving = 1;
    }
    else if(homing.move_number > 0) {
//        handle_homing_logic();
    	moving = 1;
    }
    else if(capture.capture_type) {
        capture_logic();
    }
    else {
    	moving = handle_queued_movements();
    }

	if(motor_control_mode == OPEN_LOOP_POSITION_CONTROL) {
		commutation_position = desired_position + commutation_position_offset;
		if(moving) {
			motor_pwm_voltage = OPEN_LOOP_DYNAMIC_MOTOR_PWM_VOLTAGE;
		}
		else {
			motor_pwm_voltage = OPEN_LOOP_STATIC_MOTOR_PWM_VOLTAGE;
		}
	}
	else {
		commutation_position = hall_position + commutation_position_offset;
		if(motor_control_mode == CLOSED_LOOP_POSITION_CONTROL) {
			motor_pwm_voltage = PID_controller(desired_position - hall_position);
			int32_t pwm_voltage_adjustment = desired_velocity;
			if(desired_velocity >= 0) {
				if(desired_velocity - velocity > 20) {
					pwm_voltage_adjustment = velocity;
				}
			}
			else {
				if(velocity - desired_velocity > 20) {
					pwm_voltage_adjustment = velocity;
				}
			}
			if(pwm_voltage_adjustment > MAX_PWM_VOLTAGE_ADJUSTMENT) {
				pwm_voltage_adjustment = MAX_PWM_VOLTAGE_ADJUSTMENT;

			}
			if(pwm_voltage_adjustment < -MAX_PWM_VOLTAGE_ADJUSTMENT) {
				pwm_voltage_adjustment = -MAX_PWM_VOLTAGE_ADJUSTMENT;
			}
			motor_pwm_voltage += pwm_voltage_adjustment;
		}
		if(motor_pwm_voltage >= 0) {
			commutation_position += HALL_TO_POSITION_90_DEGREE_OFFSET;
		}
		else {
			commutation_position -= HALL_TO_POSITION_90_DEGREE_OFFSET;
			motor_pwm_voltage = -motor_pwm_voltage;
		}
	}
}


void motor_phase_calculations(void)
{
    static uint16_t commutation_step = 0;
    static uint16_t commutation_sub_step = 0;
    static uint32_t phase1;
    static uint32_t phase2;
    static uint32_t phase3;
    static int32_t phase1_slope;
    static int32_t phase2_slope;
    static int32_t phase3_slope;
    static int32_t tmp32bit;
    static uint16_t start_time;
	static uint16_t end_time;
//    char buf[200];
//    volatile uint32_t delay;

//    sprintf(buf, "commutation_position: %u\n", (unsigned int)commutation_position);
//    transmit(buf, strlen(buf));

    start_time = TIM3->CNT;
    commutation_step = (commutation_position >> N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT) % N_COMMUTATION_STEPS;
    end_time = TIM3->CNT;
    time_difference_mod = end_time - start_time;
    commutation_sub_step = (commutation_position & 0xff) >> (8 - N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT);

//    sprintf(buf, "commutation_step: %u   commutation_sub_step: %u\n", (unsigned int)commutation_step, (unsigned int)commutation_sub_step);
//    transmit(buf, strlen(buf));

//    for(delay = 0; delay < 100000; delay++);

    phase1 = commutation_lookup_table[commutation_step].phase1;
    phase2 = commutation_lookup_table[commutation_step].phase2;
    phase3 = commutation_lookup_table[commutation_step].phase3;
    phase1_slope = commutation_lookup_table[commutation_step].phase1_slope;
    phase2_slope = commutation_lookup_table[commutation_step].phase2_slope;
    phase3_slope = commutation_lookup_table[commutation_step].phase3_slope;

    tmp32bit = phase1_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase1 = phase1 + tmp32bit;

    tmp32bit = phase2_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase2 = phase2 + tmp32bit;

    tmp32bit = phase3_slope;
    tmp32bit *= commutation_sub_step;
    tmp32bit >>= N_COMMUTATION_SUB_STEPS_SHIFT_RIGHT;
    phase3 = phase3 + tmp32bit;

//    sprintf(buf, "Ph: %u %u %u   Motor voltage: %u\n", (unsigned int)phase1, (unsigned int)phase2, (unsigned int)phase3, (unsigned int)motor_pwm_voltage);
//    transmit(buf, strlen(buf));

//    for(delay = 0; delay < 100000; delay++);

    phase1 >>= 8;
    phase1 *= (uint32_t)motor_pwm_voltage;
    phase1 >>= 16;
    phase1 += 13;
    TIM1->CCR1 = phase1;

    phase2 >>= 8;
    phase2 *= (uint32_t)motor_pwm_voltage;
    phase2 >>= 16;
    phase2 += 13;
    TIM1->CCR2 = phase2;

    phase3 >>= 8;
    phase3 *= (uint32_t)motor_pwm_voltage;
    phase3 >>= 16;
    phase3 += 13;
    TIM1->CCR3 = phase3;

//    sprintf(buf, "Ph: %u %u %u   Motor voltage: %u\n", (unsigned int)phase1, (unsigned int)phase2, (unsigned int)phase3, (unsigned int)motor_pwm_voltage);
//    transmit(buf, strlen(buf));
}

void increase_motor_pwm_voltage(void)
{
	char buf[100];
	motor_pwm_voltage++;
	sprintf(buf, "motor_pwm_voltage: %d\n", (int)motor_pwm_voltage);
	transmit(buf, strlen(buf));
}

void decrease_motor_pwm_voltage(void)
{
	char buf[100];
	motor_pwm_voltage--;
	sprintf(buf, "motor_pwm_voltage: %d\n", (int)motor_pwm_voltage);
	transmit(buf, strlen(buf));
}

uint8_t get_motor_control_mode(void) {
	return motor_control_mode;
}

void set_motor_control_mode(uint8_t new_motor_control_mode)
{
	motor_control_mode = new_motor_control_mode;
}

void move_n_steps_in_m_time(int32_t displacement, uint32_t time_delta)
{
	uint64_t local_time = get_microsecond_time();
	add_to_queue(desired_position - displacement, local_time + time_delta);
}

void zero_position_and_hall_sensor(void)
{
    clear_the_queue();
    stop_movement();
	commutation_position_offset = commutation_position_offset - desired_position;
    zero_hall_position();
	desired_position = 0;
	movement_end_position = 0;
	movement_end_time = 0;
}

void processCommand(uint8_t axis, uint8_t command, uint8_t *parameters)
{
    uint64_t local_time;
    uint64_t time_from_master = 0;
    int32_t end_position;
    uint32_t end_time;
    uint8_t capture_type;
	uint8_t buf[5];

//    print_number("Received a command with length: ", commandLen);
    if((axis == MY_AXIS) || (axis == ALL_AXIS)) {
//        print_number("Axis:", axis);
//        print_number("command:", command);
        switch(command) {
        case DISABLE_MOSFETS_COMMAND:
            disable_mosfets();
            if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            break;
        case ENABLE_MOSFETS_COMMAND:
            enable_mosfets();
            if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            break;
        case SET_POSITION_AND_MOVE_COMMAND:
            end_position = ((int32_t*)parameters)[0];
            local_time = get_microsecond_time();
            end_time = abs((int32_t)(end_position - desired_position)) / max_velocity + local_time;
            add_to_queue(end_position, end_time);
//            print_number("Set position: ", (uint16_t)desired_position);
            if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            break;
        case SET_VELOCITY_COMMAND:
            max_velocity = *(int32_t*)parameters;
            if(max_velocity > (int16_t)MAX_VELOCITY) {
                max_velocity = (int16_t)MAX_VELOCITY;
            }
            if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            break;
        case SET_POSITION_AND_FINISH_TIME_COMMAND:
            end_position = ((int32_t*)parameters)[0];
            end_time = ((int32_t*)parameters)[1];
            add_to_queue(end_position, end_time);
//            print_number("Set position: ", (uint16_t)desired_position);
            if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            break;
        case SET_ACCELERATION_COMMAND:
            max_acceleration = *(uint16_t*)parameters;
            if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            break;
        case START_CALIBRATION_COMMAND:
            enable_mosfets();
            start_calibration(1);
            break;
        case CAPTURE_HALL_SENSOR_DATA_COMMAND:
        	capture_type = parameters[0];
            if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            start_capture(capture_type);
            break;
        case RESET_TIME_COMMAND:
            clear_the_queue();
            stop_movement();
            movement_end_time = 0;
            reset_microsecond_time();
            if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            break;
        case GET_CURRENT_TIME_COMMAND:
            if(axis != ALL_AXIS) {
                local_time = get_microsecond_time();
                rs485_transmit("R\x01\x06", 3);
                rs485_transmit(&local_time, 6);
            }
            break;
        case TIME_SYNC_COMMAND:
        	memcpy(&time_from_master, parameters, 6);
            local_time = get_microsecond_time();
            int32_t time_error = (int32_t)(time_from_master - local_time);
            uint8_t new_clock_cal_value = PI_controller(time_error);
            RCC->ICSCR = new_clock_cal_value << RCC_ICSCR_HSITRIM_Pos;
            if(axis != ALL_AXIS) {
                rs485_transmit("R\x01\x06", 3);
                rs485_transmit(&time_error, 4);
                rs485_transmit((uint16_t*)(&RCC->ICSCR), 2);
            }
            break;
        case GET_N_ITEMS_IN_QUEUE_COMMAND:
            if(axis != ALL_AXIS) {
                rs485_transmit("R\x01\x01", 3);
                rs485_transmit(&n_items_in_queue, 1);
            }
            break;
        case EMERGENCY_STOP_COMMAND:
            disable_mosfets();
            clear_the_queue();
            if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            break;
        case ZERO_POSITION_COMMAND:
            zero_position_and_hall_sensor();
			if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            break;
        case HOMING_COMMAND:
            enable_mosfets();
//            int32_t max_homing_travel_displacement = ((int32_t*)parameters)[0];
            //start_homing(max_homing_travel_displacement);
            if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            break;
        case GET_POSITION_COMMAND:
            if(axis != ALL_AXIS) {
                rs485_transmit("R\x01\x04", 3);
            	if(motor_control_mode == CLOSED_LOOP_POSITION_CONTROL) {
            		rs485_transmit(&hall_position, sizeof(hall_position));
            	}
            	else {
            		rs485_transmit(&desired_position, sizeof(desired_position));
            	}
            }
            break;
        case GET_STATUS_COMMAND:
            if(axis != ALL_AXIS) {
            	buf[0] = motor_control_mode;
            	buf[1] = calibration.move_number;
            	buf[2] = homing.move_number;
            	buf[3] = capture.capture_type;
            	buf[4] = get_mosfets_enabled();
                rs485_transmit("R\x01\x05", 3);
        		rs485_transmit(buf, sizeof(buf));
            }
            break;
        case GO_TO_CLOSED_LOOP_COMMAND:
        	start_go_to_closed_loop_mode();
            if(axis != ALL_AXIS) {
                rs485_transmit(NO_ERROR_RESPONSE, 3);
            }
            break;
        }
    }
}

void motor_control(void)
{
	uint16_t start_time = TIM3->CNT;
	uint16_t end_time;
	compute_velocity();
    motor_movement_calculations();
    motor_phase_calculations();
    end_time = TIM3->CNT;
    time_difference = end_time - start_time;
}

