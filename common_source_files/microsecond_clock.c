#include "stm32g0xx_hal.h"
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "debug_uart.h"
#include "microsecond_clock.h"
#include "error_handling.h"

static uint64_t previous_64bit_time = 0;
static volatile uint32_t upper_32_bits = 0;

void microsecond_clock_init(void)
{
    RCC->APBENR2 |= RCC_APBENR2_TIM14EN; // enable the clock to TIM14
    TIM14->PSC = 64 - 1; // prescale it so that we get one count per microsecond. have to subtract 1 to be right
    TIM14->ARR = 0xFFFFFFFF;
    TIM14->DIER = TIM_DIER_UIE; // enable the interrupt for the update event (overflow)
    TIM14->CR1 = TIM_CR1_CEN | TIM_CR1_UIFREMAP; // enable the timer and remap the rollover bit to bit 31 of the counter
    TIM14->EGR |= TIM_EGR_UG; // do an update (load and clear the prescaler)
    NVIC_SetPriority(TIM14_IRQn, 2); // third highest priority. we can accept that this is handled at a lower priority than the motor control interrupt
    NVIC_EnableIRQ(TIM14_IRQn); // enable the interrupt to this timer
}



void TIM14_IRQHandler(void)
{
    __disable_irq();
    uint32_t tim_count = TIM14->CNT;
    if(tim_count & (1 << 31)) {
        upper_32_bits++;
    }
    TIM14->SR = 0; // set all interrupt flags for the timer to zero
    __enable_irq();
}


uint64_t get_microsecond_time(void)
{
    volatile union {
        volatile uint64_t sixty_four_bit_time;
        volatile struct __attribute__((__packed__)) {
            volatile uint16_t lower_16_bits;
            volatile uint32_t upper_32_bits;
        } fourty_eight_bit_time;
    } returned_time;
    uint32_t tim_count;


    __disable_irq();

    ((uint32_t*)&returned_time.sixty_four_bit_time)[1] = 0;
    tim_count = TIM14->CNT;
    returned_time.fourty_eight_bit_time.lower_16_bits = (uint16_t)tim_count;
    if(tim_count & (1 << 31)) {
        upper_32_bits++;
        TIM14->SR = 0; // clear the bit that indicated an overflow which is re-mapped to bit 31 of the CNT register
    }
    returned_time.fourty_eight_bit_time.upper_32_bits = upper_32_bits;

    if(returned_time.sixty_four_bit_time < previous_64bit_time) {
        fatal_error(ERROR_TIME_WENT_BACKWARDS); // All error messages are defined in error_text.h, which is an autogenerated file based on error_codes.json in the servomotor Python module (<repo root>/python_programs/servomotor/error_codes.json)
    }
    previous_64bit_time = returned_time.sixty_four_bit_time;

    __enable_irq();

    return returned_time.sixty_four_bit_time;
}

/*
uint64_t get_microsecond_time(void)
{
    static uint64_t previous_64bit_time = 0;
    volatile union {
        volatile uint64_t sixty_four_bit_time;
        volatile struct __attribute__((__packed__)) {
            volatile uint16_t lower_16_bits;
            volatile uint32_t upper_32_bits;
        } fourty_eight_bit_time;
    } returned_time;

    returned_time.sixty_four_bit_time = 0;
    returned_time.fourty_eight_bit_time.upper_32_bits = upper_32_bits;
    returned_time.fourty_eight_bit_time.lower_16_bits = TIM14->CNT;

    while(returned_time.fourty_eight_bit_time.upper_32_bits != upper_32_bits) { // check if the timer rolled over in the middle of reading it
        returned_time.fourty_eight_bit_time.upper_32_bits = upper_32_bits; // if it rolled over, we need to read it again to make sure we have the new rolled over value
        returned_time.fourty_eight_bit_time.lower_16_bits = TIM14->CNT;
    }

    if(returned_time.sixty_four_bit_time < previous_64bit_time) {
        returned_time.sixty_four_bit_time = previous_64bit_time + 1;
    }
    previous_64bit_time = returned_time.sixty_four_bit_time;

    return returned_time.sixty_four_bit_time;
}
*/


void reset_microsecond_time(void)
{
    __disable_irq();
    TIM14->CNT = 0;
    upper_32_bits = 0;
    previous_64bit_time = 0;
    __enable_irq();
}


void microsecond_delay(uint32_t microseconds)
{
    uint64_t start_time = get_microsecond_time();
    while(get_microsecond_time() - start_time < microseconds);
}
