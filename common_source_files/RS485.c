#include "stm32g0xx_hal.h"
#include <string.h>
#include "RS485.h"
#include "error_handling.h"
#include "leds.h"
#include <stdlib.h>
#include <stdio.h>
#include "global_variables.h"
#include "device_status.h"
#include "unique_id.h"
#include "crc32.h"

static volatile char transmitBuffer[TRANSMIT_BUFFER_SIZE];
static volatile uint8_t transmitIndex = 0;
static volatile uint8_t transmitCount = 0;

#define UNKNOWN_VALUE_LENGTH 65535
static uint16_t nReceivedBytes = 0;
static uint16_t receiveIndex;

volatile uint8_t selectedAxis;
volatile uint8_t command;
volatile uint8_t valueBuffer[MAX_VALUE_BUFFER_LENGTH];
volatile uint16_t valueLength;
volatile uint8_t commandReceived = 0;
volatile uint8_t in_extended_addressing_mode = 0;

static volatile uint8_t unique_id_mismatch = 0; // Flag to track if unique ID doesn't match (0 = match so far)
static volatile uint8_t unique_id_bytes_received = 0;

void rs485_init(void)
{
    commandReceived = 0;
    unique_id_mismatch = 0; // Initialize to no mismatch (will be set to 1 if any byte doesn't match)
    unique_id_bytes_received = 0;
    in_extended_addressing_mode = 0;
    
    RCC->APBENR2 |= RCC_APBENR2_USART1EN_Msk; // enable the clock to the UART1 peripheral
    RCC->CCIPR |= 1 << RCC_CCIPR_USART1SEL_Pos; // select SYSCLK as the clock source
    
    GPIOB->AFR[0] |= (0 << GPIO_AFRL_AFSEL6_Pos) | // for PB6, choose alternative function 0 (USART1_TX)
                     (0 << GPIO_AFRL_AFSEL7_Pos);  // for PB7, choose alternative function 0 (USART1_RX)
    GPIOA->AFR[1] |= (1 << GPIO_AFRH_AFSEL12_Pos); // for PA12, choose alternative function 1 (USART1_DE)

    USART1->BRR = 278; // set baud to 230400 @ 64MHz SYSCLK
    USART1->CR1 = (0 << USART_CR1_DEAT_Pos) | (0 << USART_CR1_DEDT_Pos) | USART_CR1_FIFOEN | USART_CR1_RXNEIE_RXFNEIE; // set timing parameters for the drive enable, enable the FIFO mode, enable the receive interrupt
    USART1->CR2 = USART_CR2_RTOEN; // enable the timeout feature  (this is supported on USART1 but not supported on USART2)
    USART1->RTOR = ((230400 / 10) << USART_RTOR_RTO_Pos); // set the timeout t0 0.1 s)
    USART1->CR3 = (0 << USART_CR3_DEP_Pos) | USART_CR3_DEM | USART_CR3_EIE; // drive enable is active high, enable the drive enable, an interrupt will happen if there is an error (like overrun or framing error or noise error), 
    USART1->CR1 |= USART_CR1_TE | USART_CR1_RE | USART_CR1_UE; // enable transmitter, receiver, and the uart
    NVIC_SetPriority(USART1_IRQn, 2); // third highest priority. needs to be lower than the motor control interrupt (PWM.c) but otherwise this is more important than things like systick
    NVIC_EnableIRQ(USART1_IRQn);
}

void rs485_allow_next_command(void)
{
    commandReceived = 0;
    USART1->CR1 |= USART_CR1_RXNEIE_RXFNEIE; // enable receive interrupt
}

void USART1_IRQHandler(void)
{
    // check for errors like framing error, overrun error, and noise error
    if(USART1->ISR & USART_ISR_FE) {
        fatal_error(ERROR_FRAMING); // All error messages are defined in error_text.h, which is an autogenerated file based on error_codes.json in the servomotor Python module (<repo root>/python_programs/servomotor/error_codes.json)
    }
    if(USART1->ISR & USART_ISR_ORE) {
        fatal_error(ERROR_OVERRUN); // All error messages are defined in error_text.h, which is an autogenerated file based on error_codes.json in the servomotor Python module (<repo root>/python_programs/servomotor/error_codes.json)
    }
    if(USART1->ISR & USART_ISR_NE) {
        fatal_error(ERROR_NOISE); // All error messages are defined in error_text.h, which is an autogenerated file based on error_codes.json in the servomotor Python module (<repo root>/python_programs/servomotor/error_codes.json)
    }

    if((USART1->ISR & USART_ISR_RXNE_RXFNE) && (USART1->CR1 & USART_CR1_RXNEIE_RXFNEIE)) {
        if(USART1->ISR & USART_ISR_RTOF) {
            nReceivedBytes = 0;
            USART1->ICR |= USART_ICR_RTOCF; // clear the timeout flag
        }
        uint8_t receivedByte;
        receivedByte = USART1->RDR;
        #ifdef MOTOR_SIMULATION
        USART1->ISR &= ~USART_ISR_RXNE_RXFNE; // clear this bit to indicate that we have read the received byte (done automatically in the real hardware but not in the simulated hardware)
        #endif
        // Error checks for received bytes count and command overflow
        if(nReceivedBytes >= 65535) {
            fatal_error(ERROR_TOO_MANY_BYTES);
        }
        if(commandReceived) {
            fatal_error(ERROR_COMMAND_OVERFLOW);
        }
        
        nReceivedBytes++;

        // Process the first byte (device ID or extended addressing indicator)
        if(nReceivedBytes == 1) {
            if(!is_valid_device_id_format(receivedByte)) {
                fatal_error(ERROR_INVALID_DEVICE_ID);
            }
            selectedAxis = decode_device_id(receivedByte);
            in_extended_addressing_mode = (selectedAxis == EXTENDED_ADDRESSING);
            unique_id_bytes_received = 0;
            
            // Set unique_id_mismatch based on addressing mode
            if(in_extended_addressing_mode) {
                unique_id_mismatch = 0; // For extended addressing, we'll check bytes as they arrive
            } else {
                // For standard addressing, check if this message is for us
                unique_id_mismatch = (selectedAxis == RESPONSE_CHARACTER || 
                                    (selectedAxis != global_settings.my_alias && 
                                     selectedAxis != ALL_ALIAS)) ? 1 : 0;
            }
            valueLength = UNKNOWN_VALUE_LENGTH; // valueLength needs to be initialized to some high number so that the condition if(receiveIndex >= valueLength) is always false before the correct valueLength is determined
            return; // Return to wait for next byte
        }
        
        // Process based on addressing mode
        if(in_extended_addressing_mode) {
            // Extended addressing mode
            if(unique_id_bytes_received < UNIQUE_ID_SIZE) {
                // Check each unique ID byte as it arrives
                uint64_t device_id = get_unique_id();
                uint8_t expected_byte = (device_id >> (unique_id_bytes_received * 8)) & 0xFF;
                
                // If any byte doesn't match, set the mismatch flag to 1
                if(receivedByte != expected_byte) {
                    unique_id_mismatch = 1;
                }

                unique_id_bytes_received++;
            }
            else if(unique_id_bytes_received == UNIQUE_ID_SIZE) {
                // Received all unique ID bytes, now get command
                command = receivedByte;
                unique_id_bytes_received++;
            }
            else if(unique_id_bytes_received == UNIQUE_ID_SIZE + 1) {
                // Get value length
                valueLength = receivedByte;
                receiveIndex = 0;
                unique_id_bytes_received++;
            }
            else if((unique_id_bytes_received == UNIQUE_ID_SIZE + 3) && (valueLength == 255)) {
                // Handle extended value length
                valueLength = (receivedByte << 8) + valueBuffer[0];
                receiveIndex = 0;
            }
            else if(receiveIndex < MAX_VALUE_BUFFER_LENGTH) {
                // Store value bytes
                valueBuffer[receiveIndex++] = receivedByte;
            }
        }
        else {
            // Standard addressing mode
            if(nReceivedBytes == 2) {
                // Second byte is the command
                command = receivedByte;
            }
            else if(nReceivedBytes == 3) {
                // Third byte is the value length
                valueLength = receivedByte;
                receiveIndex = 0;
            }
            else if((nReceivedBytes == 5) && (valueLength == 255)) {
                // Extended value length
                valueLength = (receivedByte << 8) + valueBuffer[0];
                receiveIndex = 0;
            }
            else if(receiveIndex < MAX_VALUE_BUFFER_LENGTH) {
                // Store value bytes
                valueBuffer[receiveIndex++] = receivedByte;
            }
        }
        
        // Check if we've received all bytes for the current command
        if(receiveIndex >= valueLength) { // This condition must remain false before the correct valueLength is received. That is why we initialize valueLength to UNKNOWN_VALUE_LENGTH, which is a big number
            // Process command if it's addressed to this device (no mismatch)
            if(!unique_id_mismatch) {
                if(valueLength <= MAX_VALUE_BUFFER_LENGTH) {
                    USART1->CR1 &= ~USART_CR1_RXNEIE_RXFNEIE; // Disable receive interrupt until command is processed
                    commandReceived = 1;
                }
                else {
                    fatal_error(ERROR_COMMAND_TOO_LONG);
                }
            }
            
            nReceivedBytes = 0; // Reset state for next command
        }
    }

    if(nReceivedBytes == 0) {
        red_LED_off();
    }
    else {
        red_LED_on();
    }

    while((USART1->ISR & USART_ISR_TXE_TXFNF_Msk) && (transmitCount > 0)) {
        USART1->TDR = transmitBuffer[transmitIndex];
#ifdef MOTOR_SIMULATION
        // In simulation, we need to clear TXE after writing to TDR
        // (In real hardware, this is done by the USART hardware)
        USART1->ISR &= ~USART_ISR_TXE_TXFNF_Msk;
#endif
        transmitCount--;
        transmitIndex++;
    }

    if(transmitCount == 0) {
        USART1->CR1 &= ~USART_CR1_TXFEIE; // nothing more to transmit, so disable the interrupt
    }
}


void rs485_transmit(void *s, uint8_t len)
{
    if(len == 0) {
        return;
    }
    if(len > TRANSMIT_BUFFER_SIZE) {
        len = TRANSMIT_BUFFER_SIZE;
    }
    while(transmitCount > 0); // wait for previous transmission to finish
    memcpy((void*)transmitBuffer, s, len); // we discard the volatile qualifier here. i am not actually sure if this is safe or not.
    transmitIndex = 0;
    transmitCount = len;

    while((USART1->ISR & USART_ISR_TXE_TXFNF_Msk) && (transmitCount > 0)) {
        USART1->TDR = transmitBuffer[transmitIndex];
#ifdef MOTOR_SIMULATION
        // In simulation, we need to clear TXE after writing to TDR
        // (In real hardware, this is done by the USART hardware)
        USART1->ISR &= ~USART_ISR_TXE_TXFNF_Msk;
#endif
        transmitCount--;
        transmitIndex++;
    }
    if(transmitCount > 0) {
        USART1->CR1 |= USART_CR1_TXFEIE; // we have more to transmit and the buffer must be full,
                                         // so enable the interrupt to handle the rest of the transmission
                                         // once the buffer becomes empty
    }
}

void rs485_wait_for_transmit_done(void)
{
    while(transmitCount > 0); // wait for previous transmission to finish
}



#ifdef MOTOR_SIMULATION
/**
 * Initialize all static variables in RS485.c for simulator use
 * This function should be called when the simulator starts to ensure
 * all static variables are properly initialized
 */
void RS485_simulator_init(void)
{
    printf("RS485_simulator_init() called\n");
    
    // Set up the USART1 interrupt status register such that no interrupt flags are set
    // except for the USART_ISR_TXE_TXFNF_Msk flag, which indicates that the transmit buffer is empty and the UART
    // is ready to accept a new byte for sending out
    // Hardware does this in the real hardware, but we need to do it in the simulator
    USART1->ISR = USART_ISR_TXE_TXFNF_Msk;

    // Initialize transmit buffer variables
    transmitIndex = 0;
    transmitCount = 0;
    
    // Initialize static variables that were moved from USART1_IRQHandler
    nReceivedBytes = 0;
    receiveIndex = 0;
    
    // Initialize command handling variables
    commandReceived = 0;
    
    // Initialize extended addressing variables
    unique_id_mismatch = 0; // Initialize to no mismatch
    unique_id_bytes_received = 0;
    in_extended_addressing_mode = 0;
    selectedAxis = 0;
    command = 0;
    
    // Clear value buffer
    for (int i = 0; i < MAX_VALUE_BUFFER_LENGTH; i++) {
        valueBuffer[i] = 0;
    }
    
    printf("RS485 module reset complete\n");
}

void print_nReceivedBytes(void)
{
    printf("nReceivedBytes = %hu\n", nReceivedBytes);
}

#endif

