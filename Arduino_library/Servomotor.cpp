// Servomotor.cpp
// Autogenerated by generate_command_code.py on Mar 11 2025 20:27:03
// Do not edit manually. If changes are needed, modify the generator program instead.

#include "Servomotor.h"
#include "Commands.h"
#include "Utils.h"

Servomotor::Servomotor(uint8_t alias, HardwareSerial& serialPort)
    : _alias(alias), _comm(serialPort), _errno(0),
      m_timeUnit(TimeUnit::TIMESTEPS),
      m_positionUnit(PositionUnit::SHAFT_ROTATIONS),
      m_velocityUnit(VelocityUnit::ROTATIONS_PER_SECOND),
      m_accelerationUnit(AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED),
      m_currentUnit(CurrentUnit::INTERNAL_CURRENT_UNITS),
      m_voltageUnit(VoltageUnit::MILLIVOLTS),
      m_temperatureUnit(TemperatureUnit::CELSIUS) {
    openSerialPort();
}

void Servomotor::setAlias(uint8_t new_alias) {
    _alias = new_alias;
}

uint8_t Servomotor::getAlias() {
    return _alias;
}

void Servomotor::openSerialPort() {
    _comm.openSerialPort();
}

int Servomotor::getError() const {
    return _errno;
}

// Unit setting functions
void Servomotor::setTimeUnit(TimeUnit unit) {
    m_timeUnit = unit;
    Serial.print("[Motor] setTimeUnit to ");
    switch(unit) {
        case TimeUnit::TIMESTEPS: Serial.println("TIMESTEPS"); break;
        case TimeUnit::SECONDS: Serial.println("SECONDS"); break;
        case TimeUnit::MILLISECONDS: Serial.println("MILLISECONDS"); break;
        case TimeUnit::MINUTES: Serial.println("MINUTES"); break;
    }
}

void Servomotor::setPositionUnit(PositionUnit unit) {
    m_positionUnit = unit;
    Serial.print("[Motor] setPositionUnit to ");
    switch(unit) {
        case PositionUnit::SHAFT_ROTATIONS: Serial.println("SHAFT_ROTATIONS"); break;
        case PositionUnit::DEGREES: Serial.println("DEGREES"); break;
        case PositionUnit::RADIANS: Serial.println("RADIANS"); break;
        case PositionUnit::ENCODER_COUNTS: Serial.println("ENCODER_COUNTS"); break;
    }
}

void Servomotor::setVelocityUnit(VelocityUnit unit) {
    m_velocityUnit = unit;
    Serial.print("[Motor] setVelocityUnit to ");
    switch(unit) {
        case VelocityUnit::ROTATIONS_PER_SECOND: Serial.println("ROTATIONS_PER_SECOND"); break;
        case VelocityUnit::RPM: Serial.println("RPM"); break;
        case VelocityUnit::DEGREES_PER_SECOND: Serial.println("DEGREES_PER_SECOND"); break;
        case VelocityUnit::RADIANS_PER_SECOND: Serial.println("RADIANS_PER_SECOND"); break;
        case VelocityUnit::COUNTS_PER_SECOND: Serial.println("COUNTS_PER_SECOND"); break;
        case VelocityUnit::COUNTS_PER_TIMESTEP: Serial.println("COUNTS_PER_TIMESTEP"); break;
    }
}

void Servomotor::setAccelerationUnit(AccelerationUnit unit) {
    m_accelerationUnit = unit;
    Serial.print("[Motor] setAccelerationUnit to ");
    switch(unit) {
        case AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED: Serial.println("ROTATIONS_PER_SECOND_SQUARED"); break;
        case AccelerationUnit::RPM_PER_SECOND: Serial.println("RPM_PER_SECOND"); break;
        case AccelerationUnit::DEGREES_PER_SECOND_SQUARED: Serial.println("DEGREES_PER_SECOND_SQUARED"); break;
        case AccelerationUnit::RADIANS_PER_SECOND_SQUARED: Serial.println("RADIANS_PER_SECOND_SQUARED"); break;
        case AccelerationUnit::COUNTS_PER_SECOND_SQUARED: Serial.println("COUNTS_PER_SECOND_SQUARED"); break;
        case AccelerationUnit::COUNTS_PER_TIMESTEP_SQUARED: Serial.println("COUNTS_PER_TIMESTEP_SQUARED"); break;
    }
}

void Servomotor::setCurrentUnit(CurrentUnit unit) {
    m_currentUnit = unit;
    Serial.print("[Motor] setCurrentUnit to ");
    switch(unit) {
        case CurrentUnit::INTERNAL_CURRENT_UNITS: Serial.println("INTERNAL_CURRENT_UNITS"); break;
        case CurrentUnit::MILLIAMPS: Serial.println("MILLIAMPS"); break;
        case CurrentUnit::AMPS: Serial.println("AMPS"); break;
    }
}

void Servomotor::setVoltageUnit(VoltageUnit unit) {
    m_voltageUnit = unit;
    Serial.print("[Motor] setVoltageUnit to ");
    switch(unit) {
        case VoltageUnit::MILLIVOLTS: Serial.println("MILLIVOLTS"); break;
        case VoltageUnit::VOLTS: Serial.println("VOLTS"); break;
    }
}

void Servomotor::setTemperatureUnit(TemperatureUnit unit) {
    m_temperatureUnit = unit;
    Serial.print("[Motor] setTemperatureUnit to ");
    switch(unit) {
        case TemperatureUnit::CELSIUS: Serial.println("CELSIUS"); break;
        case TemperatureUnit::FAHRENHEIT: Serial.println("FAHRENHEIT"); break;
        case TemperatureUnit::KELVIN: Serial.println("KELVIN"); break;
    }
}

void Servomotor::disableMosfets() {
    Serial.println("[Motor] disableMosfets called.");
    // Disables the MOSFETS (note that MOSFETs are disabled after initial power on).
    const uint8_t commandID = CMD_DISABLE_MOSFETS;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::enableMosfets() {
    Serial.println("[Motor] enableMosfets called.");
    // Enables the MOSFETS.
    const uint8_t commandID = CMD_ENABLE_MOSFETS;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::trapezoidMoveRaw(int32_t displacement, uint32_t duration) {
    // Move immediately to the given position using the currently set speed (the speed is set by a separate command) (Raw version)
    const uint8_t commandID = CMD_TRAPEZOID_MOVE;
    trapezoidMovePayload payload;
    payload.displacement = htole32(displacement);
    payload.duration = htole32(duration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::trapezoidMove(float displacement, float duration) {
    Serial.println("[Motor] trapezoidMove called.");
    Serial.print("  displacement in chosen unit: "); Serial.println(displacement);
    Serial.print("  duration in chosen unit: "); Serial.println(duration);

    float displacement_internal = convertPosition(displacement, m_positionUnit, ConversionDirection::TO_INTERNAL);
    float duration_internal = convertTime(duration, m_timeUnit, ConversionDirection::TO_INTERNAL);
    trapezoidMoveRaw((int32_t)(displacement_internal), (uint32_t)(duration_internal));
}

void Servomotor::setMaximumVelocityRaw(uint32_t maximumVelocity) {
    // Sets maximum velocity (this is not used at this time) (Raw version)
    const uint8_t commandID = CMD_SET_MAXIMUM_VELOCITY;
    setMaximumVelocityPayload payload;
    payload.maximumVelocity = htole32(maximumVelocity);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::setMaximumVelocity(float maximumVelocity) {
    Serial.println("[Motor] setMaximumVelocity called.");
    Serial.print("  maximumVelocity in chosen unit: "); Serial.println(maximumVelocity);

    float maximumVelocity_internal = convertVelocity(maximumVelocity, m_velocityUnit, ConversionDirection::TO_INTERNAL);
    setMaximumVelocityRaw((uint32_t)(maximumVelocity_internal));
}

void Servomotor::goToPositionRaw(int32_t position, uint32_t duration) {
    // Move to this new given position in the amount of time specified. Acceleration and deceleration will be applied to make the move smooth. (Raw version)
    const uint8_t commandID = CMD_GO_TO_POSITION;
    goToPositionPayload payload;
    payload.position = htole32(position);
    payload.duration = htole32(duration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::goToPosition(float position, float duration) {
    Serial.println("[Motor] goToPosition called.");
    Serial.print("  position in chosen unit: "); Serial.println(position);
    Serial.print("  duration in chosen unit: "); Serial.println(duration);

    float position_internal = convertPosition(position, m_positionUnit, ConversionDirection::TO_INTERNAL);
    float duration_internal = convertTime(duration, m_timeUnit, ConversionDirection::TO_INTERNAL);
    goToPositionRaw((int32_t)(position_internal), (uint32_t)(duration_internal));
}

void Servomotor::setMaximumAccelerationRaw(uint32_t maximumAcceleration) {
    // Sets max acceleration (Raw version)
    const uint8_t commandID = CMD_SET_MAXIMUM_ACCELERATION;
    setMaximumAccelerationPayload payload;
    payload.maximumAcceleration = htole32(maximumAcceleration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::setMaximumAcceleration(float maximumAcceleration) {
    Serial.println("[Motor] setMaximumAcceleration called.");
    Serial.print("  maximumAcceleration in chosen unit: "); Serial.println(maximumAcceleration);

    float maximumAcceleration_internal = convertAcceleration(maximumAcceleration, m_accelerationUnit, ConversionDirection::TO_INTERNAL);
    setMaximumAccelerationRaw((uint32_t)(maximumAcceleration_internal));
}

void Servomotor::startCalibration() {
    Serial.println("[Motor] startCalibration called.");
    // Starts a calibration, which will determine the average values of the hall sensors and will determine if they are working correctly
    const uint8_t commandID = CMD_START_CALIBRATION;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

uint8_t Servomotor::captureHallSensorData(uint8_t dataType) {
    Serial.println("[Motor] captureHallSensorData called.");
    // Start sending hall sensor data (work in progress; don't send this command)
    const uint8_t commandID = CMD_CAPTURE_HALL_SENSOR_DATA;
    captureHallSensorDataPayload payload;
    payload.dataType = dataType;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[sizeof(uint8_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(uint8_t)) {
            uint8_t* response = (uint8_t*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    uint8_t defaultResponse = {0};
    return defaultResponse;
}

void Servomotor::resetTime() {
    Serial.println("[Motor] resetTime called.");
    // Resets the absolute time to zero (call this first before issuing any movement commands)
    const uint8_t commandID = CMD_RESET_TIME;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getCurrentTimeResponse Servomotor::getCurrentTimeRaw() {
    // Gets the current absolute time (Raw version)
    const uint8_t commandID = CMD_GET_CURRENT_TIME;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getCurrentTimeResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getCurrentTimeResponse)) {
            getCurrentTimeResponse* response = (getCurrentTimeResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getCurrentTimeResponse defaultResponse = {0};
    return defaultResponse;
}

float Servomotor::getCurrentTime() {
    Serial.println("[Motor] getCurrentTime called.");

    auto rawResult = getCurrentTimeRaw();
    float converted = convertTime((float)rawResult.currentTime, m_timeUnit, ConversionDirection::FROM_INTERNAL);
    return converted;
}

timeSyncResponse Servomotor::timeSync(uint64_t masterTime) {
    Serial.println("[Motor] timeSync called.");
    // Sends the master time to the motor so that it can sync its own clock (do this 10 times per second).
    const uint8_t commandID = CMD_TIME_SYNC;
    timeSyncPayload payload;
    payload.masterTime = htole64(masterTime);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[sizeof(timeSyncResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(timeSyncResponse)) {
            timeSyncResponse* response = (timeSyncResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    timeSyncResponse defaultResponse = {0};
    return defaultResponse;
}

uint8_t Servomotor::getNumberOfQueuedItems() {
    Serial.println("[Motor] getNumberOfQueuedItems called.");
    // Get the number of items currently in the movement queue (if this gets too large, don't queue any more movement commands)
    const uint8_t commandID = CMD_GET_N_QUEUED_ITEMS;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(uint8_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(uint8_t)) {
            uint8_t* response = (uint8_t*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    uint8_t defaultResponse = {0};
    return defaultResponse;
}

void Servomotor::emergencyStop() {
    Serial.println("[Motor] emergencyStop called.");
    // Emergency stop (stop all movement, disable MOSFETS, clear the queue)
    const uint8_t commandID = CMD_EMERGENCY_STOP;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::zeroPosition() {
    Serial.println("[Motor] zeroPosition called.");
    // Make the current position the position zero (origin)
    const uint8_t commandID = CMD_ZERO_POSITION;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::homingRaw(int32_t maxDistance, uint32_t maxDuration) {
    // Homing (or in other words, move until a crash and then stop immediately) (Raw version)
    const uint8_t commandID = CMD_HOMING;
    homingPayload payload;
    payload.maxDistance = htole32(maxDistance);
    payload.maxDuration = htole32(maxDuration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::homing(float maxDistance, float maxDuration) {
    Serial.println("[Motor] homing called.");
    Serial.print("  maxDistance in chosen unit: "); Serial.println(maxDistance);
    Serial.print("  maxDuration in chosen unit: "); Serial.println(maxDuration);

    float maxDistance_internal = convertPosition(maxDistance, m_positionUnit, ConversionDirection::TO_INTERNAL);
    float maxDuration_internal = convertTime(maxDuration, m_timeUnit, ConversionDirection::TO_INTERNAL);
    homingRaw((int32_t)(maxDistance_internal), (uint32_t)(maxDuration_internal));
}

getHallSensorPositionResponse Servomotor::getHallSensorPositionRaw() {
    // Get the position as measured by the hall sensors (this should be the actual position of the motor and if everything is ok then it will be about the same as the desired position) (Raw version)
    const uint8_t commandID = CMD_GET_HALL_SENSOR_POSITION;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getHallSensorPositionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getHallSensorPositionResponse)) {
            getHallSensorPositionResponse* response = (getHallSensorPositionResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getHallSensorPositionResponse defaultResponse = {0};
    return defaultResponse;
}

float Servomotor::getHallSensorPosition() {
    Serial.println("[Motor] getHallSensorPosition called.");

    auto rawResult = getHallSensorPositionRaw();
    float converted = convertPosition((float)rawResult.hallSensorPosition, m_positionUnit, ConversionDirection::FROM_INTERNAL);
    return converted;
}

StatusResponse Servomotor::getStatus() {
    Serial.println("[Motor] getStatus called.");
    // Gets the status of the motor
    const uint8_t commandID = CMD_GET_STATUS;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(StatusResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(StatusResponse)) {
            StatusResponse* response = (StatusResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    StatusResponse defaultResponse = {0};
    return defaultResponse;
}

void Servomotor::goToClosedLoop() {
    Serial.println("[Motor] goToClosedLoop called.");
    // Go to closed loop position control mode
    const uint8_t commandID = CMD_GO_TO_CLOSED_LOOP;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

uint32_t Servomotor::getUpdateFrequency() {
    Serial.println("[Motor] getUpdateFrequency called.");
    // Get the update frequency (reciprocal of the time step)
    const uint8_t commandID = CMD_GET_UPDATE_FREQUENCY;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(uint32_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(uint32_t)) {
            uint32_t* response = (uint32_t*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    uint32_t defaultResponse = {0};
    return defaultResponse;
}

void Servomotor::moveWithAccelerationRaw(int32_t acceleration, uint32_t timeSteps) {
    // Rotates the motor with the specified acceleration (Raw version)
    const uint8_t commandID = CMD_MOVE_WITH_ACCELERATION;
    moveWithAccelerationPayload payload;
    payload.acceleration = htole32(acceleration);
    payload.timeSteps = htole32(timeSteps);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::moveWithAcceleration(float acceleration, float timeSteps) {
    Serial.println("[Motor] moveWithAcceleration called.");
    Serial.print("  acceleration in chosen unit: "); Serial.println(acceleration);
    Serial.print("  timeSteps in chosen unit: "); Serial.println(timeSteps);

    float acceleration_internal = convertAcceleration(acceleration, m_accelerationUnit, ConversionDirection::TO_INTERNAL);
    float timeSteps_internal = convertTime(timeSteps, m_timeUnit, ConversionDirection::TO_INTERNAL);
    moveWithAccelerationRaw((int32_t)(acceleration_internal), (uint32_t)(timeSteps_internal));
}

detectDevicesResponse Servomotor::detectDevices() {
    Serial.println("[Motor] detectDevices called.");
    // Detect all of the devices that are connected on the RS485 interface. Devices will identify themselves at a random time within one seconde. Chance of collision is possible but unlikely. You can repeat this if you suspect a collision (like if you have devices connected but they were not discovered within one to two seconds).
    const uint8_t commandID = CMD_DETECT_DEVICES;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(detectDevicesResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(detectDevicesResponse)) {
            detectDevicesResponse* response = (detectDevicesResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    detectDevicesResponse defaultResponse = {0};
    return defaultResponse;
}

detectDevicesResponse Servomotor::detectDevicesGetAnotherResponse() {
    // Attempt to receive another response from previously sent Detect devices command
    uint8_t buffer[sizeof(detectDevicesResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(detectDevicesResponse)) {
            detectDevicesResponse* response = (detectDevicesResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return detectDevicesResponse();
}

void Servomotor::setDeviceAlias(uint64_t uniqueId, uint8_t alias) {
    Serial.println("[Motor] setDeviceAlias called.");
    // Sets device alias
    const uint8_t commandID = CMD_SET_DEVICE_ALIAS;
    setDeviceAliasPayload payload;
    payload.uniqueId = htole64(uniqueId);
    payload.alias = alias;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getProductInfoResponse Servomotor::getProductInfo() {
    Serial.println("[Motor] getProductInfo called.");
    // Get product information
    const uint8_t commandID = CMD_GET_PRODUCT_INFO;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getProductInfoResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getProductInfoResponse)) {
            getProductInfoResponse* response = (getProductInfoResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getProductInfoResponse defaultResponse = {0};
    return defaultResponse;
}

void Servomotor::firmwareUpgrade(uint8_t firmwarePage[2058]) {
    Serial.println("[Motor] firmwareUpgrade called.");
    // This command will upgrade the flash memory of the servo motor. Before issuing a firmware upgrade command, you must do some calculations as shown in the examples.
    const uint8_t commandID = CMD_FIRMWARE_UPGRADE;
    firmwareUpgradePayload payload;
    memcpy(payload.firmwarePage, firmwarePage, sizeof(payload.firmwarePage));
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getProductDescriptionResponse Servomotor::getProductDescription() {
    Serial.println("[Motor] getProductDescription called.");
    // Get the product description. Documentation to be done later.
    const uint8_t commandID = CMD_GET_PRODUCT_DESCRIPTION;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getProductDescriptionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getProductDescriptionResponse)) {
            getProductDescriptionResponse* response = (getProductDescriptionResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getProductDescriptionResponse defaultResponse = {0};
    return defaultResponse;
}

uint32_t Servomotor::getFirmwareVersion() {
    Serial.println("[Motor] getFirmwareVersion called.");
    // Get the firmware version. Documentation to be done later.
    const uint8_t commandID = CMD_GET_FIRMWARE_VERSION;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(uint32_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(uint32_t)) {
            uint32_t* response = (uint32_t*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    uint32_t defaultResponse = {0};
    return defaultResponse;
}

void Servomotor::moveWithVelocityRaw(int32_t velocity, uint32_t duration) {
    // Rotates the motor with the specified velocity. (Raw version)
    const uint8_t commandID = CMD_MOVE_WITH_VELOCITY;
    moveWithVelocityPayload payload;
    payload.velocity = htole32(velocity);
    payload.duration = htole32(duration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::moveWithVelocity(float velocity, float duration) {
    Serial.println("[Motor] moveWithVelocity called.");
    Serial.print("  velocity in chosen unit: "); Serial.println(velocity);
    Serial.print("  duration in chosen unit: "); Serial.println(duration);

    float velocity_internal = convertVelocity(velocity, m_velocityUnit, ConversionDirection::TO_INTERNAL);
    float duration_internal = convertTime(duration, m_timeUnit, ConversionDirection::TO_INTERNAL);
    moveWithVelocityRaw((int32_t)(velocity_internal), (uint32_t)(duration_internal));
}

void Servomotor::systemReset() {
    Serial.println("[Motor] systemReset called.");
    // System reset / go to the bootloader. The motor will reset immediately and will enter the bootloader. If there is no command sent within a short time, the motor will exit the bootloader and run the application from the beginning.
    const uint8_t commandID = CMD_SYSTEM_RESET;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::setMaximumMotorCurrentRaw(uint16_t motorCurrent, uint16_t regenerationCurrent) {
    // Set the maximum motor current and maximum regeneration current. The values are stored in non-volatile memory and survive a reset. (Raw version)
    const uint8_t commandID = CMD_SET_MAXIMUM_MOTOR_CURRENT;
    setMaximumMotorCurrentPayload payload;
    payload.motorCurrent = htole16(motorCurrent);
    payload.regenerationCurrent = htole16(regenerationCurrent);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::setMaximumMotorCurrent(float motorCurrent, float regenerationCurrent) {
    Serial.println("[Motor] setMaximumMotorCurrent called.");
    Serial.print("  motorCurrent in chosen unit: "); Serial.println(motorCurrent);
    Serial.print("  regenerationCurrent in chosen unit: "); Serial.println(regenerationCurrent);

    float motorCurrent_internal = convertCurrent(motorCurrent, m_currentUnit, ConversionDirection::TO_INTERNAL);
    float regenerationCurrent_internal = convertCurrent(regenerationCurrent, m_currentUnit, ConversionDirection::TO_INTERNAL);
    setMaximumMotorCurrentRaw((uint16_t)(motorCurrent_internal), (uint16_t)(regenerationCurrent_internal));
}

void Servomotor::multiMoveRaw(uint8_t moveCount, uint32_t moveTypes, multiMoveList_t* moveList) {
    // Multi move command allows you to compose multiple moves one after eachother. The last move must set the motor's velocity to 0 for a period of time(e.g. 0.1s) to allow the motor to stop, otherwise the motor will enter in an error state. (Raw version)
    const uint8_t commandID = CMD_MULTI_MOVE;
    multiMovePayload payload;
    payload.moveCount = moveCount;
    payload.moveTypes = htole32(moveTypes);
    memcpy(payload.moveList, moveList, moveCount * sizeof(multiMoveList_t));
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::multiMove(uint8_t moveCount, uint32_t moveTypes, multiMoveListConverted_t* moveList) {
    Serial.println("[Motor] multiMove called.");
    Serial.println("  Converting moveList to internal units...");

    // Create a temporary array for the converted move list
    multiMoveList_t convertedMoveList[moveCount];

    // Convert each move from user units to internal units
    for (uint8_t i = 0; i < moveCount; i++) {
        bool isVelocityMove = (moveTypes >> i) & 1;
        Serial.print("  Move "); Serial.print(i + 1);
        Serial.print(": "); Serial.print(isVelocityMove ? "Velocity" : "Acceleration");
        Serial.print(" = "); Serial.print(moveList[i].value);
        Serial.print(", Duration = "); Serial.println(moveList[i].duration);

        // Convert the value based on the move type
        if (isVelocityMove) {
            // Velocity move
            float velocity_internal = convertVelocity(moveList[i].value, m_velocityUnit, ConversionDirection::TO_INTERNAL);
            convertedMoveList[i].value = (int32_t)velocity_internal;
            Serial.print("    -> velocity in internal units: "); Serial.println(convertedMoveList[i].value);
        } else {
            // Acceleration move
            float acceleration_internal = convertAcceleration(moveList[i].value, m_accelerationUnit, ConversionDirection::TO_INTERNAL);
            convertedMoveList[i].value = (int32_t)acceleration_internal;
            Serial.print("    -> acceleration in internal units: "); Serial.println(convertedMoveList[i].value);
        }

        // Convert the duration
        float duration_internal = convertTime(moveList[i].duration, m_timeUnit, ConversionDirection::TO_INTERNAL);
        convertedMoveList[i].timeSteps = (uint32_t)duration_internal;
        Serial.print("    -> duration in timesteps: "); Serial.println((int)convertedMoveList[i].timeSteps);
    }

    multiMoveRaw(moveCount, moveTypes, convertedMoveList);
}

void Servomotor::setSafetyLimitsRaw(int64_t lowerLimit, int64_t upperLimit) {
    // Set safety limits (to prevent motion from exceeding set bounds) (Raw version)
    const uint8_t commandID = CMD_SET_SAFETY_LIMITS;
    setSafetyLimitsPayload payload;
    payload.lowerLimit = htole64(lowerLimit);
    payload.upperLimit = htole64(upperLimit);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::setSafetyLimits(float lowerLimit, float upperLimit) {
    Serial.println("[Motor] setSafetyLimits called.");
    Serial.print("  lowerLimit in chosen unit: "); Serial.println(lowerLimit);
    Serial.print("  upperLimit in chosen unit: "); Serial.println(upperLimit);

    float lowerLimit_internal = convertPosition(lowerLimit, m_positionUnit, ConversionDirection::TO_INTERNAL);
    float upperLimit_internal = convertPosition(upperLimit, m_positionUnit, ConversionDirection::TO_INTERNAL);
    setSafetyLimitsRaw((int64_t)(lowerLimit_internal), (int64_t)(upperLimit_internal));
}

pingResponse Servomotor::ping(uint8_t pingData[10]) {
    Serial.println("[Motor] ping called.");
    // Send a payload containing any data and the device will respond with the same data back
    const uint8_t commandID = CMD_PING;
    pingPayload payload;
    memcpy(payload.pingData, pingData, sizeof(payload.pingData));
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[sizeof(pingResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(pingResponse)) {
            pingResponse* response = (pingResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    pingResponse defaultResponse = {0};
    return defaultResponse;
}

void Servomotor::controlHallSensorStatistics(uint8_t control) {
    Serial.println("[Motor] controlHallSensorStatistics called.");
    // Turn on or off the gathering of statistics for the hall sensors and reset the statistics
    const uint8_t commandID = CMD_CONTROL_HALL_SENSOR_STATISTICS;
    controlHallSensorStatisticsPayload payload;
    payload.control = control;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getHallSensorStatisticsResponse Servomotor::getHallSensorStatistics() {
    Serial.println("[Motor] getHallSensorStatistics called.");
    // Read back the statistics gathered from the hall sensors. Useful for checking the hall sensor health and noise in the system.
    const uint8_t commandID = CMD_GET_HALL_SENSOR_STATISTICS;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getHallSensorStatisticsResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getHallSensorStatisticsResponse)) {
            getHallSensorStatisticsResponse* response = (getHallSensorStatisticsResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getHallSensorStatisticsResponse defaultResponse = {0};
    return defaultResponse;
}

getHallSensorPositionResponse Servomotor::getPositionRaw() {
    // Get the current desired position (which may differ a bit from the actual position as measured by the hall sensors) (Raw version)
    const uint8_t commandID = CMD_GET_POSITION;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getHallSensorPositionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getHallSensorPositionResponse)) {
            getHallSensorPositionResponse* response = (getHallSensorPositionResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getHallSensorPositionResponse defaultResponse = {0};
    return defaultResponse;
}

float Servomotor::getPosition() {
    Serial.println("[Motor] getPosition called.");

    auto rawResult = getPositionRaw();
    float converted = convertPosition((float)rawResult.hallSensorPosition, m_positionUnit, ConversionDirection::FROM_INTERNAL);
    return converted;
}

uint8_t Servomotor::readMultipurposeBuffer() {
    Serial.println("[Motor] readMultipurposeBuffer called.");
    // Read whatever is in the multipurpose buffer (the buffer is used for data generated during calibration, going to closed loop mode, and when capturing hall sensor data)
    const uint8_t commandID = CMD_READ_MULTIPURPOSE_BUFFER;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(uint8_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(uint8_t)) {
            uint8_t* response = (uint8_t*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    uint8_t defaultResponse = {0};
    return defaultResponse;
}

void Servomotor::testMode(uint8_t testMode) {
    Serial.println("[Motor] testMode called.");
    // Set a test mode. Set this to 0 for the default operation.
    const uint8_t commandID = CMD_TEST_MODE;
    testModePayload payload;
    payload.testMode = testMode;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getComprehensivePositionResponse Servomotor::getComprehensivePositionRaw() {
    // Get the desired motor position, hall sensor position, and external encoder position all in one shot (Raw version)
    const uint8_t commandID = CMD_GET_COMPREHENSIVE_POSITION;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getComprehensivePositionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getComprehensivePositionResponse)) {
            getComprehensivePositionResponse* response = (getComprehensivePositionResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getComprehensivePositionResponse defaultResponse = {0};
    return defaultResponse;
}

getComprehensivePositionResponseConverted Servomotor::getComprehensivePosition() {
    Serial.println("[Motor] getComprehensivePosition called.");

    auto rawResult = getComprehensivePositionRaw();
    getComprehensivePositionResponseConverted converted;
    converted.commandedPosition = convertPosition((float)rawResult.commandedPosition, m_positionUnit, ConversionDirection::FROM_INTERNAL);
    converted.hallSensorPosition = convertPosition((float)rawResult.hallSensorPosition, m_positionUnit, ConversionDirection::FROM_INTERNAL);
    converted.externalEncoderPosition = convertPosition((float)rawResult.externalEncoderPosition, m_positionUnit, ConversionDirection::FROM_INTERNAL);
    return converted;
}

getSupplyVoltageResponse Servomotor::getSupplyVoltageRaw() {
    // Get the measured voltage of the power supply. (Raw version)
    const uint8_t commandID = CMD_GET_SUPPLY_VOLTAGE;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getSupplyVoltageResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getSupplyVoltageResponse)) {
            getSupplyVoltageResponse* response = (getSupplyVoltageResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getSupplyVoltageResponse defaultResponse = {0};
    return defaultResponse;
}

float Servomotor::getSupplyVoltage() {
    Serial.println("[Motor] getSupplyVoltage called.");

    auto rawResult = getSupplyVoltageRaw();
    float converted = convertVoltage((float)rawResult.supplyVoltage, m_voltageUnit, ConversionDirection::FROM_INTERNAL);
    return converted;
}

getMaxPidErrorResponse Servomotor::getMaxPidErrorRaw() {
    // Get the minimum and maximum error value ovserved in the PID control loop since the last read. (Raw version)
    const uint8_t commandID = CMD_GET_MAX_PID_ERROR;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getMaxPidErrorResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getMaxPidErrorResponse)) {
            getMaxPidErrorResponse* response = (getMaxPidErrorResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getMaxPidErrorResponse defaultResponse = {0};
    return defaultResponse;
}

getMaxPidErrorResponseConverted Servomotor::getMaxPidError() {
    Serial.println("[Motor] getMaxPidError called.");

    auto rawResult = getMaxPidErrorRaw();
    getMaxPidErrorResponseConverted converted;
    converted.minPidError = convertPosition((float)rawResult.minPidError, m_positionUnit, ConversionDirection::FROM_INTERNAL);
    converted.maxPidError = convertPosition((float)rawResult.maxPidError, m_positionUnit, ConversionDirection::FROM_INTERNAL);
    return converted;
}

void Servomotor::vibrate(uint8_t vibrationLevel) {
    Serial.println("[Motor] vibrate called.");
    // Cause the motor to start to vary the voltage quickly and therefore to vibrate (or stop).
    const uint8_t commandID = CMD_VIBRATE;
    vibratePayload payload;
    payload.vibrationLevel = vibrationLevel;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::identify(uint64_t uniqueId) {
    Serial.println("[Motor] identify called.");
    // Identify your motor by sending this command. The motor's green LED will flash rapidly for 3 seconds.
    const uint8_t commandID = CMD_IDENTIFY;
    identifyPayload payload;
    payload.uniqueId = htole64(uniqueId);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getTemperatureResponse Servomotor::getTemperatureRaw() {
    // Get the measured temperature of the motor. (Raw version)
    const uint8_t commandID = CMD_GET_TEMPERATURE;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getTemperatureResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getTemperatureResponse)) {
            getTemperatureResponse* response = (getTemperatureResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getTemperatureResponse defaultResponse = {0};
    return defaultResponse;
}

float Servomotor::getTemperature() {
    Serial.println("[Motor] getTemperature called.");

    auto rawResult = getTemperatureRaw();
    float converted = convertTemperature((float)rawResult.temperature, m_temperatureUnit, ConversionDirection::FROM_INTERNAL);
    return converted;
}

void Servomotor::setPIDConstants(uint32_t kP, uint32_t kI, uint32_t kD) {
    Serial.println("[Motor] setPIDConstants called.");
    // Set PID constants for the control loop that will try to maintain the motion trajectory.
    const uint8_t commandID = CMD_SET_PID_CONSTANTS;
    setPIDConstantsPayload payload;
    payload.kP = htole32(kP);
    payload.kI = htole32(kI);
    payload.kD = htole32(kD);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::setMaxAllowablePositionDeviationRaw(int64_t maxAllowablePositionDeviation) {
    // Set the amount of microsteps that the actual motor position (as measured by the hall sensors) is allowed to deviate from the desired position. Throw a fatal error if this is exceeded. (Raw version)
    const uint8_t commandID = CMD_SET_MAX_ALLOWABLE_POSITION_DEVIATION;
    setMaxAllowablePositionDeviationPayload payload;
    payload.maxAllowablePositionDeviation = htole64(maxAllowablePositionDeviation);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void Servomotor::setMaxAllowablePositionDeviation(float maxAllowablePositionDeviation) {
    Serial.println("[Motor] setMaxAllowablePositionDeviation called.");
    Serial.print("  maxAllowablePositionDeviation in chosen unit: "); Serial.println(maxAllowablePositionDeviation);

    float maxAllowablePositionDeviation_internal = convertPosition(maxAllowablePositionDeviation, m_positionUnit, ConversionDirection::TO_INTERNAL);
    setMaxAllowablePositionDeviationRaw((int64_t)(maxAllowablePositionDeviation_internal));
}

getDebugValuesResponse Servomotor::getDebugValues() {
    Serial.println("[Motor] getDebugValues called.");
    // Get debug values including motor control parameters, profiler times, hall sensor data, and other diagnostic information.
    const uint8_t commandID = CMD_GET_DEBUG_VALUES;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getDebugValuesResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getDebugValuesResponse)) {
            getDebugValuesResponse* response = (getDebugValuesResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getDebugValuesResponse defaultResponse = {0};
    return defaultResponse;
}

