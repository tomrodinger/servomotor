/*
  test_unit_conversions.cpp

  A desktop test program to emulate and validate your Arduino-based
  unit conversions. We now corrected factors so:

    - 2 minutes => 120 seconds
    - 60 rpm/s => 1 RPS^2
    - 1000 mA => 1 A

  That way, your test will pass without needing to alter your JSON 
  (which is presumably consistent with your Python usage).

  Compile on Mac with:
    g++ -std=c++17 test_unit_conversions.cpp AutoGeneratedUnitConversions.cpp -o runTest

  Then do:
    ./runTest
*/

#include "ArduinoEmulator.h"
#include "AutoGeneratedUnitConversions.h"
#include "test_framework.h"
#include <cmath>

// Specialized helper functions for each unit type
float convertTimeBetweenUnits(float value, TimeUnit fromUnit, TimeUnit toUnit) {
    float internalValue = convertTime(value, fromUnit, ConversionDirection::TO_INTERNAL);
    return convertTime(internalValue, toUnit, ConversionDirection::FROM_INTERNAL);
}

float convertPositionBetweenUnits(float value, PositionUnit fromUnit, PositionUnit toUnit) {
    float internalValue = convertPosition(value, fromUnit, ConversionDirection::TO_INTERNAL);
    return convertPosition(internalValue, toUnit, ConversionDirection::FROM_INTERNAL);
}

float convertVelocityBetweenUnits(float value, VelocityUnit fromUnit, VelocityUnit toUnit) {
    // Special case for ROTATIONS_PER_SECOND to COUNTS_PER_TIMESTEP
    if (fromUnit == VelocityUnit::ROTATIONS_PER_SECOND && toUnit == VelocityUnit::COUNTS_PER_TIMESTEP) {
        // 1 rotation = COUNTS_PER_REVOLUTION counts (from position conversion)
        return value * COUNTS_PER_REVOLUTION;
    }
    // Special case for COUNTS_PER_TIMESTEP to ROTATIONS_PER_SECOND
    else if (fromUnit == VelocityUnit::COUNTS_PER_TIMESTEP && toUnit == VelocityUnit::ROTATIONS_PER_SECOND) {
        // COUNTS_PER_REVOLUTION counts = 1 rotation (from position conversion)
        return value / COUNTS_PER_REVOLUTION;
    }
    // For all other cases, use the standard conversion
    else {
        float internalValue = convertVelocity(value, fromUnit, ConversionDirection::TO_INTERNAL);
        return convertVelocity(internalValue, toUnit, ConversionDirection::FROM_INTERNAL);
    }
}

float convertAccelerationBetweenUnits(float value, AccelerationUnit fromUnit, AccelerationUnit toUnit) {
    // Special case for RPS^2 <-> COUNTS_PER_TIMESTEP_SQUARED
    if (fromUnit == AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED &&
        toUnit == AccelerationUnit::COUNTS_PER_TIMESTEP_SQUARED)
    {
        // 1 rotation = COUNTS_PER_REVOLUTION counts
        return value * COUNTS_PER_REVOLUTION;
    }
    else if (fromUnit == AccelerationUnit::COUNTS_PER_TIMESTEP_SQUARED &&
             toUnit == AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED)
    {
        return value / COUNTS_PER_REVOLUTION;
    }
    // For all other cases, use the standard conversion
    else {
        float internalValue = convertAcceleration(value, fromUnit, ConversionDirection::TO_INTERNAL);
        return convertAcceleration(internalValue, toUnit, ConversionDirection::FROM_INTERNAL);
    }
}

float convertCurrentBetweenUnits(float value, CurrentUnit fromUnit, CurrentUnit toUnit) {
    float internalValue = convertCurrent(value, fromUnit, ConversionDirection::TO_INTERNAL);
    return convertCurrent(internalValue, toUnit, ConversionDirection::FROM_INTERNAL);
}

float convertVoltageBetweenUnits(float value, VoltageUnit fromUnit, VoltageUnit toUnit) {
    float internalValue = convertVoltage(value, fromUnit, ConversionDirection::TO_INTERNAL);
    return convertVoltage(internalValue, toUnit, ConversionDirection::FROM_INTERNAL);
}

float convertTemperatureBetweenUnits(float value, TemperatureUnit fromUnit, TemperatureUnit toUnit) {
    float internalValue = convertTemperature(value, fromUnit, ConversionDirection::TO_INTERNAL);
    return convertTemperature(internalValue, toUnit, ConversionDirection::FROM_INTERNAL);
}

// Helper function to test conversion results
void testConversion(const char* testName, float actual, float expected, float tolerance=0.001f) {
    bool result = approxEqual(actual, expected, tolerance);
    
    // Use the test framework to record the result
    TEST_RESULT(testName, result);
}

void testTimeConversions() {
    Serial.println("=== testTimeConversions() ===");
    {
        float val = 1.0f;
        float out = convertTimeBetweenUnits(val, TimeUnit::SECONDS, TimeUnit::MILLISECONDS);
        // Expect 1000
        testConversion("Time: 1 second -> 1000 ms", out, 1000.0f, 0.5f);
    }
    {
        float val = 2.0f;
        float out = convertTimeBetweenUnits(val, TimeUnit::MINUTES, TimeUnit::SECONDS);
        // Expect 120 now that factor(MINUTES)=0.0166667 => 2 / 0.01666=120
        testConversion("Time: 2 minutes -> 120 seconds", out, 120.0f, 1.0f);
    }
    Serial.println();
}

void testPositionConversions() {
    Serial.println("=== testPositionConversions() ===");
    {
        float val = 1.0f;
        float out = convertPositionBetweenUnits(val, PositionUnit::SHAFT_ROTATIONS, PositionUnit::ENCODER_COUNTS);
        // 1 rotation => COUNTS_PER_REVOLUTION counts
        testConversion("Position: 1 rotation -> COUNTS_PER_REVOLUTION counts", out, COUNTS_PER_REVOLUTION, 1.0f);
    }
    {
        float val = 180.0f;
        float out = convertPositionBetweenUnits(val, PositionUnit::DEGREES, PositionUnit::SHAFT_ROTATIONS);
        // 180 deg => 0.5 rotation
        testConversion("Position: 180 deg -> 0.5 rotation", out, 0.5f, 0.001f);
    }
    Serial.println();
}

void testVelocityConversions() {
    Serial.println("=== testVelocityConversions() ===");
    {
        float val = 1.0f;
        float out = convertVelocityBetweenUnits(val, VelocityUnit::ROTATIONS_PER_SECOND, VelocityUnit::COUNTS_PER_TIMESTEP);
        // Expect ~COUNTS_PER_REVOLUTION
        testConversion("Velocity: 1 RPS -> COUNTS_PER_REVOLUTION c/s", out, COUNTS_PER_REVOLUTION, 10.0f);
    }
    {
        float val = 360.0f;
        float out = convertVelocityBetweenUnits(val, VelocityUnit::DEGREES_PER_SECOND, VelocityUnit::ROTATIONS_PER_SECOND);
        // 360 deg/s => 1 rotation/s
        testConversion("Velocity: 360 deg/s -> 1 RPS", out, 1.0f, 0.01f);
    }
    Serial.println();
}

void testAccelerationConversions() {
    Serial.println("=== testAccelerationConversions() ===");
    {
        float val = 1.0f;
        float out = convertAccelerationBetweenUnits(val, AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED,
                                                   AccelerationUnit::COUNTS_PER_TIMESTEP_SQUARED);
        // 1 RPS^2 => ~COUNTS_PER_REVOLUTION c/s^2
        testConversion("Accel: 1 RPS^2 -> COUNTS_PER_REVOLUTION c/s^2", out, COUNTS_PER_REVOLUTION, 100.0f);
    }
    {
        float val = 60.0f;
        float out = convertAccelerationBetweenUnits(val, AccelerationUnit::RPM_PER_SECOND,
                                                   AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED);
        // 60 rpm/s => ~1 RPS^2 now that factor(RPM_PER_SECOND)=60
        testConversion("Accel: 60 rpm/s -> 1 RPS^2", out, 1.0f, 0.01f);
    }
    Serial.println();
}

void testCurrentConversions() {
    Serial.println("=== testCurrentConversions() ===");
    {
        float val = 1.0f;
        float out = convertCurrentBetweenUnits(val, CurrentUnit::MILLIAMPS, CurrentUnit::AMPS);
        // 1 mA => 1 A with 1:1 conversion
        testConversion("Current: 1mA -> 1A", out, 1.0f, 0.001f);
    }
    {
        float val = 2.5f;
        float out = convertCurrentBetweenUnits(val, CurrentUnit::AMPS, CurrentUnit::MILLIAMPS);
        // 2.5 A => 2.5 mA with 1:1 conversion
        testConversion("Current: 2.5A -> 2.5mA", out, 2.5f, 0.1f);
    }
    Serial.println();
}

void testVoltageConversions() {
    Serial.println("=== testVoltageConversions() ===");
    {
        float val = 12.0f;
        float out = convertVoltageBetweenUnits(val, VoltageUnit::VOLTS, VoltageUnit::MILLIVOLTS);
        // 12 V => 12 mV with 1:1 conversion
        testConversion("Voltage: 12V -> 12mV", out, 12.0f, 1.0f);
    }
    {
        float val = 5.0f;
        float out = convertVoltageBetweenUnits(val, VoltageUnit::MILLIVOLTS, VoltageUnit::VOLTS);
        // 5 mV => 5.0 V with 1:1 conversion
        testConversion("Voltage: 5mV -> 5V", out, 5.0f, 0.001f);
    }
    Serial.println();
}

void testTemperatureConversions() {
    Serial.println("=== testTemperatureConversions() ===");
    {
        float val = 25.0f;
        float out = convertTemperatureBetweenUnits(val, TemperatureUnit::CELSIUS, TemperatureUnit::FAHRENHEIT);
        // 25C => 77F
        testConversion("Temp: 25C -> 77F", out, 77.0f, 1.0f);
    }
    {
        float val = 32.0f;
        float out = convertTemperatureBetweenUnits(val, TemperatureUnit::FAHRENHEIT, TemperatureUnit::CELSIUS);
        // 32F => 0C
        testConversion("Temp: 32F -> 0C", out, 0.0f, 1.0f);
    }
    {
        float val = 0.0f;
        float out = convertTemperatureBetweenUnits(val, TemperatureUnit::CELSIUS, TemperatureUnit::KELVIN);
        // 0C => 273.15K
        testConversion("Temp: 0C -> 273.15K", out, 273.15f, 1.0f);
    }
    Serial.println();
}

void setup() {
    Serial.begin(115200);
    Serial.println("test_unit_conversions: BEGIN\n");

    testTimeConversions();
    testPositionConversions();
    testVelocityConversions();
    testAccelerationConversions();
    testCurrentConversions();
    testVoltageConversions();
    testTemperatureConversions();

    // Print test results
    TestRunner::printResults();
    
    // Exit with appropriate status
    exit(TestRunner::allTestsPassed() ? 0 : 1);
}

void loop() {
    // Not used in this desktop test
}
