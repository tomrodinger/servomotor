#!/usr/bin/env python3

import json
import re
from datetime import datetime
import sys

# Paths to JSON files
MOTOR_COMMANDS_JSON_FILE = "/Users/tom/Documents/Move_the_Needle/Servomotor/python_programs/servomotor/motor_commands.json"
DATA_TYPES_JSON_FILE = "/Users/tom/Documents/Move_the_Needle/Servomotor/python_programs/servomotor/data_types.json"
COMMANDS_H_FILE = "Commands.h"
SERVOMOTOR_CPP_FILE = "ServoMotor.cpp"
SERVOMOTOR_H_FILE = "ServoMotor.h"

def generate_commands_header(json_file, header_file):
    with open(json_file, 'r') as f:
        commands_data = json.load(f)

    # Get current date and time
    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    with open(header_file, 'w') as hf:
        hf.write('// Commands.h\n')
        hf.write('// This file was autogenerated by generate_command_code.py on {}\n'.format(now))
        hf.write('// Do not edit this file manually.\n\n')
        hf.write('#ifndef COMMANDS_H\n')
        hf.write('#define COMMANDS_H\n\n')
        hf.write('enum CommandID {\n')
        
        for command in commands_data:
            command_name = command['CommandString'].upper()
            command_name = re.sub(r'[^a-zA-Z0-9]+', '_', command_name)
            command_id = command['CommandEnum']
            hf.write('    CMD_{} = {},\n'.format(command_name, command_id))
        
        hf.write('};\n\n')
        hf.write('#endif // COMMANDS_H\n')
    print('Generated {} successfully.'.format(header_file))

def generate_servo_motor_files(json_file, data_types_file, header_file, source_file):
    with open(json_file, 'r') as f:
        commands_data = json.load(f)

    with open(data_types_file, 'r') as f:
        data_types_data = json.load(f)

    commands = commands_data
    data_types = data_types_data

    # Create a mapping from data_type to its properties
    data_type_map = {dt['data_type']: dt for dt in data_types}

    # Get current date and time
    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Mappings for special function and struct names
    function_name_mappings = {
        'Disable MOSFETs': 'disableMosfets',
        'Enable MOSFETs': 'enableMosfets',
        'Get n queued items': 'getNumberOfQueuedItems',
        'Get position': 'getPosition',
        'Get status': 'getStatus',
        'System reset': 'systemReset',
        'Set PID constants': 'setPIDConstants',
    }

    response_struct_mappings = {
        'Get status': ('StatusResponse', ['statusFlags', 'fatalErrorCode']),
        'Get position': 'int64_t',
        'Get n queued items': 'uint8_t',
    }

    reserved_words = {
        # Include C++ reserved words and built-in types
        'alignas', 'alignof', 'and', 'and_eq', 'asm', 'atomic_cancel', 'atomic_commit',
        'atomic_noexcept', 'auto', 'bitand', 'bitor', 'bool', 'break', 'case', 'catch',
        'char', 'char8_t', 'char16_t', 'char32_t', 'class', 'compl', 'concept', 'const',
        'consteval', 'constexpr', 'const_cast', 'continue', 'co_await', 'co_return',
        'co_yield', 'decltype', 'default', 'delete', 'do', 'double', 'dynamic_cast', 'else',
        'enum', 'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend', 'goto',
        'if', 'inline', 'int', 'long', 'mutable', 'namespace', 'new', 'noexcept', 'not',
        'not_eq', 'nullptr', 'operator', 'or', 'or_eq', 'private', 'protected', 'public',
        'register', 'reinterpret_cast', 'requires', 'return', 'short', 'signed', 'sizeof',
        'static', 'static_assert', 'static_cast', 'struct', 'switch', 'template', 'this',
        'thread_local', 'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union',
        'unsigned', 'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while', 'xor',
        'xor_eq'
    }

    # Generate ServoMotor.h
    with open(header_file, 'w') as hf:
        hf.write('// ServoMotor.h\n')
        hf.write('// This file was autogenerated by generate_command_code.py on {}\n'.format(now))
        hf.write('// Do not edit this file manually.\n\n')
        hf.write('#ifndef SERVOMOTOR_H\n')
        hf.write('#define SERVOMOTOR_H\n\n')
        hf.write('#include <Arduino.h>\n')
        hf.write('#include "Communication.h"\n')
        hf.write('#include "Commands.h"\n')
        hf.write('#include "DataTypes.h"\n')
        hf.write('#include "Utils.h"\n\n')

        # Include necessary payload and response structures
        hf.write('// Payload and Response Structures\n\n')
        for command in commands:
            func_name = format_command_name(command['CommandString'], function_name_mappings)

            # Generate payload structures
            input_params = extract_parameters(command.get('Input'), command['CommandString'], data_type_map, reserved_words)
            if input_params:
                struct_name = '{}Payload'.format(func_name)
                hf.write('// Structure for {} command payload\n'.format(command['CommandString']))
                hf.write('typedef struct __attribute__((__packed__)) {\n')
                for param in input_params:
                    param_type = format_struct_member_type(param)
                    param_name = param['name']
                    if param.get('array_size') and param['array_size'] > 1:
                        hf.write('    {} {}[{}];\n'.format(param_type, param_name, param['array_size']))
                    else:
                        hf.write('    {} {};\n'.format(param_type, param_name))
                hf.write('}} {};\n\n'.format(struct_name))

            # Generate response structures
            if command.get('Output') and command['Output'] != 'success_response':
                output_params = extract_parameters(command.get('Output'), command['CommandString'], data_type_map, reserved_words)
                if len(output_params) == 1 and isinstance(response_struct_mappings.get(command['CommandString']), str):
                    continue  # Skip struct definition if returning a single value
                struct_mapping = response_struct_mappings.get(command['CommandString'])
                if struct_mapping and isinstance(struct_mapping, tuple):
                    struct_name, param_names = struct_mapping
                else:
                    struct_name = '{}Response'.format(func_name)
                    param_names = None
                hf.write('// Structure for {} command response\n'.format(command['CommandString']))
                hf.write('typedef struct __attribute__((__packed__)) {\n')
                for idx, param in enumerate(output_params):
                    param_type = format_struct_member_type(param)
                    param_name = param['name'] if not param_names else param_names[idx]
                    if param.get('array_size') and param['array_size'] > 1:
                        hf.write('    {} {}[{}];\n'.format(param_type, param_name, param['array_size']))
                    else:
                        hf.write('    {} {};\n'.format(param_type, param_name))
                hf.write('}} {};\n\n'.format(struct_name))

        # Define the ServoMotor class
        hf.write('class ServoMotor {\n')
        hf.write('public:\n')
        hf.write('    ServoMotor(uint8_t alias, HardwareSerial& serialPort);\n')
        hf.write('    void setAlias(uint8_t new_alias);\n')
        hf.write('    uint8_t getAlias();\n')
        hf.write('    void openSerialPort();\n')
        for command in commands:
            func_name = format_command_name(command['CommandString'], function_name_mappings)
            input_params = extract_parameters(command.get('Input'), command['CommandString'], data_type_map, reserved_words)
            params = []
            for param in input_params:
                param_type = format_function_param_type(param)
                params.append('{}'.format(param_type))
            if command.get('Output') and command['Output'] != 'success_response':
                output_params = extract_parameters(command.get('Output'), command['CommandString'], data_type_map, reserved_words)
                if len(output_params) == 1 and isinstance(response_struct_mappings.get(command['CommandString']), str):
                    return_type = format_return_type(output_params[0])
                else:
                    struct_mapping = response_struct_mappings.get(command['CommandString'])
                    if struct_mapping and isinstance(struct_mapping, tuple):
                        struct_name = struct_mapping[0]
                    else:
                        struct_name = '{}Response'.format(func_name)
                    return_type = struct_name
            else:
                return_type = 'void'
            hf.write('    {} {}({});\n'.format(return_type, func_name, ', '.join(params)))
            
            # Add getAnotherResponse function for commands with multiple responses
            if command.get('MultipleResponses'):
                hf.write('    {} {}GetAnotherResponse();\n'.format(return_type, func_name))

        hf.write('    int getError() const;\n\n')
        hf.write('private:\n')
        hf.write('    uint8_t _alias;\n')
        hf.write('    Communication _comm;\n')
        hf.write('    int _errno;\n')
        hf.write('};\n\n')
        hf.write('#endif // SERVOMOTOR_H\n')

    # Generate ServoMotor.cpp
    with open(source_file, 'w') as sf:
        sf.write('// ServoMotor.cpp\n')
        sf.write('// This file was autogenerated by generate_command_code.py on {}\n'.format(now))
        sf.write('// Do not edit this file manually.\n\n')
        sf.write('#include "ServoMotor.h"\n')
        sf.write('#include "Commands.h"\n')
        sf.write('#include "Utils.h"\n\n')
        sf.write('ServoMotor::ServoMotor(uint8_t alias, HardwareSerial& serialPort)\n')
        sf.write('    : _alias(alias), _comm(serialPort), _errno(0) {}\n\n')
        sf.write('void ServoMotor::setAlias(uint8_t new_alias) {\n')
        sf.write('    _alias = new_alias;\n')
        sf.write('}\n\n')
        sf.write('uint8_t ServoMotor::getAlias() {\n')
        sf.write('    return _alias;\n')
        sf.write('}\n\n')
        sf.write('void ServoMotor::openSerialPort() {\n')
        sf.write('    _comm.openSerialPort();\n')
        sf.write('}\n\n')
        sf.write('int ServoMotor::getError() const {\n')
        sf.write('    return _errno;\n')
        sf.write('}\n\n')

        # Implementations of command functions
        for command in commands:
            func_name = format_command_name(command['CommandString'], function_name_mappings)
            input_params = extract_parameters(command.get('Input'), command['CommandString'], data_type_map, reserved_words)
            params = []
            for param in input_params:
                param_type = format_function_param_type(param)
                params.append('{}'.format(param_type))

            # Determine the return type
            if command.get('Output') and command['Output'] != 'success_response':
                output_params = extract_parameters(command.get('Output'), command['CommandString'], data_type_map, reserved_words)
                if len(output_params) == 1 and isinstance(response_struct_mappings.get(command['CommandString']), str):
                    return_type = format_return_type(output_params[0])
                else:
                    struct_mapping = response_struct_mappings.get(command['CommandString'])
                    if struct_mapping and isinstance(struct_mapping, tuple):
                        struct_name = struct_mapping[0]
                    else:
                        struct_name = '{}Response'.format(func_name)
                    return_type = struct_name
            else:
                return_type = 'void'

            # Function signature
            sf.write('{} ServoMotor::{}({}) {{\n'.format(return_type, func_name, ', '.join(params)))

            # Command ID
            sf.write('    // {}\n'.format(command['Description']))
            command_id = command['CommandEnum']
            sf.write('    const uint8_t commandID = {};\n'.format(command_id))

            # Handle payload
            if input_params:
                struct_name = '{}Payload'.format(func_name)
                sf.write('    {} payload;\n'.format(struct_name))
                for param in input_params:
                    if param.get('array_size') and param['array_size'] > 1:
                        # For arrays
                        sf.write('    memcpy(payload.{}, {}, sizeof(payload.{}));\n'.format(param['name'], param['name'], param['name']))
                    elif '*' in param['type']:
                        # Pointer types
                        sf.write('    // Handle pointer type\n')
                        sf.write('    // Assuming payload.{} is an array of known size\n'.format(param['name']))
                        sf.write('    memcpy(payload.{}, {}, sizeof(payload.{}));\n'.format(param['name'], param['name'], param['name']))
                    elif is_integer_type(param['type']) and get_size_of_type(param['type'], data_type_map) > 1:
                        endian_func = 'htole{}'.format(get_size_of_type(param['type'], data_type_map)*8)
                        sf.write('    payload.{} = {}({});\n'.format(param['name'], endian_func, param['name']))
                    else:
                        sf.write('    payload.{} = {};\n'.format(param['name'], param['name']))
                sf.write('    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));\n')
            else:
                sf.write('    _comm.sendCommand(_alias, commandID, nullptr, 0);\n')

            # Attempt to receive a response
            sf.write('\n    // Attempt to receive a response\n')
            if command.get('Output') and command['Output'] != 'success_response':
                output_params = extract_parameters(command.get('Output'), command['CommandString'], data_type_map, reserved_words)
                if len(output_params) == 1 and isinstance(response_struct_mappings.get(command['CommandString']), str):
                    # Single value response
                    param = output_params[0]
                    sf.write('    uint8_t buffer[sizeof({})];\n'.format(param['type']))
                    sf.write('    uint16_t receivedSize;\n')
                    sf.write('    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);\n')
                    sf.write('    if (_errno == 0) {\n')
                    sf.write('        if (receivedSize == sizeof({})) {{\n'.format(param['type']))
                    if is_integer_type(param['type']) and get_size_of_type(param['type'], data_type_map) > 1:
                        endian_func = 'le{}toh'.format(get_size_of_type(param['type'], data_type_map)*8)
                        sf.write('            {} value = {}(*({}*)buffer);\n'.format(param['type'], endian_func, param['type']))
                    else:
                        sf.write('            {} value = *({}*)buffer;\n'.format(param['type'], param['type']))
                    sf.write('            return value;\n')
                    sf.write('        } else {\n')
                    sf.write('            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;\n')
                    sf.write('        }\n')
                    sf.write('    }\n')
                    sf.write('    return {}; // Return default value\n'.format(get_default_value(param['type'])))
                else:
                    # Response expected with struct
                    struct_mapping = response_struct_mappings.get(command['CommandString'])
                    if struct_mapping and isinstance(struct_mapping, tuple):
                        struct_name = struct_mapping[0]
                        param_names = struct_mapping[1]
                    else:
                        struct_name = '{}Response'.format(func_name)
                        param_names = None
                    sf.write('    uint8_t buffer[sizeof({})];\n'.format(struct_name))
                    sf.write('    uint16_t receivedSize;\n')
                    sf.write('    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);\n')
                    sf.write('    if (_errno == 0) {\n')
                    sf.write('        if (receivedSize == sizeof({})) {{\n'.format(struct_name))
                    sf.write('            {}* response = ({}*)buffer;\n'.format(struct_name, struct_name))
                    # Handle endianness conversion
                    sf.write('            {} result;\n'.format(struct_name))
                    for idx, param in enumerate(output_params):
                        param_name = param['name']
                        if param_names:
                            param_name = param_names[idx]
                        if is_integer_type(param['type']) and get_size_of_type(param['type'], data_type_map) > 1:
                            endian_func = 'le{}toh'.format(get_size_of_type(param['type'], data_type_map)*8)
                            sf.write('            result.{} = {}(response->{});\n'.format(param_name, endian_func, param_name))
                        elif param.get('array_size') and param['array_size'] > 1:
                            sf.write('            memcpy(result.{}, response->{}, sizeof(result.{}));\n'.format(param_name, param_name, param_name))
                        else:
                            sf.write('            result.{} = response->{};\n'.format(param_name, param_name))
                    sf.write('            return result;\n')
                    sf.write('        } else {\n')
                    sf.write('            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;\n')
                    sf.write('        }\n')
                    sf.write('    }\n')
                    sf.write('    return {}; // Return default value\n'.format(struct_name + '()'))
            else:
                if 'system reset' in command['CommandString'].lower():
                    sf.write('    // No response expected for system reset\n')
                    sf.write('    _errno = 0;\n')
                else:
                    sf.write('    uint8_t buffer[1]; // No payload expected\n')
                    sf.write('    uint16_t receivedSize;\n')
                    sf.write('    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);\n')
            sf.write('}\n\n')

            # Generate getAnotherResponse function for commands with multiple responses
            if command.get('MultipleResponses'):
                sf.write('{} ServoMotor::{}GetAnotherResponse() {{\n'.format(return_type, func_name))
                sf.write('    // Attempt to receive another response from previously sent {} command\n'.format(command['CommandString']))
                if command.get('Output') and command['Output'] != 'success_response':
                    output_params = extract_parameters(command.get('Output'), command['CommandString'], data_type_map, reserved_words)
                    struct_mapping = response_struct_mappings.get(command['CommandString'])
                    if struct_mapping and isinstance(struct_mapping, tuple):
                        struct_name = struct_mapping[0]
                        param_names = struct_mapping[1]
                    else:
                        struct_name = '{}Response'.format(func_name)
                        param_names = None
                    sf.write('    uint8_t buffer[sizeof({})];\n'.format(struct_name))
                    sf.write('    uint16_t receivedSize;\n')
                    sf.write('    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);\n')
                    sf.write('    if (_errno == 0) {\n')
                    sf.write('        if (receivedSize == sizeof({})) {{\n'.format(struct_name))
                    sf.write('            {}* response = ({}*)buffer;\n'.format(struct_name, struct_name))
                    sf.write('            {} result;\n'.format(struct_name))
                    for idx, param in enumerate(output_params):
                        param_name = param['name']
                        if param_names:
                            param_name = param_names[idx]
                        if is_integer_type(param['type']) and get_size_of_type(param['type'], data_type_map) > 1:
                            endian_func = 'le{}toh'.format(get_size_of_type(param['type'], data_type_map)*8)
                            sf.write('            result.{} = {}(response->{});\n'.format(param_name, endian_func, param_name))
                        elif param.get('array_size') and param['array_size'] > 1:
                            sf.write('            memcpy(result.{}, response->{}, sizeof(result.{}));\n'.format(param_name, param_name, param_name))
                        else:
                            sf.write('            result.{} = response->{};\n'.format(param_name, param_name))
                    sf.write('            return result;\n')
                    sf.write('        } else {\n')
                    sf.write('            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;\n')
                    sf.write('        }\n')
                    sf.write('    }\n')
                    sf.write('    return {}; // Return default value\n'.format(struct_name + '()'))
                sf.write('}\n\n')

    print('Generated {} and {} successfully.'.format(header_file, source_file))

def extract_parameters(param_list, command_string, data_type_map, reserved_words):
    if not param_list or param_list == 'success_response':
        return []
    params = []
    used_names = set()
    index = 1
    for item in param_list:
        description = item.get('Description', '')
        parameter_name = item.get('ParameterName')
        # Extract type and description
        match = re.match(r'(\w+):\s*(.*)', description)
        if match:
            type_str = match.group(1)
            desc = match.group(2)
            # Use ParameterName if available
            if parameter_name:
                param_name = parameter_name
            else:
                # Try to extract parameter name from the description
                param_name = extract_param_name(desc, index)
            # Ensure the parameter name is unique within this scope
            param_name = make_unique_name(param_name, used_names)
            used_names.add(param_name)
            # Clean up type
            mapped_type = map_type(type_str, data_type_map)
            if isinstance(mapped_type, tuple):
                base_type, array_size = mapped_type
                type_name = base_type
            else:
                type_name = mapped_type
                array_size = None
            params.append({'type': type_name, 'name': param_name, 'array_size': array_size, 'description': desc, 'original_type': type_str})
            index += 1
        else:
            # Handle special types or unknown formats
            continue
    return params

def extract_param_name(description, index):
    # Remove leading articles and stop words
    stop_words = {'the', 'a', 'an', 'this', 'that', 'these', 'those', 'his', 'her', 'its', 'of', 'and', 'or', 'to', 'with', 'for', 'from'}
    words = description.strip().split()
    # Remove stop words from the beginning
    while words and words[0].lower() in stop_words:
        words.pop(0)
    # If the description contains 'parameter_name: rest of description'
    name_match = re.match(r'([\w_]+)\s*[:\-]\s*(.*)', ' '.join(words))
    if name_match:
        param_name = name_match.group(1)
    elif words:
        param_name = words[0]
    else:
        param_name = f'param{index}'
    # Clean up the parameter name
    param_name = re.sub(r'\W|^(?=\d)', '_', param_name)
    return param_name

def make_unique_name(name, used_names):
    original_name = name
    count = 2
    while name in used_names or is_reserved_word(name):
        name = f"{original_name}_{count}"
        count +=1
    return name

def is_reserved_word(word):
    reserved_words = {
        # Include C++ reserved words and built-in types
        'alignas', 'alignof', 'and', 'and_eq', 'asm', 'atomic_cancel', 'atomic_commit',
        'atomic_noexcept', 'auto', 'bitand', 'bitor', 'bool', 'break', 'case', 'catch',
        'char', 'char8_t', 'char16_t', 'char32_t', 'class', 'compl', 'concept', 'const',
        'consteval', 'constexpr', 'const_cast', 'continue', 'co_await', 'co_return',
        'co_yield', 'decltype', 'default', 'delete', 'do', 'double', 'dynamic_cast', 'else',
        'enum', 'explicit', 'export', 'extern', 'false', 'float', 'for', 'friend', 'goto',
        'if', 'inline', 'int', 'long', 'mutable', 'namespace', 'new', 'noexcept', 'not',
        'not_eq', 'nullptr', 'operator', 'or', 'or_eq', 'private', 'protected', 'public',
        'register', 'reinterpret_cast', 'requires', 'return', 'short', 'signed', 'sizeof',
        'static', 'static_assert', 'static_cast', 'struct', 'switch', 'template', 'this',
        'thread_local', 'throw', 'true', 'try', 'typedef', 'typeid', 'typename', 'union',
        'unsigned', 'using', 'virtual', 'void', 'volatile', 'wchar_t', 'while', 'xor',
        'xor_eq'
    }
    return word in reserved_words

def map_type(type_str, data_type_map):
    standard_type_map = {
        'i8': 'int8_t',
        'u8': 'uint8_t',
        'i16': 'int16_t',
        'u16': 'uint16_t',
        'i32': 'int32_t',
        'u32': 'uint32_t',
        'i64': 'int64_t',
        'u64': 'uint64_t',
        'float': 'float',
        'double': 'double',
        'string8': ('char', 8),
        'string_null_term': ('char', 32),  # Assuming maximum 32 characters
        'u24_version_number': 'uint32_t',
        'u32_version_number': 'uint32_t',
        'u64_unique_id': 'uint64_t',
        'crc32': 'uint32_t',
        'u48': 'uint64_t',  # Map u48 to uint64_t
    }

    if type_str in standard_type_map:
        return standard_type_map[type_str]
    elif type_str in data_type_map:
        dt_info = data_type_map[type_str]
        size = dt_info['size']
        if size is not None and size > 0:
            if size == 1:
                # Single-byte data
                return 'uint8_t'
            else:
                return ('uint8_t', size)
        else:
            # Variable-sized data, assume pointer
            return 'uint8_t*'
    else:
        return 'uint8_t'  # Default to uint8_t

def format_struct_member_type(param):
    return param['type']

def format_function_param_type(param):
    if param.get('array_size') and param['array_size'] > 1:
        return '{} {}[{}]'.format(param['type'], param['name'], param['array_size'])
    elif param.get('array_size') == 'variable':
        return '{}* {}'.format(param['type'], param['name'])
    else:
        return '{} {}'.format(param['type'], param['name'])

def format_return_type(param):
    if param.get('array_size') and param['array_size'] > 1:
        return '{}[{}]'.format(param['type'], param['array_size'])
    else:
        return '{}'.format(param['type'])

def is_integer_type(type_name):
    integer_types = {
        'int8_t', 'uint8_t',
        'int16_t', 'uint16_t',
        'int32_t', 'uint32_t',
        'int64_t', 'uint64_t',
    }
    return type_name in integer_types

def get_size_of_type(type_name, data_type_map, array_size=None):
    sizes = {
        'int8_t': 1,
        'uint8_t': 1,
        'int16_t': 2,
        'uint16_t': 2,
        'int32_t': 4,
        'uint32_t': 4,
        'int64_t': 8,
        'uint64_t': 8,
        'float': 4,
        'double': 8,
        'char': 1,
    }
    base_type = type_name.strip('*')
    if base_type in sizes:
        base_size = sizes[base_type]
    else:
        # For unknown types, default to 1
        base_size = 1

    if array_size:
        return base_size * array_size
    else:
        return base_size

def get_default_value(type_name):
    # Return a default value based on type
    if 'int' in type_name or 'float' in type_name or 'double' in type_name:
        return '0'
    elif '*' in type_name or '[' in type_name:
        return 'nullptr'
    else:
        return '{}()'  # Default constructor

def format_command_name(command_string, mappings):
    if command_string in mappings:
        return mappings[command_string]
    else:
        command_string = command_string.strip()
        command_string = re.sub(r'[^a-zA-Z0-9]+', ' ', command_string)
        words = command_string.strip().split()
        if not words:
            return ''
        func_name = words[0].lower() + ''.join(word.capitalize() for word in words[1:])
        return func_name

# This function will back uo the specified set of files in the given list
# The file name of the backup should be the original name with the following appended:
# {ORIGINAL_FILE_NAME}.{TIME_STAMP}.bak
# where {ORIGINAL_FILE_NAME} is the name of the original file and {TIME_STAMP} is the current time in the format YYYY-MM-DD-HH-MM-SS
def back_up_files(files):
    for file in files:
        backup_filename = f"{file}.{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}.bak"
        with open(file, 'r') as f:
            contents = f.read()
        with open(backup_filename, 'w') as f:
            f.write(contents)
        print(f"Backed up {file} to {backup_filename}")

if __name__ == '__main__':
    # Let the user know which foles will be overwritten and ask the user to confirm before generating code, unless the -y command line option was given
    print("This script will generate the following files:")
    print(f"  {COMMANDS_H_FILE}")
    print(f"  {SERVOMOTOR_CPP_FILE}")
    print(f"  {SERVOMOTOR_H_FILE}")
    # Now, check for the --no-backups option to see if we need to back up the files
    if '--no-backup' not in sys.argv:
        print("The existing files will be backed up and then overwritten. You can give the --no-backup command line option to not make any backups.")
        backup_the_files = True
    else:
        print("The --no-backup command line option was given. No backups will be made.")
        backup_the_files = False
    # Now, check for the -y option
    if '-y' in sys.argv:
        print("The -y command line option was given. Skipping the prompt and promptly going ahead with the generation.")
    else:
        print("You can give the -y command line option to skip the following prompt.")
        print("Do you want to continue? (y/n)")
        response = input()
        if response.lower() != 'y':
            print("Exiting.")
            exit(0)
    if backup_the_files:
        back_up_files([COMMANDS_H_FILE, SERVOMOTOR_CPP_FILE, SERVOMOTOR_H_FILE])
    generate_commands_header(MOTOR_COMMANDS_JSON_FILE, COMMANDS_H_FILE)
    generate_servo_motor_files(
        MOTOR_COMMANDS_JSON_FILE,
        DATA_TYPES_JSON_FILE,
        SERVOMOTOR_H_FILE,
        SERVOMOTOR_CPP_FILE
    )

