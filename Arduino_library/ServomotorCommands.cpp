// ServoMotor.cpp
// This file was autogenerated by generate_command_code.py on 2025-01-02 19:37:46
// Do not edit this file manually.

#include "ServomotorCommands.h"
#include "Commands.h"
#include "Utils.h"
#include "Communication.h"

static bool Serial1_initialized = false;

ServoMotor::ServoMotor(uint8_t alias, HardwareSerial& serialPort)
    : _alias(alias), _comm(serialPort), _errno(0),
      m_positionUnit(PositionUnit::SHAFT_ROTATIONS),
      m_timeUnit(TimeUnit::SECONDS) {
    openSerialPort();
}

void ServoMotor::setAlias(uint8_t new_alias) {
    _alias = new_alias;
}

uint8_t ServoMotor::getAlias() {
    return _alias;
}

void ServoMotor::openSerialPort() {
    _comm.openSerialPort();
}

int ServoMotor::getError() const {
    return _errno;
}

void ServoMotor::setPositionUnit(PositionUnit unit) {
    m_positionUnit = unit;
    Serial.print("[Motor] setPositionUnit to ");
    switch(unit) {
        case PositionUnit::SHAFT_ROTATIONS: Serial.println("SHAFT_ROTATIONS"); break;
        case PositionUnit::DEGREES:         Serial.println("DEGREES"); break;
        case PositionUnit::RADIANS:         Serial.println("RADIANS"); break;
        case PositionUnit::ENCODER_COUNTS:  Serial.println("ENCODER_COUNTS"); break;
    }
}

void ServoMotor::setTimeUnit(TimeUnit unit) {
    m_timeUnit = unit;
    Serial.print("[Motor] setTimeUnit to ");
    switch(unit) {
        case TimeUnit::SECONDS:      Serial.println("SECONDS"); break;
        case TimeUnit::MILLISECONDS: Serial.println("MILLISECONDS"); break;
        case TimeUnit::MINUTES:      Serial.println("MINUTES"); break;
        case TimeUnit::TIMESTEPS:    Serial.println("TIMESTEPS"); break;
    }
}

void ServoMotor::disableMosfets() {
    // Disables the MOSFETS (note that MOSFETs are disabled after initial power on).
    const uint8_t commandID = 0;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::enableMosfets() {
    // Enables the MOSFETS.
    const uint8_t commandID = 1;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::trapezoidMove(float distance, float duration) {
    Serial.println("[Motor] trapezoidMove called.");
    Serial.print("  distance in chosen unit: ");
    Serial.println(distance);
    Serial.print("  time in chosen unit: ");
    Serial.println(duration);

    // Convert from user units to internal units
    float distance_internal = convertPosition(distance, m_positionUnit, PositionUnit::ENCODER_COUNTS);
    float duration_internal = convertTime(duration, m_timeUnit, TimeUnit::TIMESTEPS);

    Serial.print("  -> distance in encoder_counts: ");
    Serial.println(distance_internal);
    Serial.print("  -> duration in timesteps: ");
    Serial.println(duration_internal);

    // Move immediately to the given position using the currently set speed
    const uint8_t commandID = 2;
    trapezoidMovePayload payload;
    payload.displacement = htole32((int32_t)distance_internal);
    payload.duration = htole32((uint32_t)duration_internal);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setMaximumVelocity(uint32_t maximumVelocity) {
    // Sets maximum velocity (this is not used at this time)
    const uint8_t commandID = 3;
    setMaximumVelocityPayload payload;
    payload.maximumVelocity = htole32(maximumVelocity);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::goToPosition(int32_t position, uint32_t duration) {
    // Move to this new given position in the amount of time specified. Acceleration and deceleration will be applied to make the move smooth.
    const uint8_t commandID = 4;
    goToPositionPayload payload;
    payload.position = htole32(position);
    payload.duration = htole32(duration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setMaximumAcceleration(uint32_t maximumAcceleration) {
    // Sets max acceleration
    const uint8_t commandID = 5;
    setMaximumAccelerationPayload payload;
    payload.maximumAcceleration = htole32(maximumAcceleration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::startCalibration() {
    // Starts a calibration, which will determine the average values of the hall sensors and will determine if they are working correctly
    const uint8_t commandID = 6;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

captureHallSensorDataResponse ServoMotor::captureHallSensorData(uint8_t dataType) {
    // Start sending hall sensor data (work in progress; don't send this command)
    const uint8_t commandID = 7;
    captureHallSensorDataPayload payload;
    payload.dataType = dataType;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[sizeof(captureHallSensorDataResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(captureHallSensorDataResponse)) {
            captureHallSensorDataResponse* response = (captureHallSensorDataResponse*)buffer;
            captureHallSensorDataResponse result;
            result.data = response->data;
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return captureHallSensorDataResponse(); // Return default value
}

void ServoMotor::resetTime() {
    // Resets the absolute time to zero (call this first before issuing any movement commands)
    const uint8_t commandID = 8;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getCurrentTimeResponse ServoMotor::getCurrentTime() {
    // Gets the current absolute time
    const uint8_t commandID = 9;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getCurrentTimeResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getCurrentTimeResponse)) {
            getCurrentTimeResponse* response = (getCurrentTimeResponse*)buffer;
            getCurrentTimeResponse result;
            result.currentTime = le64toh(response->currentTime);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getCurrentTimeResponse(); // Return default value
}

timeSyncResponse ServoMotor::timeSync(uint64_t masterTime) {
    // Sends the master time to the motor so that it can sync its own clock (do this 10 times per second).
    const uint8_t commandID = 10;
    timeSyncPayload payload;
    payload.masterTime = htole64(masterTime);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[sizeof(timeSyncResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(timeSyncResponse)) {
            timeSyncResponse* response = (timeSyncResponse*)buffer;
            timeSyncResponse result;
            result.timeError = le32toh(response->timeError);
            result.rccIcscr = le16toh(response->rccIcscr);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return timeSyncResponse(); // Return default value
}

uint8_t ServoMotor::getNumberOfQueuedItems() {
    // Get the number of items currently in the movement queue (if this gets too large, don't queue any more movement commands)
    const uint8_t commandID = 11;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(uint8_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(uint8_t)) {
            uint8_t value = *(uint8_t*)buffer;
            return value;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return 0; // Return default value
}

void ServoMotor::emergencyStop() {
    // Emergency stop (stop all movement, disable MOSFETS, clear the queue)
    const uint8_t commandID = 12;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::zeroPosition() {
    // Make the current position the position zero (origin)
    const uint8_t commandID = 13;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::homing(int32_t maxDistance, uint32_t maxDuration) {
    // Homing (or in other words, move until a crash and then stop immediately)
    const uint8_t commandID = 14;
    homingPayload payload;
    payload.maxDistance = htole32(maxDistance);
    payload.maxDuration = htole32(maxDuration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getHallSensorPositionResponse ServoMotor::getHallSensorPosition() {
    // Get the position as measured by the hall sensors (this should be the actual position of the motor and if everything is ok then it will be about the same as the desired position)
    const uint8_t commandID = 15;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getHallSensorPositionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getHallSensorPositionResponse)) {
            getHallSensorPositionResponse* response = (getHallSensorPositionResponse*)buffer;
            getHallSensorPositionResponse result;
            result.hallSensorPosition = le64toh(response->hallSensorPosition);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getHallSensorPositionResponse(); // Return default value
}

StatusResponse ServoMotor::getStatus() {
    // Gets the status of the motor
    const uint8_t commandID = 16;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(StatusResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(StatusResponse)) {
            StatusResponse* response = (StatusResponse*)buffer;
            StatusResponse result;
            result.statusFlags = response->statusFlags;
            result.fatalErrorCode = response->fatalErrorCode;
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return StatusResponse(); // Return default value
}

void ServoMotor::goToClosedLoop() {
    // Go to closed loop position control mode
    const uint8_t commandID = 17;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getUpdateFrequencyResponse ServoMotor::getUpdateFrequency() {
    // Get the update frequency (reciprocal of the time step)
    const uint8_t commandID = 18;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getUpdateFrequencyResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getUpdateFrequencyResponse)) {
            getUpdateFrequencyResponse* response = (getUpdateFrequencyResponse*)buffer;
            getUpdateFrequencyResponse result;
            result.updateFrequency = le32toh(response->updateFrequency);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getUpdateFrequencyResponse(); // Return default value
}

void ServoMotor::moveWithAcceleration(int32_t acceleration, uint32_t timeSteps) {
    // Rotates the motor with the specified acceleration
    const uint8_t commandID = 19;
    moveWithAccelerationPayload payload;
    payload.acceleration = htole32(acceleration);
    payload.timeSteps = htole32(timeSteps);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

detectDevicesResponse ServoMotor::detectDevices() {
    // Detect all of the devices that are connected on the RS485 interface. Devices will identify themselves at a random time within one seconde. Chance of collision is possible but unlikely. You can repeat this if you suspect a collision (like if you have devices connected but they were not discovered within one to two seconds).
    const uint8_t commandID = 20;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(detectDevicesResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(detectDevicesResponse)) {
            detectDevicesResponse* response = (detectDevicesResponse*)buffer;
            detectDevicesResponse result;
            result.uniqueId = le64toh(response->uniqueId);
            result.alias = response->alias;
            result.crc = le32toh(response->crc);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return detectDevicesResponse(); // Return default value
}

detectDevicesResponse ServoMotor::detectDevicesGetAnotherResponse() {
    // Attempt to receive another response from previously sent Detect devices command
    uint8_t buffer[sizeof(detectDevicesResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(detectDevicesResponse)) {
            detectDevicesResponse* response = (detectDevicesResponse*)buffer;
            detectDevicesResponse result;
            result.uniqueId = le64toh(response->uniqueId);
            result.alias = response->alias;
            result.crc = le32toh(response->crc);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return detectDevicesResponse(); // Return default value
}

void ServoMotor::setDeviceAlias(uint64_t uniqueId, uint8_t alias) {
    // Sets device alias
    const uint8_t commandID = 21;
    setDeviceAliasPayload payload;
    payload.uniqueId = htole64(uniqueId);
    payload.alias = alias;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getProductInfoResponse ServoMotor::getProductInfo() {
    // Get product information
    const uint8_t commandID = 22;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getProductInfoResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getProductInfoResponse)) {
            getProductInfoResponse* response = (getProductInfoResponse*)buffer;
            getProductInfoResponse result;
            memcpy(result.productCode, response->productCode, sizeof(result.productCode));
            result.firmwareCompatibility = response->firmwareCompatibility;
            result.hardwareVersion = le32toh(response->hardwareVersion);
            result.serialNumber = le32toh(response->serialNumber);
            result.uniqueId = le64toh(response->uniqueId);
            result.reserved = le32toh(response->reserved);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getProductInfoResponse(); // Return default value
}

void ServoMotor::firmwareUpgrade(uint8_t firmwarePage[2058]) {
    // This command will upgrade the flash memory of the servo motor. Before issuing a firmware upgrade command, you must do some calculations as shown in the examples.
    const uint8_t commandID = 23;
    firmwareUpgradePayload payload;
    memcpy(payload.firmwarePage, firmwarePage, sizeof(payload.firmwarePage));
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getProductDescriptionResponse ServoMotor::getProductDescription() {
    // Get the product description. Documentation to be done later.
    const uint8_t commandID = 24;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getProductDescriptionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getProductDescriptionResponse)) {
            getProductDescriptionResponse* response = (getProductDescriptionResponse*)buffer;
            getProductDescriptionResponse result;
            memcpy(result.productDescription, response->productDescription, sizeof(result.productDescription));
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getProductDescriptionResponse(); // Return default value
}

getFirmwareVersionResponse ServoMotor::getFirmwareVersion() {
    // Get the firmware version. Documentation to be done later.
    const uint8_t commandID = 25;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getFirmwareVersionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getFirmwareVersionResponse)) {
            getFirmwareVersionResponse* response = (getFirmwareVersionResponse*)buffer;
            getFirmwareVersionResponse result;
            result.firmwareVersion = le32toh(response->firmwareVersion);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getFirmwareVersionResponse(); // Return default value
}

void ServoMotor::moveWithVelocity(int32_t velocity, uint32_t duration) {
    // Rotates the motor with the specified velocity.
    const uint8_t commandID = 26;
    moveWithVelocityPayload payload;
    payload.velocity = htole32(velocity);
    payload.duration = htole32(duration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::systemReset() {
    // System reset / go to the bootloader. The motor will reset immediately and will enter the bootloader. If there is no command sent within a short time, the motor will exit the bootloader and run the application from the beginning.
    const uint8_t commandID = 27;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    // No response expected for system reset
    _errno = 0;
}

void ServoMotor::setMaximumMotorCurrent(uint16_t motorCurrent, uint16_t regenerationCurrent) {
    // Set the maximum motor current and maximum regeneration current. The values are stored in non-volatile memory and survive a reset.
    const uint8_t commandID = 28;
    setMaximumMotorCurrentPayload payload;
    payload.motorCurrent = htole16(motorCurrent);
    payload.regenerationCurrent = htole16(regenerationCurrent);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::multiMove(uint8_t moveCount, uint32_t moveTypes, uint8_t* moveList) {
    // Multi-move command allows you to compose multiple moves one after eachother. The last move must set the motor's velocity to 0 for a period of time(e.g. 0.1s) to allow the motor to stop, otherwise the motor will enter in an error state.
    const uint8_t commandID = 29;
    multiMovePayload payload;
    payload.moveCount = moveCount;
    payload.moveTypes = htole32(moveTypes);
    // Handle pointer type
    // Assuming payload.moveList is an array of known size
    memcpy(payload.moveList, moveList, sizeof(payload.moveList[0]) * moveCount);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setSafetyLimits(int64_t lowerLimit, int64_t upperLimit) {
    // Set safety limits (to prevent motion from exceeding set bounds)
    const uint8_t commandID = 30;
    setSafetyLimitsPayload payload;
    payload.lowerLimit = htole64(lowerLimit);
    payload.upperLimit = htole64(upperLimit);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

pingResponse ServoMotor::ping(uint8_t pingData[10]) {
    // Send a payload containing any data and the device will respond with the same data back
    const uint8_t commandID = 31;
    pingPayload payload;
    memcpy(payload.pingData, pingData, sizeof(payload.pingData));
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[sizeof(pingResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(pingResponse)) {
            pingResponse* response = (pingResponse*)buffer;
            pingResponse result;
            memcpy(result.responsePayload, response->responsePayload, sizeof(result.responsePayload));
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return pingResponse(); // Return default value
}

void ServoMotor::controlHallSensorStatistics(uint8_t control) {
    // Turn on or off the gathering of statistics for the hall sensors and reset the statistics
    const uint8_t commandID = 32;
    controlHallSensorStatisticsPayload payload;
    payload.control = control;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getHallSensorStatisticsResponse ServoMotor::getHallSensorStatistics() {
    // Read back the statistics gathered from the hall sensors. Useful for checking the hall sensor health and noise in the system.
    const uint8_t commandID = 33;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getHallSensorStatisticsResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getHallSensorStatisticsResponse)) {
            getHallSensorStatisticsResponse* response = (getHallSensorStatisticsResponse*)buffer;
            getHallSensorStatisticsResponse result;
            result.maxHall1 = le16toh(response->maxHall1);
            result.maxHall2 = le16toh(response->maxHall2);
            result.maxHall3 = le16toh(response->maxHall3);
            result.minHall1 = le16toh(response->minHall1);
            result.minHall2 = le16toh(response->minHall2);
            result.minHall3 = le16toh(response->minHall3);
            result.sumHall1 = le64toh(response->sumHall1);
            result.sumHall2 = le64toh(response->sumHall2);
            result.sumHall3 = le64toh(response->sumHall3);
            result.measurementCount = le32toh(response->measurementCount);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getHallSensorStatisticsResponse(); // Return default value
}

int64_t ServoMotor::getPosition() {
    // Get the current desired position (which may differ a bit from the actual position as measured by the hall sensors)
    const uint8_t commandID = 34;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(int64_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(int64_t)) {
            int64_t value = le64toh(*(int64_t*)buffer);
            return value;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return 0; // Return default value
}

readMultipurposeBufferResponse ServoMotor::readMultipurposeBuffer() {
    // Read whatever is in the multipurpose buffer (the buffer is used for data generated during calibration, going to closed loop mode, and when capturing hall sensor data)
    const uint8_t commandID = 35;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(readMultipurposeBufferResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(readMultipurposeBufferResponse)) {
            readMultipurposeBufferResponse* response = (readMultipurposeBufferResponse*)buffer;
            readMultipurposeBufferResponse result;
            result.bufferData = response->bufferData;
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return readMultipurposeBufferResponse(); // Return default value
}

void ServoMotor::testMode(uint8_t testMode) {
    // Set a test mode. Set this to 0 for the default operation.
    const uint8_t commandID = 36;
    testModePayload payload;
    payload.testMode = testMode;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getComprehensivePositionResponse ServoMotor::getComprehensivePosition() {
    // Get the desired motor position, hall sensor position, and external encoder position all in one shot
    const uint8_t commandID = 37;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getComprehensivePositionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getComprehensivePositionResponse)) {
            getComprehensivePositionResponse* response = (getComprehensivePositionResponse*)buffer;
            getComprehensivePositionResponse result;
            result.commandedPosition = le64toh(response->commandedPosition);
            result.hallSensorPosition = le64toh(response->hallSensorPosition);
            result.externalEncoderPosition = le32toh(response->externalEncoderPosition);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getComprehensivePositionResponse(); // Return default value
}

getSupplyVoltageResponse ServoMotor::getSupplyVoltage() {
    // Get the measured voltage of the power supply.
    const uint8_t commandID = 38;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getSupplyVoltageResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getSupplyVoltageResponse)) {
            getSupplyVoltageResponse* response = (getSupplyVoltageResponse*)buffer;
            getSupplyVoltageResponse result;
            result.supplyVoltage = le16toh(response->supplyVoltage);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getSupplyVoltageResponse(); // Return default value
}

getMaxPidErrorResponse ServoMotor::getMaxPidError() {
    // Get the minimum and maximum error value ovserved in the PID control loop since the last read.
    const uint8_t commandID = 39;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getMaxPidErrorResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getMaxPidErrorResponse)) {
            getMaxPidErrorResponse* response = (getMaxPidErrorResponse*)buffer;
            getMaxPidErrorResponse result;
            result.minPidError = le32toh(response->minPidError);
            result.maxPidError = le32toh(response->maxPidError);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getMaxPidErrorResponse(); // Return default value
}

void ServoMotor::vibrate(uint8_t vibrationLevel) {
    // Cause the motor to start to vary the voltage quickly and therefore to vibrate (or stop).
    const uint8_t commandID = 40;
    vibratePayload payload;
    payload.vibrationLevel = vibrationLevel;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::identify(uint64_t uniqueId) {
    // Identify your motor by sending this command. The motor's green LED will flash rapidly for 3 seconds.
    const uint8_t commandID = 41;
    identifyPayload payload;
    payload.uniqueId = htole64(uniqueId);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getTemperatureResponse ServoMotor::getTemperature() {
    // Get the measured temperature of the motor.
    const uint8_t commandID = 42;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getTemperatureResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getTemperatureResponse)) {
            getTemperatureResponse* response = (getTemperatureResponse*)buffer;
            getTemperatureResponse result;
            result.temperature = le16toh(response->temperature);
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getTemperatureResponse(); // Return default value
}

void ServoMotor::setPIDConstants(uint32_t kP, uint32_t kI, uint32_t kD) {
    // Set PID constants for the control loop that will try to maintain the motion trajectory.
    const uint8_t commandID = 43;
    setPIDConstantsPayload payload;
    payload.kP = htole32(kP);
    payload.kI = htole32(kI);
    payload.kD = htole32(kD);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setMaxAllowablePositionDeviation(int64_t maxAllowablePositionDeviation) {
    // Set the amount of microsteps that the actual motor position (as measured by the hall sensors) is allowed to deviate from the desired position. Throw a fatal error if this is exceeded.
    const uint8_t commandID = 44;
    setMaxAllowablePositionDeviationPayload payload;
    payload.maxAllowablePositionDeviation = htole64(maxAllowablePositionDeviation);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));

    // Attempt to receive a response
    uint8_t buffer[1]; // No payload expected
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getDebugValuesResponse ServoMotor::getDebugValues() {
    // Get debug values including motor control parameters, profiler times, hall sensor data, and other diagnostic information.
    const uint8_t commandID = 45;
    _comm.sendCommand(_alias, commandID, nullptr, 0);

    // Attempt to receive a response
    uint8_t buffer[sizeof(getDebugValuesResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getDebugValuesResponse)) {
            getDebugValuesResponse* response = (getDebugValuesResponse*)buffer;
            getDebugValuesResponse result;
            result.maxAcceleration = le64toh(response->maxAcceleration);
            result.maxVelocity = le64toh(response->maxVelocity);
            result.currentVelocity = le64toh(response->currentVelocity);
            result.measuredVelocity = le32toh(response->measuredVelocity);
            result.nTimeSteps = le32toh(response->nTimeSteps);
            result.debugValue1 = le64toh(response->debugValue1);
            result.debugValue2 = le64toh(response->debugValue2);
            result.debugValue3 = le64toh(response->debugValue3);
            result.debugValue4 = le64toh(response->debugValue4);
            result.allMotorControlCalculationsProfilerTime = le16toh(response->allMotorControlCalculationsProfilerTime);
            result.allMotorControlCalculationsProfilerMaxTime = le16toh(response->allMotorControlCalculationsProfilerMaxTime);
            result.getSensorPositionProfilerTime = le16toh(response->getSensorPositionProfilerTime);
            result.getSensorPositionProfilerMaxTime = le16toh(response->getSensorPositionProfilerMaxTime);
            result.computeVelocityProfilerTime = le16toh(response->computeVelocityProfilerTime);
            result.computeVelocityProfilerMaxTime = le16toh(response->computeVelocityProfilerMaxTime);
            result.motorMovementCalculationsProfilerTime = le16toh(response->motorMovementCalculationsProfilerTime);
            result.motorMovementCalculationsProfilerMaxTime = le16toh(response->motorMovementCalculationsProfilerMaxTime);
            result.motorPhaseCalculationsProfilerTime = le16toh(response->motorPhaseCalculationsProfilerTime);
            result.motorPhaseCalculationsProfilerMaxTime = le16toh(response->motorPhaseCalculationsProfilerMaxTime);
            result.motorControlLoopPeriodProfilerTime = le16toh(response->motorControlLoopPeriodProfilerTime);
            result.motorControlLoopPeriodProfilerMaxTime = le16toh(response->motorControlLoopPeriodProfilerMaxTime);
            result.hallSensor1Voltage = le16toh(response->hallSensor1Voltage);
            result.hallSensor2Voltage = le16toh(response->hallSensor2Voltage);
            result.hallSensor3Voltage = le16toh(response->hallSensor3Voltage);
            result.commutationPositionOffset = le32toh(response->commutationPositionOffset);
            result.motorPhasesReversed = response->motorPhasesReversed;
            result.maxHallPositionDelta = le32toh(response->maxHallPositionDelta);
            result.minHallPositionDelta = le32toh(response->minHallPositionDelta);
            result.averageHallPositionDelta = le32toh(response->averageHallPositionDelta);
            result.motorPwmVoltage = response->motorPwmVoltage;
            return result;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return getDebugValuesResponse(); // Return default value
}

