// ServomotorCommands.cpp
// This file was autogenerated by generate_command_code.py on 2025-02-23 13:54:36
// Do not edit this file manually.

#include "ServomotorCommands.h"
#include "Commands.h"
#include "Utils.h"

ServoMotor::ServoMotor(uint8_t alias, HardwareSerial& serialPort)
    : _alias(alias), _comm(serialPort), _errno(0),
      m_positionUnit(PositionUnit::SHAFT_ROTATIONS),
      m_timeUnit(TimeUnit::SECONDS) {
    openSerialPort();
}

void ServoMotor::setAlias(uint8_t new_alias) {
    _alias = new_alias;
}

uint8_t ServoMotor::getAlias() {
    return _alias;
}

void ServoMotor::openSerialPort() {
    _comm.openSerialPort();
}

int ServoMotor::getError() const {
    return _errno;
}

// Unit setting functions
void ServoMotor::setPositionUnit(PositionUnit unit) {
    m_positionUnit = unit;
    Serial.print("[Motor] setPositionUnit to ");
    switch(unit) {
        case PositionUnit::SHAFT_ROTATIONS: Serial.println("SHAFT_ROTATIONS"); break;
        case PositionUnit::DEGREES:         Serial.println("DEGREES"); break;
        case PositionUnit::RADIANS:         Serial.println("RADIANS"); break;
        case PositionUnit::ENCODER_COUNTS:  Serial.println("ENCODER_COUNTS"); break;
    }
}

void ServoMotor::setTimeUnit(TimeUnit unit) {
    m_timeUnit = unit;
    Serial.print("[Motor] setTimeUnit to ");
    switch(unit) {
        case TimeUnit::SECONDS:      Serial.println("SECONDS"); break;
        case TimeUnit::MILLISECONDS: Serial.println("MILLISECONDS"); break;
        case TimeUnit::MINUTES:      Serial.println("MINUTES"); break;
        case TimeUnit::TIMESTEPS:    Serial.println("TIMESTEPS"); break;
    }
}

void ServoMotor::disableMosfets() {
    // Disables the MOSFETS (note that MOSFETs are disabled after initial power on).
    const uint8_t commandID = 0;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::enableMosfets() {
    // Enables the MOSFETS.
    const uint8_t commandID = 1;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::trapezoidMoveRaw(int32_t displacement, uint32_t duration) {
    // Move immediately to the given position using the currently set speed (the speed is set by a separate command) (Raw version)
    const uint8_t commandID = 2;
    trapezoidMovePayload payload;
    payload.displacement = htole32(displacement);
    payload.duration = htole32(duration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::trapezoidMove(float displacement, float duration) {
    Serial.println("[Motor] trapezoidMove called.");
    Serial.print("  displacement in chosen unit: "); Serial.println(displacement);
    Serial.print("  duration in chosen unit: "); Serial.println(duration);

    float displacement_internal = convertPosition(displacement, m_positionUnit, PositionUnit::ENCODER_COUNTS);
    float duration_internal = convertTime(duration, m_timeUnit, TimeUnit::TIMESTEPS);
    trapezoidMoveRaw((int32_t)(displacement_internal), (uint32_t)(duration_internal));
}

void ServoMotor::setMaximumVelocityRaw(uint32_t maximumVelocity) {
    // Sets maximum velocity (this is not used at this time) (Raw version)
    const uint8_t commandID = 3;
    setMaximumVelocityPayload payload;
    payload.maximumVelocity = htole32(maximumVelocity);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setMaximumVelocity(float maximumVelocity) {
    Serial.println("[Motor] setMaximumVelocity called.");
    Serial.print("  maximumVelocity in chosen unit: "); Serial.println(maximumVelocity);

    float maximumVelocity_internal = convertVelocity(maximumVelocity, ((VelocityUnit)0), ((VelocityUnit)0));
    setMaximumVelocityRaw((uint32_t)(maximumVelocity_internal));
}

void ServoMotor::goToPositionRaw(int32_t position, uint32_t duration) {
    // Move to this new given position in the amount of time specified. Acceleration and deceleration will be applied to make the move smooth. (Raw version)
    const uint8_t commandID = 4;
    goToPositionPayload payload;
    payload.position = htole32(position);
    payload.duration = htole32(duration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::goToPosition(float position, float duration) {
    Serial.println("[Motor] goToPosition called.");
    Serial.print("  position in chosen unit: "); Serial.println(position);
    Serial.print("  duration in chosen unit: "); Serial.println(duration);

    float position_internal = convertPosition(position, m_positionUnit, PositionUnit::ENCODER_COUNTS);
    float duration_internal = convertTime(duration, m_timeUnit, TimeUnit::TIMESTEPS);
    goToPositionRaw((int32_t)(position_internal), (uint32_t)(duration_internal));
}

void ServoMotor::setMaximumAccelerationRaw(uint32_t maximumAcceleration) {
    // Sets max acceleration (Raw version)
    const uint8_t commandID = 5;
    setMaximumAccelerationPayload payload;
    payload.maximumAcceleration = htole32(maximumAcceleration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setMaximumAcceleration(float maximumAcceleration) {
    Serial.println("[Motor] setMaximumAcceleration called.");
    Serial.print("  maximumAcceleration in chosen unit: "); Serial.println(maximumAcceleration);

    float maximumAcceleration_internal = convertAcceleration(maximumAcceleration, ((AccelerationUnit)0), ((AccelerationUnit)0));
    setMaximumAccelerationRaw((uint32_t)(maximumAcceleration_internal));
}

void ServoMotor::startCalibration() {
    // Starts a calibration, which will determine the average values of the hall sensors and will determine if they are working correctly
    const uint8_t commandID = 6;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

uint8_t ServoMotor::captureHallSensorData(uint8_t dataType) {
    // Start sending hall sensor data (work in progress; don't send this command)
    const uint8_t commandID = 7;
    captureHallSensorDataPayload payload;
    payload.dataType = dataType;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[sizeof(uint8_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(uint8_t)) {
            uint8_t* response = (uint8_t*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    uint8_t defaultResponse = {0};
    return defaultResponse;
}

void ServoMotor::resetTime() {
    // Resets the absolute time to zero (call this first before issuing any movement commands)
    const uint8_t commandID = 8;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getCurrentTimeResponse ServoMotor::getCurrentTimeRaw() {
    // Gets the current absolute time (Raw version)
    const uint8_t commandID = 9;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getCurrentTimeResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getCurrentTimeResponse)) {
            getCurrentTimeResponse* response = (getCurrentTimeResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getCurrentTimeResponse defaultResponse = {0};
    return defaultResponse;
}

float ServoMotor::getCurrentTime() {
    Serial.println("[Motor] getCurrentTime called.");

    auto rawResult = getCurrentTimeRaw();
    float convertedResult = convertTime((float)rawResult.currentTime, m_timeUnit, TimeUnit::TIMESTEPS);
    return convertedResult;
}

timeSyncResponse ServoMotor::timeSync(uint64_t masterTime) {
    // Sends the master time to the motor so that it can sync its own clock (do this 10 times per second).
    const uint8_t commandID = 10;
    timeSyncPayload payload;
    payload.masterTime = htole64(masterTime);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[sizeof(timeSyncResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(timeSyncResponse)) {
            timeSyncResponse* response = (timeSyncResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    timeSyncResponse defaultResponse = {0};
    return defaultResponse;
}

uint8_t ServoMotor::getNumberOfQueuedItems() {
    // Get the number of items currently in the movement queue (if this gets too large, don't queue any more movement commands)
    const uint8_t commandID = 11;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(uint8_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(uint8_t)) {
            uint8_t* response = (uint8_t*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    uint8_t defaultResponse = {0};
    return defaultResponse;
}

void ServoMotor::emergencyStop() {
    // Emergency stop (stop all movement, disable MOSFETS, clear the queue)
    const uint8_t commandID = 12;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::zeroPosition() {
    // Make the current position the position zero (origin)
    const uint8_t commandID = 13;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::homingRaw(int32_t maxDistance, uint32_t maxDuration) {
    // Homing (or in other words, move until a crash and then stop immediately) (Raw version)
    const uint8_t commandID = 14;
    homingPayload payload;
    payload.maxDistance = htole32(maxDistance);
    payload.maxDuration = htole32(maxDuration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::homing(float maxDistance, float maxDuration) {
    Serial.println("[Motor] homing called.");
    Serial.print("  maxDistance in chosen unit: "); Serial.println(maxDistance);
    Serial.print("  maxDuration in chosen unit: "); Serial.println(maxDuration);

    float maxDistance_internal = convertPosition(maxDistance, m_positionUnit, PositionUnit::ENCODER_COUNTS);
    float maxDuration_internal = convertTime(maxDuration, m_timeUnit, TimeUnit::TIMESTEPS);
    homingRaw((int32_t)(maxDistance_internal), (uint32_t)(maxDuration_internal));
}

getHallSensorPositionResponse ServoMotor::getHallSensorPositionRaw() {
    // Get the position as measured by the hall sensors (this should be the actual position of the motor and if everything is ok then it will be about the same as the desired position) (Raw version)
    const uint8_t commandID = 15;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getHallSensorPositionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getHallSensorPositionResponse)) {
            getHallSensorPositionResponse* response = (getHallSensorPositionResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getHallSensorPositionResponse defaultResponse = {0};
    return defaultResponse;
}

float ServoMotor::getHallSensorPosition() {
    Serial.println("[Motor] getHallSensorPosition called.");

    auto rawResult = getHallSensorPositionRaw();
    float convertedResult = convertPosition((float)rawResult.hallSensorPosition, m_positionUnit, PositionUnit::ENCODER_COUNTS);
    return convertedResult;
}

StatusResponse ServoMotor::getStatus() {
    // Gets the status of the motor
    const uint8_t commandID = 16;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(StatusResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(StatusResponse)) {
            StatusResponse* response = (StatusResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    StatusResponse defaultResponse = {0};
    return defaultResponse;
}

void ServoMotor::goToClosedLoop() {
    // Go to closed loop position control mode
    const uint8_t commandID = 17;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

uint32_t ServoMotor::getUpdateFrequency() {
    // Get the update frequency (reciprocal of the time step)
    const uint8_t commandID = 18;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(uint32_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(uint32_t)) {
            uint32_t* response = (uint32_t*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    uint32_t defaultResponse = {0};
    return defaultResponse;
}

void ServoMotor::moveWithAccelerationRaw(int32_t acceleration, uint32_t timeSteps) {
    // Rotates the motor with the specified acceleration (Raw version)
    const uint8_t commandID = 19;
    moveWithAccelerationPayload payload;
    payload.acceleration = htole32(acceleration);
    payload.timeSteps = htole32(timeSteps);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::moveWithAcceleration(float acceleration, float timeSteps) {
    Serial.println("[Motor] moveWithAcceleration called.");
    Serial.print("  acceleration in chosen unit: "); Serial.println(acceleration);
    Serial.print("  timeSteps in chosen unit: "); Serial.println(timeSteps);

    float acceleration_internal = convertAcceleration(acceleration, ((AccelerationUnit)0), ((AccelerationUnit)0));
    float timeSteps_internal = convertTime(timeSteps, m_timeUnit, TimeUnit::TIMESTEPS);
    moveWithAccelerationRaw((int32_t)(acceleration_internal), (uint32_t)(timeSteps_internal));
}

detectDevicesResponse ServoMotor::detectDevices() {
    // Detect all of the devices that are connected on the RS485 interface. Devices will identify themselves at a random time within one seconde. Chance of collision is possible but unlikely. You can repeat this if you suspect a collision (like if you have devices connected but they were not discovered within one to two seconds).
    const uint8_t commandID = 20;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(detectDevicesResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(detectDevicesResponse)) {
            detectDevicesResponse* response = (detectDevicesResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    detectDevicesResponse defaultResponse = {0};
    return defaultResponse;
}

detectDevicesResponse ServoMotor::detectDevicesGetAnotherResponse() {
    // Attempt to receive another response from previously sent Detect devices command
    uint8_t buffer[sizeof(detectDevicesResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(detectDevicesResponse)) {
            detectDevicesResponse* response = (detectDevicesResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    return detectDevicesResponse();
}

void ServoMotor::setDeviceAlias(uint64_t uniqueId, uint8_t alias) {
    // Sets device alias
    const uint8_t commandID = 21;
    setDeviceAliasPayload payload;
    payload.uniqueId = htole64(uniqueId);
    payload.alias = alias;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getProductInfoResponse ServoMotor::getProductInfo() {
    // Get product information
    const uint8_t commandID = 22;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getProductInfoResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getProductInfoResponse)) {
            getProductInfoResponse* response = (getProductInfoResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getProductInfoResponse defaultResponse = {0};
    return defaultResponse;
}

void ServoMotor::firmwareUpgrade(uint8_t firmwarePage[2058]) {
    // This command will upgrade the flash memory of the servo motor. Before issuing a firmware upgrade command, you must do some calculations as shown in the examples.
    const uint8_t commandID = 23;
    firmwareUpgradePayload payload;
    memcpy(payload.firmwarePage, firmwarePage, sizeof(payload.firmwarePage));
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getProductDescriptionResponse ServoMotor::getProductDescription() {
    // Get the product description. Documentation to be done later.
    const uint8_t commandID = 24;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getProductDescriptionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getProductDescriptionResponse)) {
            getProductDescriptionResponse* response = (getProductDescriptionResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getProductDescriptionResponse defaultResponse = {0};
    return defaultResponse;
}

uint32_t ServoMotor::getFirmwareVersion() {
    // Get the firmware version. Documentation to be done later.
    const uint8_t commandID = 25;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(uint32_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(uint32_t)) {
            uint32_t* response = (uint32_t*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    uint32_t defaultResponse = {0};
    return defaultResponse;
}

void ServoMotor::moveWithVelocityRaw(int32_t velocity, uint32_t duration) {
    // Rotates the motor with the specified velocity. (Raw version)
    const uint8_t commandID = 26;
    moveWithVelocityPayload payload;
    payload.velocity = htole32(velocity);
    payload.duration = htole32(duration);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::moveWithVelocity(float velocity, float duration) {
    Serial.println("[Motor] moveWithVelocity called.");
    Serial.print("  velocity in chosen unit: "); Serial.println(velocity);
    Serial.print("  duration in chosen unit: "); Serial.println(duration);

    float velocity_internal = convertVelocity(velocity, ((VelocityUnit)0), ((VelocityUnit)0));
    float duration_internal = convertTime(duration, m_timeUnit, TimeUnit::TIMESTEPS);
    moveWithVelocityRaw((int32_t)(velocity_internal), (uint32_t)(duration_internal));
}

void ServoMotor::systemReset() {
    // System reset / go to the bootloader. The motor will reset immediately and will enter the bootloader. If there is no command sent within a short time, the motor will exit the bootloader and run the application from the beginning.
    const uint8_t commandID = 27;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setMaximumMotorCurrentRaw(uint16_t motorCurrent, uint16_t regenerationCurrent) {
    // Set the maximum motor current and maximum regeneration current. The values are stored in non-volatile memory and survive a reset. (Raw version)
    const uint8_t commandID = 28;
    setMaximumMotorCurrentPayload payload;
    payload.motorCurrent = htole16(motorCurrent);
    payload.regenerationCurrent = htole16(regenerationCurrent);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setMaximumMotorCurrent(float motorCurrent, float regenerationCurrent) {
    Serial.println("[Motor] setMaximumMotorCurrent called.");
    Serial.print("  motorCurrent in chosen unit: "); Serial.println(motorCurrent);
    Serial.print("  regenerationCurrent in chosen unit: "); Serial.println(regenerationCurrent);

    float motorCurrent_internal = convertCurrent(motorCurrent, ((CurrentUnit)0), ((CurrentUnit)0));
    float regenerationCurrent_internal = convertCurrent(regenerationCurrent, ((CurrentUnit)0), ((CurrentUnit)0));
    setMaximumMotorCurrentRaw((uint16_t)(motorCurrent_internal), (uint16_t)(regenerationCurrent_internal));
}

void ServoMotor::multiMove(uint8_t moveCount, uint32_t moveTypes, uint8_t moveList) {
    // Multi-move command allows you to compose multiple moves one after eachother. The last move must set the motor's velocity to 0 for a period of time(e.g. 0.1s) to allow the motor to stop, otherwise the motor will enter in an error state.
    const uint8_t commandID = 29;
    multiMovePayload payload;
    payload.moveCount = moveCount;
    payload.moveTypes = htole32(moveTypes);
    payload.moveList = moveList;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setSafetyLimitsRaw(int64_t lowerLimit, int64_t upperLimit) {
    // Set safety limits (to prevent motion from exceeding set bounds) (Raw version)
    const uint8_t commandID = 30;
    setSafetyLimitsPayload payload;
    payload.lowerLimit = htole64(lowerLimit);
    payload.upperLimit = htole64(upperLimit);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setSafetyLimits(float lowerLimit, float upperLimit) {
    Serial.println("[Motor] setSafetyLimits called.");
    Serial.print("  lowerLimit in chosen unit: "); Serial.println(lowerLimit);
    Serial.print("  upperLimit in chosen unit: "); Serial.println(upperLimit);

    float lowerLimit_internal = convertPosition(lowerLimit, m_positionUnit, PositionUnit::ENCODER_COUNTS);
    float upperLimit_internal = convertPosition(upperLimit, m_positionUnit, PositionUnit::ENCODER_COUNTS);
    setSafetyLimitsRaw((int64_t)(lowerLimit_internal), (int64_t)(upperLimit_internal));
}

pingResponse ServoMotor::ping(uint8_t pingData[10]) {
    // Send a payload containing any data and the device will respond with the same data back
    const uint8_t commandID = 31;
    pingPayload payload;
    memcpy(payload.pingData, pingData, sizeof(payload.pingData));
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[sizeof(pingResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(pingResponse)) {
            pingResponse* response = (pingResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    pingResponse defaultResponse = {0};
    return defaultResponse;
}

void ServoMotor::controlHallSensorStatistics(uint8_t control) {
    // Turn on or off the gathering of statistics for the hall sensors and reset the statistics
    const uint8_t commandID = 32;
    controlHallSensorStatisticsPayload payload;
    payload.control = control;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getHallSensorStatisticsResponse ServoMotor::getHallSensorStatistics() {
    // Read back the statistics gathered from the hall sensors. Useful for checking the hall sensor health and noise in the system.
    const uint8_t commandID = 33;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getHallSensorStatisticsResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getHallSensorStatisticsResponse)) {
            getHallSensorStatisticsResponse* response = (getHallSensorStatisticsResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getHallSensorStatisticsResponse defaultResponse = {0};
    return defaultResponse;
}

getHallSensorPositionResponse ServoMotor::getPositionRaw() {
    // Get the current desired position (which may differ a bit from the actual position as measured by the hall sensors) (Raw version)
    const uint8_t commandID = 34;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getHallSensorPositionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getHallSensorPositionResponse)) {
            getHallSensorPositionResponse* response = (getHallSensorPositionResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getHallSensorPositionResponse defaultResponse = {0};
    return defaultResponse;
}

float ServoMotor::getPosition() {
    Serial.println("[Motor] getPosition called.");

    auto rawResult = getPositionRaw();
    float convertedResult = 0; // Unknown conversion
    return convertedResult;
}

uint8_t ServoMotor::readMultipurposeBuffer() {
    // Read whatever is in the multipurpose buffer (the buffer is used for data generated during calibration, going to closed loop mode, and when capturing hall sensor data)
    const uint8_t commandID = 35;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(uint8_t)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(uint8_t)) {
            uint8_t* response = (uint8_t*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    uint8_t defaultResponse = {0};
    return defaultResponse;
}

void ServoMotor::testMode(uint8_t testMode) {
    // Set a test mode. Set this to 0 for the default operation.
    const uint8_t commandID = 36;
    testModePayload payload;
    payload.testMode = testMode;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getComprehensivePositionResponse ServoMotor::getComprehensivePositionRaw() {
    // Get the desired motor position, hall sensor position, and external encoder position all in one shot (Raw version)
    const uint8_t commandID = 37;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getComprehensivePositionResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getComprehensivePositionResponse)) {
            getComprehensivePositionResponse* response = (getComprehensivePositionResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getComprehensivePositionResponse defaultResponse = {0};
    return defaultResponse;
}

float ServoMotor::getComprehensivePosition() {
    Serial.println("[Motor] getComprehensivePosition called.");

    auto rawResult = getComprehensivePositionRaw();
    float convertedResult = 0; // Unknown conversion
    return convertedResult;
}

getSupplyVoltageResponse ServoMotor::getSupplyVoltageRaw() {
    // Get the measured voltage of the power supply. (Raw version)
    const uint8_t commandID = 38;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getSupplyVoltageResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getSupplyVoltageResponse)) {
            getSupplyVoltageResponse* response = (getSupplyVoltageResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getSupplyVoltageResponse defaultResponse = {0};
    return defaultResponse;
}

float ServoMotor::getSupplyVoltage() {
    Serial.println("[Motor] getSupplyVoltage called.");

    auto rawResult = getSupplyVoltageRaw();
    float convertedResult = convertVoltage((float)rawResult.supplyVoltage, ((VoltageUnit)0), ((VoltageUnit)0));
    return convertedResult;
}

getMaxPidErrorResponse ServoMotor::getMaxPidErrorRaw() {
    // Get the minimum and maximum error value ovserved in the PID control loop since the last read. (Raw version)
    const uint8_t commandID = 39;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getMaxPidErrorResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getMaxPidErrorResponse)) {
            getMaxPidErrorResponse* response = (getMaxPidErrorResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getMaxPidErrorResponse defaultResponse = {0};
    return defaultResponse;
}

float ServoMotor::getMaxPidError() {
    Serial.println("[Motor] getMaxPidError called.");

    auto rawResult = getMaxPidErrorRaw();
    float convertedResult = 0; // Unknown conversion
    return convertedResult;
}

void ServoMotor::vibrate(uint8_t vibrationLevel) {
    // Cause the motor to start to vary the voltage quickly and therefore to vibrate (or stop).
    const uint8_t commandID = 40;
    vibratePayload payload;
    payload.vibrationLevel = vibrationLevel;
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::identify(uint64_t uniqueId) {
    // Identify your motor by sending this command. The motor's green LED will flash rapidly for 3 seconds.
    const uint8_t commandID = 41;
    identifyPayload payload;
    payload.uniqueId = htole64(uniqueId);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

getTemperatureResponse ServoMotor::getTemperatureRaw() {
    // Get the measured temperature of the motor. (Raw version)
    const uint8_t commandID = 42;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getTemperatureResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getTemperatureResponse)) {
            getTemperatureResponse* response = (getTemperatureResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getTemperatureResponse defaultResponse = {0};
    return defaultResponse;
}

float ServoMotor::getTemperature() {
    Serial.println("[Motor] getTemperature called.");

    auto rawResult = getTemperatureRaw();
    float convertedResult = convertTemperature((float)rawResult.temperature, ((TemperatureUnit)0), ((TemperatureUnit)0));
    return convertedResult;
}

void ServoMotor::setPIDConstants(uint32_t kP, uint32_t kI, uint32_t kD) {
    // Set PID constants for the control loop that will try to maintain the motion trajectory.
    const uint8_t commandID = 43;
    setPIDConstantsPayload payload;
    payload.kP = htole32(kP);
    payload.kI = htole32(kI);
    payload.kD = htole32(kD);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setMaxAllowablePositionDeviationRaw(int64_t maxAllowablePositionDeviation) {
    // Set the amount of microsteps that the actual motor position (as measured by the hall sensors) is allowed to deviate from the desired position. Throw a fatal error if this is exceeded. (Raw version)
    const uint8_t commandID = 44;
    setMaxAllowablePositionDeviationPayload payload;
    payload.maxAllowablePositionDeviation = htole64(maxAllowablePositionDeviation);
    _comm.sendCommand(_alias, commandID, (uint8_t*)&payload, sizeof(payload));
    uint8_t buffer[1];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
}

void ServoMotor::setMaxAllowablePositionDeviation(float maxAllowablePositionDeviation) {
    Serial.println("[Motor] setMaxAllowablePositionDeviation called.");
    Serial.print("  maxAllowablePositionDeviation in chosen unit: "); Serial.println(maxAllowablePositionDeviation);

    float maxAllowablePositionDeviation_internal = convertPosition(maxAllowablePositionDeviation, m_positionUnit, PositionUnit::ENCODER_COUNTS);
    setMaxAllowablePositionDeviationRaw((int64_t)(maxAllowablePositionDeviation_internal));
}

getDebugValuesResponse ServoMotor::getDebugValues() {
    // Get debug values including motor control parameters, profiler times, hall sensor data, and other diagnostic information.
    const uint8_t commandID = 45;
    _comm.sendCommand(_alias, commandID, nullptr, 0);
    uint8_t buffer[sizeof(getDebugValuesResponse)];
    uint16_t receivedSize;
    _errno = _comm.getResponse(buffer, sizeof(buffer), receivedSize);
    if (_errno == 0) {
        if (receivedSize == sizeof(getDebugValuesResponse)) {
            getDebugValuesResponse* response = (getDebugValuesResponse*)buffer;
            return *response;
        } else {
            _errno = COMMUNICATION_ERROR_DATA_WRONG_SIZE;
        }
    }
    getDebugValuesResponse defaultResponse = {0};
    return defaultResponse;
}

