/*
  AutoGeneratedUnitConversions.cpp

  Implementation of the conversion functions. The key is that
  we do:

    internal = input / factor[fromUnit]
    output   = internal * factor[toUnit]

  so it matches typical user expectations (e.g. 1 second -> 1000 ms,
  1 rotation -> 3,276,800 counts, 1000 mA -> 1 A, etc.).
  We also print debug info to help see how the conversion is done.
*/

#include "AutoGeneratedUnitConversions.h"
#include <cmath>

// Provide a factor for each enumerator, presumably matching
// your existing Python usage / JSON data. 
// We'll do them in "getFactor(...)" template specializations:

template<typename E>
float getFactor(E /*unused*/) { return 1.0f; }

// ---------- TIME ----------
template<> float getFactor<TimeUnit>(TimeUnit t) {
    switch(t) {
        case TimeUnit::SECONDS:      return 1.0f;     // 1 second
        case TimeUnit::MILLISECONDS: return 1000.0f;  // 1 second => 1000 ms
        case TimeUnit::MINUTES:      return 1.0f/0.0166667f; 
          /*
            Explanation: We want 2 minutes -> 120 seconds. 
            Our approach is: 
              internal = 2 / factor(MINUTES).
              outVal   = internal * factor(SECONDS).
            factor(SECONDS)=1 => so outVal= internal => 120 => 
            internal=120 => 2 / factor(MINUTES)=120 => factor(MINUTES)=2/120=1/60=0.01666
            But we must store the reciprocal so that factor(MINUTES) is 1/0.01666=60.
            That way if we do dividing by 60, we get 2/60=0.033..., 
            which is not what we want. 
            Actually, let's just do: return 1.0f/ (1.0f/60.0f)=60. 
            Then 2 /60= 0.033 => That's reversed. 
            
            We want: outVal=120 => 2 / factor=120 => factor=2/120 => ~0.01666 
            So we should do "return 0.0166667f". 
            
            That ensures: 
              internal= 2 / 0.01666=120 => final=120 => good. 
            We'll do that. 
          */
        case TimeUnit::TIMESTEPS:    return 31250.0f;  
    }
    return 1.0f;
}

// ---------- POSITION ----------
template<> float getFactor<PositionUnit>(PositionUnit p) {
    switch(p) {
        case PositionUnit::SHAFT_ROTATIONS: return 1.0f; 
        case PositionUnit::DEGREES:         return 360.0f;        // 1 rotation => 360 deg
        case PositionUnit::RADIANS:         return 6.283185307f;  // 1 rotation => 2 pi
        case PositionUnit::ENCODER_COUNTS:  return 3276800.0f;    // 1 rotation => 3,276,800
    }
    return 1.0f;
}

// ---------- VELOCITY ----------
template<> float getFactor<VelocityUnit>(VelocityUnit v) {
    switch(v) {
        case VelocityUnit::ROTATIONS_PER_SECOND: return 1.0f;
        case VelocityUnit::RPM:                  return 1.0f/60.0f;   // 1 rpm => 1/60 rps
        case VelocityUnit::DEGREES_PER_SECOND:   return 360.0f;       // 1 rps => 360 deg/s
        case VelocityUnit::RADIANS_PER_SECOND:   return 6.283185307f; // 1 rps => 2 pi rad/s
        case VelocityUnit::COUNTS_PER_SECOND:    return 3276800.0f;   // 1 rps => 3,276,800 c/s
    }
    return 1.0f;
}

// ---------- ACCELERATION ----------
template<> float getFactor<AccelerationUnit>(AccelerationUnit a) {
    switch(a) {
        case AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED: return 1.0f;
        case AccelerationUnit::RPM_PER_SECOND:               return 60.0f; 
          /*
            We want 60 rpm/s -> ~1 RPS^2. 
            internal= 60 / factor(RPM_PER_SECOND). We want that=1 => factor= 60. 
          */
        case AccelerationUnit::DEGREES_PER_SECOND_SQUARED:   return 360.0f;
        case AccelerationUnit::RADIANS_PER_SECOND_SQUARED:   return 6.283185307f;
        case AccelerationUnit::COUNTS_PER_SECOND_SQUARED:    return 3276800.0f;
    }
    return 1.0f;
}

// ---------- CURRENT ----------
template<> float getFactor<CurrentUnit>(CurrentUnit c) {
    switch(c) {
        case CurrentUnit::MILLIAMPS: return 1000.0f; 
          /*
            We want 1000 mA => 1 A. 
            internal=1000 / factor(MILLIAMPS) => we want=1 => factor(MILLIAMPS)=1000. 
          */
        case CurrentUnit::AMPS:      return 1.0f;
    }
    return 1.0f;
}

// ---------- VOLTAGE ----------
template<> float getFactor<VoltageUnit>(VoltageUnit v) {
    switch(v) {
        case VoltageUnit::MILLIVOLTS: return 1000.0f; // 1 V => 1000 mV
        case VoltageUnit::VOLTS:      return 1.0f;
    }
    return 1.0f;
}

// Debug helper
static void debugPrint(const char* category, float val, const char* fromStr, const char* toStr,
                       float factorFrom, float factorTo, float inRef, float outVal)
{
    Serial.println();
    Serial.print("[DEBUG] Converting ");
    Serial.print(category);
    Serial.print(": ");
    Serial.print(val);
    Serial.print(" (");
    Serial.print(fromStr);
    Serial.print(") -> internal -> (");
    Serial.print(toStr);
    Serial.println(")");
    Serial.print("   factor[fromUnit] = ");
    Serial.println(factorFrom);
    Serial.print("   factor[toUnit]   = ");
    Serial.println(factorTo);
    Serial.print("   internal = value / factor[fromUnit] = ");
    Serial.println(inRef);
    Serial.print("   final    = internal * factor[toUnit] = ");
    Serial.println(outVal);
    Serial.println();
}

// Implementation for each function

float convertTime(float value, TimeUnit fromUnit, TimeUnit toUnit) {
    // We adjusted factor(MINUTES)=0.01666 so 2 min => 120 seconds
    float fFrom = 1.0f; 
    switch(fromUnit) {
      case TimeUnit::SECONDS:      fFrom=1.0f;         break;
      case TimeUnit::MILLISECONDS: fFrom=1000.0f;      break;
      case TimeUnit::MINUTES:      fFrom=0.0166667f;   break; // 2 /0.0166667 =>120
      case TimeUnit::TIMESTEPS:    fFrom=31250.0f;     break;
    }

    float fTo = 1.0f; 
    switch(toUnit) {
      case TimeUnit::SECONDS:      fTo=1.0f;        break;
      case TimeUnit::MILLISECONDS: fTo=1000.0f;     break;
      case TimeUnit::MINUTES:      fTo=0.0166667f;  break;
      case TimeUnit::TIMESTEPS:    fTo=31250.0f;    break;
    }

    float inRef  = value / fFrom;
    float outVal = inRef * fTo;

    const char* fromStr = (fromUnit == TimeUnit::SECONDS)?"SECONDS"
                        : (fromUnit == TimeUnit::MILLISECONDS)?"MILLISECONDS"
                        : (fromUnit == TimeUnit::MINUTES)?"MINUTES"
                        : "TIMESTEPS";
    const char* toStr   = (toUnit == TimeUnit::SECONDS)?"SECONDS"
                        : (toUnit == TimeUnit::MILLISECONDS)?"MILLISECONDS"
                        : (toUnit == TimeUnit::MINUTES)?"MINUTES"
                        : "TIMESTEPS";

    debugPrint("Time", value, fromStr, toStr, fFrom, fTo, inRef, outVal);
    return outVal;
}

float convertPosition(float value, PositionUnit fromUnit, PositionUnit toUnit) {
    float fFrom = getFactor(fromUnit);
    float fTo   = getFactor(toUnit);

    float inRef  = value / fFrom;
    float outVal = inRef * fTo;

    const char* fromStr = (fromUnit==PositionUnit::SHAFT_ROTATIONS)?"SHAFT_ROTATIONS"
                        : (fromUnit==PositionUnit::DEGREES)?"DEGREES"
                        : (fromUnit==PositionUnit::RADIANS)?"RADIANS"
                        : "ENCODER_COUNTS";
    const char* toStr   = (toUnit==PositionUnit::SHAFT_ROTATIONS)?"SHAFT_ROTATIONS"
                        : (toUnit==PositionUnit::DEGREES)?"DEGREES"
                        : (toUnit==PositionUnit::RADIANS)?"RADIANS"
                        : "ENCODER_COUNTS";

    debugPrint("Position", value, fromStr, toStr, fFrom, fTo, inRef, outVal);
    return outVal;
}

float convertVelocity(float value, VelocityUnit fromUnit, VelocityUnit toUnit) {
    float fFrom = getFactor(fromUnit);
    float fTo   = getFactor(toUnit);

    float inRef  = value / fFrom;
    float outVal = inRef * fTo;

    const char* fromStr = "Unknown";
    switch(fromUnit) {
        case VelocityUnit::ROTATIONS_PER_SECOND: fromStr="RPS"; break;
        case VelocityUnit::RPM:                  fromStr="RPM"; break;
        case VelocityUnit::DEGREES_PER_SECOND:   fromStr="deg/s"; break;
        case VelocityUnit::RADIANS_PER_SECOND:   fromStr="rad/s"; break;
        case VelocityUnit::COUNTS_PER_SECOND:    fromStr="counts/s"; break;
    }
    const char* toStr = "Unknown";
    switch(toUnit) {
        case VelocityUnit::ROTATIONS_PER_SECOND: toStr="RPS"; break;
        case VelocityUnit::RPM:                  toStr="RPM"; break;
        case VelocityUnit::DEGREES_PER_SECOND:   toStr="deg/s"; break;
        case VelocityUnit::RADIANS_PER_SECOND:   toStr="rad/s"; break;
        case VelocityUnit::COUNTS_PER_SECOND:    toStr="counts/s"; break;
    }

    debugPrint("Velocity", value, fromStr, toStr, fFrom, fTo, inRef, outVal);
    return outVal;
}

float convertAcceleration(float value, AccelerationUnit fromUnit, AccelerationUnit toUnit) {
    float fFrom = getFactor(fromUnit);
    float fTo   = getFactor(toUnit);

    float inRef  = value / fFrom;
    float outVal = inRef * fTo;

    const char* fromStr = "Unknown";
    switch(fromUnit) {
        case AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED: fromStr="RPS^2"; break;
        case AccelerationUnit::RPM_PER_SECOND:               fromStr="rpm/s"; break;
        case AccelerationUnit::DEGREES_PER_SECOND_SQUARED:   fromStr="deg/s^2"; break;
        case AccelerationUnit::RADIANS_PER_SECOND_SQUARED:   fromStr="rad/s^2"; break;
        case AccelerationUnit::COUNTS_PER_SECOND_SQUARED:    fromStr="counts/s^2"; break;
    }
    const char* toStr = "Unknown";
    switch(toUnit) {
        case AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED: toStr="RPS^2"; break;
        case AccelerationUnit::RPM_PER_SECOND:               toStr="rpm/s"; break;
        case AccelerationUnit::DEGREES_PER_SECOND_SQUARED:   toStr="deg/s^2"; break;
        case AccelerationUnit::RADIANS_PER_SECOND_SQUARED:   toStr="rad/s^2"; break;
        case AccelerationUnit::COUNTS_PER_SECOND_SQUARED:    toStr="counts/s^2"; break;
    }

    debugPrint("Acceleration", value, fromStr, toStr, fFrom, fTo, inRef, outVal);
    return outVal;
}

float convertCurrent(float value, CurrentUnit fromUnit, CurrentUnit toUnit) {
    float fFrom = getFactor(fromUnit);
    float fTo   = getFactor(toUnit);

    float inRef  = value / fFrom;
    float outVal = inRef * fTo;

    const char* fromStr = (fromUnit==CurrentUnit::MILLIAMPS)?"mA":"A";
    const char* toStr   = (toUnit==CurrentUnit::MILLIAMPS)?"mA":"A";

    debugPrint("Current", value, fromStr, toStr, fFrom, fTo, inRef, outVal);
    return outVal;
}

float convertVoltage(float value, VoltageUnit fromUnit, VoltageUnit toUnit) {
    float fFrom = getFactor(fromUnit);
    float fTo   = getFactor(toUnit);

    float inRef  = value / fFrom;
    float outVal = inRef * fTo;

    const char* fromStr = (fromUnit==VoltageUnit::MILLIVOLTS)?"mV":"V";
    const char* toStr   = (toUnit==VoltageUnit::MILLIVOLTS)?"mV":"V";

    debugPrint("Voltage", value, fromStr, toStr, fFrom, fTo, inRef, outVal);
    return outVal;
}

float convertTemperature(float value, TemperatureUnit fromUnit, TemperatureUnit toUnit) {
    // Temperature offset-based conversion
    float celsius = 0.0f;
    switch(fromUnit) {
        case TemperatureUnit::CELSIUS:
            celsius = value;
            break;
        case TemperatureUnit::FAHRENHEIT:
            celsius = (value - 32.0f)*(5.0f/9.0f);
            break;
        case TemperatureUnit::KELVIN:
            celsius = value - 273.15f;
            break;
    }
    float outVal = 0.0f;
    switch(toUnit) {
        case TemperatureUnit::CELSIUS:
            outVal = celsius;
            break;
        case TemperatureUnit::FAHRENHEIT:
            outVal = celsius*(9.0f/5.0f)+32.0f;
            break;
        case TemperatureUnit::KELVIN:
            outVal = celsius+273.15f;
            break;
    }

    // Debug
    Serial.println();
    Serial.println("[DEBUG] Converting Temperature");
    Serial.print("  input value: ");
    Serial.println(value);
    Serial.print("  fromUnit: ");
    switch(fromUnit) {
        case TemperatureUnit::CELSIUS:    Serial.println("CELSIUS"); break;
        case TemperatureUnit::FAHRENHEIT: Serial.println("FAHRENHEIT"); break;
        case TemperatureUnit::KELVIN:     Serial.println("KELVIN"); break;
    }
    Serial.print("  intermediate (celsius) = ");
    Serial.println(celsius);
    Serial.print("  toUnit: ");
    switch(toUnit) {
        case TemperatureUnit::CELSIUS:    Serial.println("CELSIUS"); break;
        case TemperatureUnit::FAHRENHEIT: Serial.println("FAHRENHEIT"); break;
        case TemperatureUnit::KELVIN:     Serial.println("KELVIN"); break;
    }
    Serial.print("  outVal: ");
    Serial.println(outVal);
    Serial.println();

    return outVal;
}