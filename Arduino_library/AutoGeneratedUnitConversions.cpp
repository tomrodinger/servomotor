// This file was auto-generated by generate_unit_conversion_code.py on Mar 11 2025 20:27:03
// Do not edit manually. If changes are needed, modify the generator program instead.

#include "AutoGeneratedUnitConversions.h"
#include <math.h>

float convertTime(float value, TimeUnit unit, ConversionDirection direction)
{
    // Handle both simple conversions (multiplication/division) and complex conversions (with offsets)
    float result = 0.0f;

    // Step 1: Convert from user unit to internal unit if needed
    if (direction == ConversionDirection::TO_INTERNAL) {
        switch (unit) {
            case TimeUnit::TIMESTEPS:
                result = value; // Factor is 1.0, no conversion needed
                break;
            case TimeUnit::SECONDS:
                result = value * CONVERSION_FACTOR_SECONDS;
                break;
            case TimeUnit::MILLISECONDS:
                result = value * CONVERSION_FACTOR_MILLISECONDS;
                break;
            case TimeUnit::MINUTES:
                result = value * CONVERSION_FACTOR_MINUTES;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    // Step 2: Convert from internal unit to user unit if needed
    else { // direction == ConversionDirection::FROM_INTERNAL
        switch (unit) {
            case TimeUnit::TIMESTEPS:
                result = value; // Factor is 1.0, no conversion needed
                break;
            case TimeUnit::SECONDS:
                result = value / CONVERSION_FACTOR_SECONDS;
                break;
            case TimeUnit::MILLISECONDS:
                result = value / CONVERSION_FACTOR_MILLISECONDS;
                break;
            case TimeUnit::MINUTES:
                result = value / CONVERSION_FACTOR_MINUTES;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    return result;
}

float convertPosition(float value, PositionUnit unit, ConversionDirection direction)
{
    // Handle both simple conversions (multiplication/division) and complex conversions (with offsets)
    float result = 0.0f;

    // Step 1: Convert from user unit to internal unit if needed
    if (direction == ConversionDirection::TO_INTERNAL) {
        switch (unit) {
            case PositionUnit::SHAFT_ROTATIONS:
                result = value * CONVERSION_FACTOR_SHAFT_ROTATIONS;
                break;
            case PositionUnit::DEGREES:
                result = value * CONVERSION_FACTOR_DEGREES;
                break;
            case PositionUnit::RADIANS:
                result = value * CONVERSION_FACTOR_RADIANS;
                break;
            case PositionUnit::ENCODER_COUNTS:
                result = value; // Factor is 1.0, no conversion needed
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    // Step 2: Convert from internal unit to user unit if needed
    else { // direction == ConversionDirection::FROM_INTERNAL
        switch (unit) {
            case PositionUnit::SHAFT_ROTATIONS:
                result = value / CONVERSION_FACTOR_SHAFT_ROTATIONS;
                break;
            case PositionUnit::DEGREES:
                result = value / CONVERSION_FACTOR_DEGREES;
                break;
            case PositionUnit::RADIANS:
                result = value / CONVERSION_FACTOR_RADIANS;
                break;
            case PositionUnit::ENCODER_COUNTS:
                result = value; // Factor is 1.0, no conversion needed
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    return result;
}

float convertVelocity(float value, VelocityUnit unit, ConversionDirection direction)
{
    // Handle both simple conversions (multiplication/division) and complex conversions (with offsets)
    float result = 0.0f;

    // Step 1: Convert from user unit to internal unit if needed
    if (direction == ConversionDirection::TO_INTERNAL) {
        switch (unit) {
            case VelocityUnit::ROTATIONS_PER_SECOND:
                result = value * CONVERSION_FACTOR_ROTATIONS_PER_SECOND;
                break;
            case VelocityUnit::RPM:
                result = value * CONVERSION_FACTOR_RPM;
                break;
            case VelocityUnit::DEGREES_PER_SECOND:
                result = value * CONVERSION_FACTOR_DEGREES_PER_SECOND;
                break;
            case VelocityUnit::RADIANS_PER_SECOND:
                result = value * CONVERSION_FACTOR_RADIANS_PER_SECOND;
                break;
            case VelocityUnit::COUNTS_PER_SECOND:
                result = value * CONVERSION_FACTOR_COUNTS_PER_SECOND;
                break;
            case VelocityUnit::COUNTS_PER_TIMESTEP:
                result = value * CONVERSION_FACTOR_COUNTS_PER_TIMESTEP;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    // Step 2: Convert from internal unit to user unit if needed
    else { // direction == ConversionDirection::FROM_INTERNAL
        switch (unit) {
            case VelocityUnit::ROTATIONS_PER_SECOND:
                result = value / CONVERSION_FACTOR_ROTATIONS_PER_SECOND;
                break;
            case VelocityUnit::RPM:
                result = value / CONVERSION_FACTOR_RPM;
                break;
            case VelocityUnit::DEGREES_PER_SECOND:
                result = value / CONVERSION_FACTOR_DEGREES_PER_SECOND;
                break;
            case VelocityUnit::RADIANS_PER_SECOND:
                result = value / CONVERSION_FACTOR_RADIANS_PER_SECOND;
                break;
            case VelocityUnit::COUNTS_PER_SECOND:
                result = value / CONVERSION_FACTOR_COUNTS_PER_SECOND;
                break;
            case VelocityUnit::COUNTS_PER_TIMESTEP:
                result = value / CONVERSION_FACTOR_COUNTS_PER_TIMESTEP;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    return result;
}

float convertAcceleration(float value, AccelerationUnit unit, ConversionDirection direction)
{
    // Handle both simple conversions (multiplication/division) and complex conversions (with offsets)
    float result = 0.0f;

    // Step 1: Convert from user unit to internal unit if needed
    if (direction == ConversionDirection::TO_INTERNAL) {
        switch (unit) {
            case AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED:
                result = value * CONVERSION_FACTOR_ROTATIONS_PER_SECOND_SQUARED;
                break;
            case AccelerationUnit::RPM_PER_SECOND:
                result = value * CONVERSION_FACTOR_RPM_PER_SECOND;
                break;
            case AccelerationUnit::DEGREES_PER_SECOND_SQUARED:
                result = value * CONVERSION_FACTOR_DEGREES_PER_SECOND_SQUARED;
                break;
            case AccelerationUnit::RADIANS_PER_SECOND_SQUARED:
                result = value * CONVERSION_FACTOR_RADIANS_PER_SECOND_SQUARED;
                break;
            case AccelerationUnit::COUNTS_PER_SECOND_SQUARED:
                result = value * CONVERSION_FACTOR_COUNTS_PER_SECOND_SQUARED;
                break;
            case AccelerationUnit::COUNTS_PER_TIMESTEP_SQUARED:
                result = value * CONVERSION_FACTOR_COUNTS_PER_TIMESTEP_SQUARED;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    // Step 2: Convert from internal unit to user unit if needed
    else { // direction == ConversionDirection::FROM_INTERNAL
        switch (unit) {
            case AccelerationUnit::ROTATIONS_PER_SECOND_SQUARED:
                result = value / CONVERSION_FACTOR_ROTATIONS_PER_SECOND_SQUARED;
                break;
            case AccelerationUnit::RPM_PER_SECOND:
                result = value / CONVERSION_FACTOR_RPM_PER_SECOND;
                break;
            case AccelerationUnit::DEGREES_PER_SECOND_SQUARED:
                result = value / CONVERSION_FACTOR_DEGREES_PER_SECOND_SQUARED;
                break;
            case AccelerationUnit::RADIANS_PER_SECOND_SQUARED:
                result = value / CONVERSION_FACTOR_RADIANS_PER_SECOND_SQUARED;
                break;
            case AccelerationUnit::COUNTS_PER_SECOND_SQUARED:
                result = value / CONVERSION_FACTOR_COUNTS_PER_SECOND_SQUARED;
                break;
            case AccelerationUnit::COUNTS_PER_TIMESTEP_SQUARED:
                result = value / CONVERSION_FACTOR_COUNTS_PER_TIMESTEP_SQUARED;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    return result;
}

float convertCurrent(float value, CurrentUnit unit, ConversionDirection direction)
{
    // Handle both simple conversions (multiplication/division) and complex conversions (with offsets)
    float result = 0.0f;

    // Step 1: Convert from user unit to internal unit if needed
    if (direction == ConversionDirection::TO_INTERNAL) {
        switch (unit) {
            case CurrentUnit::INTERNAL_CURRENT_UNITS:
                result = value; // Factor is 1.0, no conversion needed
                break;
            case CurrentUnit::MILLIAMPS:
                result = value * CONVERSION_FACTOR_MILLIAMPS;
                break;
            case CurrentUnit::AMPS:
                result = value * CONVERSION_FACTOR_AMPS;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    // Step 2: Convert from internal unit to user unit if needed
    else { // direction == ConversionDirection::FROM_INTERNAL
        switch (unit) {
            case CurrentUnit::INTERNAL_CURRENT_UNITS:
                result = value; // Factor is 1.0, no conversion needed
                break;
            case CurrentUnit::MILLIAMPS:
                result = value / CONVERSION_FACTOR_MILLIAMPS;
                break;
            case CurrentUnit::AMPS:
                result = value / CONVERSION_FACTOR_AMPS;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    return result;
}

float convertVoltage(float value, VoltageUnit unit, ConversionDirection direction)
{
    // Handle both simple conversions (multiplication/division) and complex conversions (with offsets)
    float result = 0.0f;

    // Step 1: Convert from user unit to internal unit if needed
    if (direction == ConversionDirection::TO_INTERNAL) {
        switch (unit) {
            case VoltageUnit::MILLIVOLTS:
                result = value * CONVERSION_FACTOR_MILLIVOLTS;
                break;
            case VoltageUnit::VOLTS:
                result = value * CONVERSION_FACTOR_VOLTS;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    // Step 2: Convert from internal unit to user unit if needed
    else { // direction == ConversionDirection::FROM_INTERNAL
        switch (unit) {
            case VoltageUnit::MILLIVOLTS:
                result = value / CONVERSION_FACTOR_MILLIVOLTS;
                break;
            case VoltageUnit::VOLTS:
                result = value / CONVERSION_FACTOR_VOLTS;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    return result;
}

float convertTemperature(float value, TemperatureUnit unit, ConversionDirection direction)
{
    // Handle both simple conversions (multiplication/division) and complex conversions (with offsets)
    float result = 0.0f;

    // Step 1: Convert from user unit to internal unit if needed
    if (direction == ConversionDirection::TO_INTERNAL) {
        switch (unit) {
            case TemperatureUnit::CELSIUS:
                result = value; // Factor is 1.0, no conversion needed
                break;
            case TemperatureUnit::FAHRENHEIT:
                result = (value + CONVERSION_OFFSET_FAHRENHEIT_TO_CELSIUS) * CONVERSION_FACTOR_FAHRENHEIT;
                break;
            case TemperatureUnit::KELVIN:
                result = value + CONVERSION_OFFSET_KELVIN_TO_CELSIUS;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    // Step 2: Convert from internal unit to user unit if needed
    else { // direction == ConversionDirection::FROM_INTERNAL
        switch (unit) {
            case TemperatureUnit::CELSIUS:
                result = value; // Factor is 1.0, no conversion needed
                break;
            case TemperatureUnit::FAHRENHEIT:
                result = (value / CONVERSION_FACTOR_FAHRENHEIT) + CONVERSION_OFFSET_CELSIUS_TO_FAHRENHEIT;
                break;
            case TemperatureUnit::KELVIN:
                result = value + CONVERSION_OFFSET_CELSIUS_TO_KELVIN;
                break;
            default:
                return 0.0f; // Invalid unit
        }
    }
    return result;
}

