#!/usr/bin/env python3

"""
generate_arduino_unit_conversions.py

Generates:
  AutoGeneratedUnitConversions.h
  AutoGeneratedUnitConversions.cpp

This script generates unit conversion functions that convert directly between
user units and internal units, with a direction parameter to control the conversion.
"""

import sys
import json
import os
from datetime import datetime

HEADER_GUARD = "AUTO_GENERATED_UNIT_CONVERSIONS_H"
CPP_FILENAME = "AutoGeneratedUnitConversions.cpp"
H_FILENAME = "AutoGeneratedUnitConversions.h"

def main(json_filename):
    with open(json_filename, 'r') as f:
        data = json.load(f)

    units_dict = data["units"]              # e.g. {"time": [...], "position": [...], ...}
    factors = data["conversion_factors"]    # e.g. { "seconds": 31250.0, "milliseconds": 31.25, ... }

    # Write .h file
    with open(H_FILENAME, 'w') as hf:
        now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        hf.write(f"#ifndef {HEADER_GUARD}\n")
        hf.write(f"#define {HEADER_GUARD}\n\n")
        hf.write(f"// This file was auto-generated by generate_unit_conversion_code.py on {now}\n")
        hf.write("// Do not edit manually. If changes are needed, modify the generator program instead.\n\n")
        
        # Add COUNTS_PER_REVOLUTION definition
        counts_per_revolution = int(factors.get("shaft_rotations", 3276800))
        hf.write(f"// Define the number of encoder counts per revolution\n")
        hf.write(f"#define COUNTS_PER_REVOLUTION {counts_per_revolution}\n\n")

        # Add ConversionDirection enum
        hf.write("// Enum to specify the direction of unit conversion\n")
        hf.write("enum class ConversionDirection {\n")
        hf.write("    TO_INTERNAL,    // Convert from user unit to internal unit\n")
        hf.write("    FROM_INTERNAL   // Convert from internal unit to user unit\n")
        hf.write("};\n\n")

        for category, unit_list in units_dict.items():
            enum_name = category.capitalize() + "Unit"  # e.g. "TimeUnit"

            # Generate an enum for the category
            hf.write(f"enum class {enum_name} {{\n")
            for i, unit_name in enumerate(unit_list):
                enumerator = unit_name.upper().replace(" ", "_")
                suffix = "," if i < len(unit_list) - 1 else ""
                hf.write(f"    {enumerator}{suffix}\n")
            hf.write("};\n\n")

            # Declare the conversion function with direction parameter
            func_name = f"convert{category.capitalize()}"
            hf.write(f"float {func_name}(float value, {enum_name} unit, ConversionDirection direction);\n\n")

        hf.write(f"#endif // {HEADER_GUARD}\n")

    # Write .cpp file
    with open(CPP_FILENAME, 'w') as cf:
        now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        cf.write(f"// This file was auto-generated by generate_unit_conversion_code.py on {now}\n")
        cf.write("// Do not edit manually. If changes are needed, modify the generator program instead.\n\n")
        cf.write(f'#include "{H_FILENAME}"\n')
        cf.write("#include <math.h>\n\n")

        # Generate a conversion function per category
        for category, unit_list in units_dict.items():
            enum_name = category.capitalize() + "Unit"
            func_name = f"convert{category.capitalize()}"
            internal_unit = unit_list[0]  # First unit in the list is the internal unit

            cf.write(f"float {func_name}(float value, {enum_name} unit, ConversionDirection direction)\n")
            cf.write("{\n")

            # Handle temperature specially with offset-based conversions
            if category == "temperature":
                cf.write("    // Temperature conversions: celsius <-> fahrenheit <-> kelvin\n")
                cf.write("    // Internal unit is CELSIUS\n\n")
                cf.write("    if (direction == ConversionDirection::TO_INTERNAL) {\n")
                cf.write("        // Convert from user unit to internal unit (CELSIUS)\n")
                cf.write("        switch (unit) {\n")
                cf.write("            case TemperatureUnit::CELSIUS:\n")
                cf.write("                return value; // Already in internal unit\n")
                cf.write("            case TemperatureUnit::FAHRENHEIT:\n")
                cf.write("                return (value - 32.0f) * (5.0f/9.0f);\n")
                cf.write("            case TemperatureUnit::KELVIN:\n")
                cf.write("                return value - 273.15f;\n")
                cf.write("            default:\n")
                cf.write("                return 0.0f; // Invalid unit\n")
                cf.write("        }\n")
                cf.write("    } else {\n")
                cf.write("        // Convert from internal unit (CELSIUS) to user unit\n")
                cf.write("        switch (unit) {\n")
                cf.write("            case TemperatureUnit::CELSIUS:\n")
                cf.write("                return value; // Already in user unit\n")
                cf.write("            case TemperatureUnit::FAHRENHEIT:\n")
                cf.write("                return (value * 9.0f/5.0f) + 32.0f;\n")
                cf.write("            case TemperatureUnit::KELVIN:\n")
                cf.write("                return value + 273.15f;\n")
                cf.write("            default:\n")
                cf.write("                return 0.0f; // Invalid unit\n")
                cf.write("        }\n")
                cf.write("    }\n")
                cf.write("}\n\n")
                continue

            # For other categories, handle direct conversion based on direction
            cf.write("    switch (unit) {\n")
            
            for u in unit_list:
                enumerator = u.upper().replace(" ", "_")
                factor = factors.get(u, 1.0)
                
                # Use the conversion factor directly from the JSON file
                
                cf.write(f"        case {enum_name}::{enumerator}:\n")
                
                # Always convert based on direction
                cf.write("            if (direction == ConversionDirection::TO_INTERNAL) {\n")
                cf.write(f"                return value * {factor:.9f}; // Convert to internal unit\n")
                cf.write("            } else {\n")
                cf.write(f"                return value / {factor:.9f}; // Convert from internal unit\n")
                cf.write("            }\n")
                
            cf.write("        default:\n")
            cf.write("            return 0.0f; // Invalid unit\n")
            cf.write("    }\n")
            cf.write("}\n\n")

    print(f"Generated {H_FILENAME} and {CPP_FILENAME} successfully.")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python generate_arduino_unit_conversions.py <unit_conversions.json>")
        sys.exit(1)
    json_file = sys.argv[1]
    if not os.path.isfile(json_file):
        print(f"Error: cannot find the file {json_file}")
        sys.exit(1)
    main(json_file)
