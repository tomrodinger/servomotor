#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "stm32g0xx_hal.h"
#include "CommutationTable.h"  // generated by a program called process_raw_hall_data.py
#include "hall_sensor_calculations.h"
#include "error_handling.h"
#include "ADC.h"
#include "PWM.h"
#include "RS485.h"
#include "debug_uart.h"
#include "LookupTableZ.h"
#include "global_variables.h"
#include "circular_buffer.h"

// search lan
// nameserver 114.114.114.119
// udhcpc -t 3 -i br-lan -C -O 121
// /usr/bin/mjpg_streamer -i "input_uvc.so -d /dev/video0 -resolution 320x240" -o "output_http.so -www /www/webcam"

#define UINT32_MIDPOINT 2147483648
#define HALL_POSITION_HYSTERESIS 100
#define NUMBER_OF_MOTORS 2
#define BUFFER_SIZE 2
#define BUFFER_SHIFT 4

// static const struct hall_weights_struct hall_weights = HALL_WEIGHTS_INITIALIZER;
// static int32_t sensor_incremental_position = 0;
// static int32_t hall_sensor_offset = 0;
// static int32_t hall_position_with_hysteresis = 0;
// static uint16_t time_difference_div = 0;

// static const struct hall_weights_struct hall_weights_1 = HALL_WEIGHTS_INITIALIZER;
// static const struct hall_weights_struct hall_weights_2 = HALL_WEIGHTS_INITIALIZER;
// static int32_t sensor_incremental_position_1 = 0;
// static int32_t sensor_incremental_position_2 = 0;
// static int32_t hall_sensor_offset_1 = 0;
// static int32_t hall_sensor_offset_2 = 0;
// static int32_t hall_position_with_hysteresis_1 = 0;
// static int32_t hall_position_with_hysteresis_2 = 0;

int8_t M_index = 1;

static const struct hall_weights_struct hall_weights_1_2 = HALL_WEIGHTS_INITIALIZER_1_2;
static const struct hall_weights_struct hall_weights_3_4 = HALL_WEIGHTS_INITIALIZER_3_4;
static int32_t sensor_incremental_position[NUMBER_OF_MOTORS] = {0, 0};
static int32_t hall_sensor_offset[NUMBER_OF_MOTORS] = {0, 0};
static int32_t hall_position_with_hysteresis[NUMBER_OF_MOTORS] = {0, 0};
static int32_t fraction_for_print = 0;
static uint16_t time_difference_div = 0;

uint16_t buffer_1[BUFFER_SIZE];
uint16_t buffer_2[BUFFER_SIZE];
uint16_t buffer_3[BUFFER_SIZE];
uint16_t buffer_4[BUFFER_SIZE];
static circular_buf_t *cbuf_1, *cbuf_2, *cbuf_3, *cbuf_4;
uint16_t Counter_1 = 0, Counter_2 = 0;
int32_t sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0;
int first_time_running1 = 1;
int first_time_running2 = 1;
uint16_t smoothed_hall_sensor_readings[2] = {0, 0};

void switch_motor()
{
    TIM1->DIER &= ~TIM_DIER_UIE;
    clear_the_queue_and_stop_no_disable_interrupt();
    M_index = !M_index;
    TIM1->DIER |= TIM_DIER_UIE;
    char buf[30];
    sprintf(buf, "Now using motor %d\n", M_index);
    transmit(buf, strlen(buf));
}

void set_current_motor_index(int index)
{
    if(index + 1 > NUMBER_OF_MOTORS) {
        fatal_error(29);
    } else {
        M_index = index;
    }
}

void adjust_hall_sensor_readings(uint16_t hall_sensor_readings[2], int32_t adjusted_hall_sensor_readings[2])
{
    int32_t d0_shifted, d1_shifted;
    if(M_index == 0) {
        d0_shifted = (int32_t)(hall_sensor_readings[0] - HALL1_MIDLINE);
    	d1_shifted = (int32_t)(hall_sensor_readings[1] - HALL2_MIDLINE);
        int32_t d0 = d0_shifted * hall_weights_1_2.h1[0] + d1_shifted * hall_weights_1_2.h2[0];
        int32_t d1 = d0_shifted * hall_weights_1_2.h1[1] + d1_shifted * hall_weights_1_2.h2[1];
        adjusted_hall_sensor_readings[0] = d0 >> 7;
        adjusted_hall_sensor_readings[1] = d1 >> 7;
    } else {
        d0_shifted = (int32_t)(hall_sensor_readings[0] - HALL3_MIDLINE);
    	d1_shifted = (int32_t)(hall_sensor_readings[1] - HALL4_MIDLINE);
        int32_t d0 = d0_shifted * hall_weights_3_4.h1[0] + d1_shifted * hall_weights_3_4.h2[0];
        int32_t d1 = d0_shifted * hall_weights_3_4.h1[1] + d1_shifted * hall_weights_3_4.h2[1];
        adjusted_hall_sensor_readings[0] = d0;
        adjusted_hall_sensor_readings[1] = d1;
    }
}

uint8_t get_region(uint8_t hall_data_sign[2], uint8_t hall_data_order) {
    if(hall_data_sign[0] == 1) {
        //(+, +)
        if(hall_data_sign[1] == 1) {
            if(hall_data_order) return 1;
            else return 2;
        }
        //(+, -)
        else {
            if(hall_data_order) return 8;
            else return 7;
        }
    }
    else {
        //(-, +)
        if(hall_data_sign[1] == 1) {
            if(hall_data_order) return 4;
            else return 3;
        }
        //(-, -)
        else {
            if(hall_data_order) return 5;
            else return 6;
        }
    }
}

inline int32_t get_max(int32_t a, int32_t b) {
	if(a > b) return a;
	return b;
}

inline int32_t get_min(int32_t a, int32_t b) {
	if(a > b) return b;
	return a;
}

int32_t get_hall_position1(void) {

	uint16_t hall_sensor_readings[2];
    int32_t d[2];
    uint8_t hall1_hall2_sign[2];
    uint8_t hall1_hall2_order = -1;
    static uint8_t prev_region = -1;
    static uint8_t curr_region = -1;
    // float ratio;
    int32_t numerator;
    int32_t denominator;
    int32_t fraction = 0;

    hall_sensor_readings[0] = (get_hall_sensor1_voltage() << 3) - HALL_SENSOR_SHIFT;
    hall_sensor_readings[1] = (get_hall_sensor2_voltage() << 3) - HALL_SENSOR_SHIFT;

    smoothed_hall_sensor_readings[0] = hall_sensor_readings[0];
    smoothed_hall_sensor_readings[1] = hall_sensor_readings[1];

    adjust_hall_sensor_readings(hall_sensor_readings, d);

    hall1_hall2_sign[0] = d[0] >= 0? 1 : 0;
    hall1_hall2_sign[1] = d[1] >= 0? 1 : 0;
    d[0] = abs(d[0]);
    d[1] = abs(d[1]);
    hall1_hall2_order = d[0] > d[1]? 1 : 0;

    curr_region = get_region(hall1_hall2_sign, hall1_hall2_order);
    if(prev_region < 0) {
        prev_region = curr_region;
    }
    numerator = get_max(d[0], d[1]) - get_min(d[0], d[1]);
    denominator = d[0] + d[1];

    if(curr_region % 2 != 0) {
        // ratio = 1 - (float)numerator / (float)denominator;
        fraction = (denominator - numerator) * SENSOR_SEGMENT_RESOLUTION / denominator;
    }
    else {
        // ratio = (float)numerator / (float)denominator;
        fraction = numerator * SENSOR_SEGMENT_RESOLUTION / denominator;
    }
    fraction_for_print = fraction;

    if(curr_region != prev_region) {
        if(curr_region - prev_region == 1 || curr_region - prev_region == -7) {
            sensor_incremental_position[0] += SENSOR_SEGMENT_RESOLUTION;
        }
        else if(curr_region - prev_region == -1 || curr_region - prev_region == 7) {
            sensor_incremental_position[0] -= SENSOR_SEGMENT_RESOLUTION;
        }
    }

    prev_region = curr_region;
    return sensor_incremental_position[0] + fraction - hall_sensor_offset[0];
}

int32_t get_hall_position2(void) {

	uint16_t hall_sensor_readings[2];
    int32_t d[2];
    uint8_t hall3_hall4_sign[2];
    uint8_t hall3_hall4_order = -1;
    static uint8_t prev_region = -1;
    static uint8_t curr_region = -1;
    int64_t numerator;
    int64_t denominator;
    int32_t fraction = 0;

    hall_sensor_readings[0] = (get_hall_sensor3_voltage() << 3) - HALL_SENSOR_SHIFT;
    hall_sensor_readings[1] = (get_hall_sensor4_voltage() << 3) - HALL_SENSOR_SHIFT;

    smoothed_hall_sensor_readings[0] = hall_sensor_readings[0];
    smoothed_hall_sensor_readings[1] = hall_sensor_readings[1];

    adjust_hall_sensor_readings(hall_sensor_readings, d);

    hall3_hall4_sign[0] = d[0] >= 0? 1 : 0;
    hall3_hall4_sign[1] = d[1] >= 0? 1 : 0;
    d[0] = abs(d[0]);
    d[1] = abs(d[1]);
    hall3_hall4_order = d[0] > d[1]? 1: 0;

    curr_region = get_region(hall3_hall4_sign, hall3_hall4_order);
    if(prev_region < 0) {
        prev_region = curr_region;
    }
    numerator = get_max(d[0], d[1]) - get_min(d[0], d[1]);
    denominator = d[0] + d[1];

    if(curr_region % 2 != 0) {
        fraction = (denominator - numerator) * SENSOR_SEGMENT_RESOLUTION / denominator;
    }
    else {
        fraction = numerator * SENSOR_SEGMENT_RESOLUTION / denominator;
    }

    if(curr_region != prev_region) {
        if(curr_region - prev_region == 1 || curr_region - prev_region == -7) {
            sensor_incremental_position[1] += SENSOR_SEGMENT_RESOLUTION;
        }
        else if(curr_region - prev_region == -1 || curr_region - prev_region == 7) {
            sensor_incremental_position[1] -= SENSOR_SEGMENT_RESOLUTION;
        }
    }

    prev_region = curr_region;
    return sensor_incremental_position[1] + fraction - hall_sensor_offset[1];
}


// int32_t get_hall_position1(void) {
//
// 	uint16_t hall_sensor_readings[2];
// 	// uint16_t smoothed_hall_sensor_readings[2] = {0, 0};
//     int32_t d[2];
//     uint8_t hall1_hall2_sign[2];
//     uint8_t hall1_hall2_order = -1;
//     static uint8_t prev_region = -1;
//     static uint8_t curr_region = -1;
//     // float ratio;
//     int32_t numerator;
//     int32_t denominator;
//     int32_t fraction = 0;
//
//     if(first_time_running1) {
//     	cbuf_1 = circular_buf_init(buffer_1, BUFFER_SIZE);
//     	cbuf_2 = circular_buf_init(buffer_2, BUFFER_SIZE);
//     	first_time_running1 = 0;
//     }
//
//     hall_sensor_readings[0] = (get_hall_sensor1_voltage() << 3) - HALL_SENSOR_SHIFT;
//     hall_sensor_readings[1] = (get_hall_sensor2_voltage() << 3) - HALL_SENSOR_SHIFT;
//
//     if(Counter_1 < BUFFER_SIZE) {
//     	Counter_1++;
//     	circular_buf_put(cbuf_1, hall_sensor_readings[0]);
//     	circular_buf_put(cbuf_2, hall_sensor_readings[1]);
//     	sum1 += hall_sensor_readings[0];
//     	sum2 += hall_sensor_readings[1];
//         return 0;
//     } else {
//     	uint16_t avg0 = (sum1 / BUFFER_SIZE);
//     	uint16_t avg1 = (sum2 / BUFFER_SIZE);
//     	smoothed_hall_sensor_readings[0] = avg0;
// 		smoothed_hall_sensor_readings[1] = avg1;
//     	uint16_t data0, data1;
//     	data0 = circular_buf_get(cbuf_1);
//     	data1 = circular_buf_get(cbuf_2);
//     	sum1 -= data0;
//     	sum2 -= data1;
//     	circular_buf_put(cbuf_1, hall_sensor_readings[0]);
//     	circular_buf_put(cbuf_2, hall_sensor_readings[1]);
//     	sum1 += hall_sensor_readings[0];
//     	sum2 += hall_sensor_readings[1];
//     }
//
//     // char buf[20];
//     // sprintf(buf, "%d  %d\n", smoothed_hall_sensor_readings[0], smoothed_hall_sensor_readings[1]);
//     // transmit(buf, strlen(buf));
//
//     adjust_hall_sensor_readings(smoothed_hall_sensor_readings, d);
//
//     // char buf[30];
//     // sprintf(buf, "%ld %ld\n", d[0], d[1]);
//     // transmit(buf, strlen(buf));
//
//     hall1_hall2_sign[0] = d[0] >= 0? 1 : 0;
//     hall1_hall2_sign[1] = d[1] >= 0? 1 : 0;
//     d[0] = abs(d[0]);
//     d[1] = abs(d[1]);
//     hall1_hall2_order = d[0] > d[1]? 1 : 0;
//
//     curr_region = get_region(hall1_hall2_sign, hall1_hall2_order);
//     if(prev_region < 0) {
//         prev_region = curr_region;
//     }
//     numerator = get_max(d[0], d[1]) - get_min(d[0], d[1]);
//     denominator = d[0] + d[1];
//
//     if(curr_region % 2 != 0) {
//         // ratio = 1 - (float)numerator / (float)denominator;
//         fraction = (denominator - numerator) * SENSOR_SEGMENT_RESOLUTION / denominator;
//     }
//     else {
//         // ratio = (float)numerator / (float)denominator;
//         fraction = numerator * SENSOR_SEGMENT_RESOLUTION / denominator;
//     }
//     fraction_for_print = fraction;
//     // fraction = (int32_t)(ratio * SENSOR_SEGMENT_RESOLUTION);
//     // char buf[20];
//     // sprintf(buf, "%ld\n", fraction);
//     // transmit(buf, strlen(buf));
//
//     if(curr_region != prev_region) {
//         if(curr_region - prev_region == 1 || curr_region - prev_region == -7) {
//             sensor_incremental_position[0] += SENSOR_SEGMENT_RESOLUTION;
//         }
//         else if(curr_region - prev_region == -1 || curr_region - prev_region == 7) {
//             sensor_incremental_position[0] -= SENSOR_SEGMENT_RESOLUTION;
//         }
//     }
//
//     prev_region = curr_region;
//     return sensor_incremental_position[0] + fraction - hall_sensor_offset[0];
// }
//
// int32_t get_hall_position2(void) {
//
// 	uint16_t hall_sensor_readings[2];
// 	// uint16_t smoothed_hall_sensor_readings[2] = {0, 0};
//     int32_t d[2];
//     uint8_t hall3_hall4_sign[2];
//     uint8_t hall3_hall4_order = -1;
//     static uint8_t prev_region = -1;
//     static uint8_t curr_region = -1;
//     int64_t numerator;
//     int64_t denominator;
//     int32_t fraction = 0;
//
//     if(first_time_running2) {
//     	cbuf_3 = circular_buf_init(buffer_3, BUFFER_SIZE);
//     	cbuf_4 = circular_buf_init(buffer_4, BUFFER_SIZE);
//     	first_time_running2 = 0;
//     }
//
//     hall_sensor_readings[0] = (get_hall_sensor3_voltage() << 3) - HALL_SENSOR_SHIFT;
//     hall_sensor_readings[1] = (get_hall_sensor4_voltage() << 3) - HALL_SENSOR_SHIFT;
//
//     if(Counter_2 < BUFFER_SIZE) {
//     	Counter_2++;
//     	circular_buf_put(cbuf_3, hall_sensor_readings[0]);
//     	circular_buf_put(cbuf_4, hall_sensor_readings[1]);
//     	sum3 += hall_sensor_readings[0];
//     	sum4 += hall_sensor_readings[1];
//         return 0;
//     } else {
//     	uint16_t avg0 = (uint16_t)(sum3 / BUFFER_SIZE);
//     	uint16_t avg1 = (uint16_t)(sum4 / BUFFER_SIZE);
//     	smoothed_hall_sensor_readings[0] = avg0;
// 		smoothed_hall_sensor_readings[1] = avg1;
//     	uint16_t data0, data1;
//     	data0 = circular_buf_get(cbuf_3);
//     	data1 = circular_buf_get(cbuf_4);
//     	sum3 -= data0;
//     	sum4 -= data1;
//     	circular_buf_put(cbuf_3, hall_sensor_readings[0]);
//     	circular_buf_put(cbuf_4, hall_sensor_readings[1]);
//     	sum3 += hall_sensor_readings[0];
//     	sum4 += hall_sensor_readings[1];
//     }
//
//     // char buf[20];
//     // sprintf(buf, "%d  %d\n", smoothed_hall_sensor_readings[0], smoothed_hall_sensor_readings[1]);
//     // transmit(buf, strlen(buf));
//
//     adjust_hall_sensor_readings(smoothed_hall_sensor_readings, d);
//
//     hall3_hall4_sign[0] = d[0] >= 0? 1 : 0;
//     hall3_hall4_sign[1] = d[1] >= 0? 1 : 0;
//     d[0] = abs(d[0]);
//     d[1] = abs(d[1]);
//     hall3_hall4_order = d[0] > d[1]? 1: 0;
//
//     curr_region = get_region(hall3_hall4_sign, hall3_hall4_order);
//     if(prev_region < 0) {
//         prev_region = curr_region;
//     }
//     numerator = get_max(d[0], d[1]) - get_min(d[0], d[1]);
//     denominator = d[0] + d[1];
//
//     if(curr_region % 2 != 0) {
//         fraction = (denominator - numerator) * SENSOR_SEGMENT_RESOLUTION / denominator;
//     }
//     else {
//         fraction = numerator * SENSOR_SEGMENT_RESOLUTION / denominator;
//     }
//
//     if(curr_region != prev_region) {
//         if(curr_region - prev_region == 1 || curr_region - prev_region == -7) {
//             sensor_incremental_position[1] += SENSOR_SEGMENT_RESOLUTION;
//         }
//         else if(curr_region - prev_region == -1 || curr_region - prev_region == 7) {
//             sensor_incremental_position[1] -= SENSOR_SEGMENT_RESOLUTION;
//         }
//     }
//
//     prev_region = curr_region;
//     return sensor_incremental_position[1] + fraction - hall_sensor_offset[1];
// }

int32_t get_hall_position(void)
{
    if(M_index == 0) {
        return get_hall_position1();
    } else {
        return get_hall_position2();
    }
}

int32_t get_hall_position_with_hysteresis(void)
{
	int32_t hall_position;

	hall_position = get_hall_position();
	if(hall_position > hall_position_with_hysteresis[M_index]) {
		hall_position_with_hysteresis[M_index] = hall_position;
	}
	else if(hall_position + HALL_POSITION_HYSTERESIS < hall_position_with_hysteresis[M_index]) {
		hall_position_with_hysteresis[M_index] = hall_position + HALL_POSITION_HYSTERESIS;
	}

	return hall_position_with_hysteresis[M_index];
}


void zero_hall_position(void)
{
	sensor_incremental_position[M_index] = 0;
	hall_sensor_offset[M_index] = 0;
	int32_t hall_position = get_hall_position();
	hall_sensor_offset[M_index] = hall_position;
}

void print_fraction(void)
{
    char buf[20];
    sprintf(buf, "%ld\n", fraction_for_print);
	transmit(buf, strlen(buf));
}


void print_hall_position_and_time_difference(void)
{
	char buf[20];
    uint16_t start_time = TIM14->CNT;
	int32_t hall_position = get_hall_position();
    uint16_t end_time = TIM14->CNT;
    time_difference_div = end_time - start_time;
	// sprintf(buf, "hall_position: %d time_difference_div: %hu\n", (int)hall_position, time_difference_div);
    sprintf(buf, "%ld\n", hall_position);
	transmit(buf, strlen(buf));
}

void print_hall_sensor_value(void)
{
    char buf[20];
    sprintf(buf, "%d %d\n", smoothed_hall_sensor_readings[0], smoothed_hall_sensor_readings[1]);
    transmit(buf, strlen(buf));
}


void print_hall_midlines(void)
{
    char buf[100];
    sprintf(buf, "Hall sensor midlines: %u %u %u\n", global_settings.hall1_midline, global_settings.hall2_midline, global_settings.hall3_midline);
    transmit(buf, strlen(buf));
}

uint16_t get_smoothed_hall_sensor1_voltage() {
    return smoothed_hall_sensor_readings[0];
}

uint16_t get_smoothed_hall_sensor2_voltage() {
    return smoothed_hall_sensor_readings[1];
}

uint16_t get_smoothed_hall_sensor3_voltage() {
    return smoothed_hall_sensor_readings[0];
}

uint16_t get_smoothed_hall_sensor4_voltage() {
    return smoothed_hall_sensor_readings[1];
}
