#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "stm32g0xx_hal.h"
#include "CommutationTable.h"  // generated by a program called process_raw_hall_data.py
#include "hall_sensor_calculations.h"
#include "error_handling.h"
#include "ADC.h"
#include "debug_uart.h"
#include "LookupTableZ.h"
#include "global_variables.h"


#define UINT32_MIDPOINT 2147483648
#define HALL_POSITION_HYSTERESIS 100

static const struct hall_weights_struct hall_weights = HALL_WEIGHTS_INITIALIZER;

extern uint16_t ADC_buffer[DMA_ADC_BUFFER_SIZE];

static int8_t previous_largest_sensor = -1;
static int32_t sensor_incremental_position = 0;
static int32_t hall_sensor_offset = 0;
static uint16_t time_difference_div = 0;
static int32_t hall_position_with_hysteresis = 0;
static uint8_t hall_sensor_statitics_active = 0;
static hall_sensor_statistics_t hall_sensor_statistics;

void adjust_hall_sensor_readings(uint16_t hall_sensor_readings[N_HALL_SENSORS], int32_t adjusted_hall_sensor_readings[N_HALL_SENSORS])
{
    int32_t d0_shifted = (int32_t)hall_sensor_readings[0] - (int32_t)global_settings.hall1_midline;
    int32_t d1_shifted = (int32_t)hall_sensor_readings[1] - (int32_t)global_settings.hall2_midline;
    int32_t d2_shifted = (int32_t)hall_sensor_readings[2] - (int32_t)global_settings.hall3_midline;
    int32_t d3_shifted = (int32_t)hall_sensor_readings[3] - (int32_t)global_settings.hall4_midline;
    int32_t d0 = (d0_shifted * hall_weights.h1[0] + d1_shifted * hall_weights.h1[1]);
    int32_t d1 = (d1_shifted * hall_weights.h2[0] + d0_shifted * hall_weights.h2[1]);
    int32_t d2 = (d2_shifted * hall_weights.h3[0] + d3_shifted * hall_weights.h3[1]);
    int32_t d3 = (d3_shifted * hall_weights.h4[0] + d2_shifted * hall_weights.h4[1]);
    adjusted_hall_sensor_readings[0] = d0;
    adjusted_hall_sensor_readings[1] = d1;
    adjusted_hall_sensor_readings[2] = d2;
    adjusted_hall_sensor_readings[3] = d3;
}

int32_t get_hall_position(void)
{
    uint16_t hall_sensor_readings[N_HALL_SENSORS];
    int32_t d[N_HALL_SENSORS];
    int8_t largest_sensor;
    int32_t numerator;
    int32_t denominator;
    int32_t fraction;
    static uint16_t start_time;
    static uint16_t end_time;


    hall_sensor_readings[0] = ((ADC_buffer[HALL1_ADC_CYCLE_INDEX] + ADC_buffer[HALL1_ADC_CYCLE_INDEX + 8] +
                                ADC_buffer[HALL1_ADC_CYCLE_INDEX + 16] + ADC_buffer[HALL1_ADC_CYCLE_INDEX + 24]) << 3) - HALL_SENSOR_SHIFT;
    hall_sensor_readings[1] = ((ADC_buffer[HALL2_ADC_CYCLE_INDEX] + ADC_buffer[HALL2_ADC_CYCLE_INDEX + 8] +
                                ADC_buffer[HALL2_ADC_CYCLE_INDEX + 16] + ADC_buffer[HALL2_ADC_CYCLE_INDEX + 24]) << 3) - HALL_SENSOR_SHIFT;
    hall_sensor_readings[2] = ((ADC_buffer[HALL3_ADC_CYCLE_INDEX] + ADC_buffer[HALL3_ADC_CYCLE_INDEX + 8] +
                                ADC_buffer[HALL3_ADC_CYCLE_INDEX + 16] + ADC_buffer[HALL3_ADC_CYCLE_INDEX + 24]) << 3) - HALL_SENSOR_SHIFT;
    hall_sensor_readings[3] = ((ADC_buffer[HALL4_ADC_CYCLE_INDEX] + ADC_buffer[HALL4_ADC_CYCLE_INDEX + 8] +
                                ADC_buffer[HALL4_ADC_CYCLE_INDEX + 16] + ADC_buffer[HALL4_ADC_CYCLE_INDEX + 24]) << 3) - HALL_SENSOR_SHIFT;

    if(hall_sensor_statitics_active) {
        for(uint8_t h = 0; h < N_HALL_SENSORS; h++) {
            if(hall_sensor_readings[h] > hall_sensor_statistics.max_value[h]) {
                hall_sensor_statistics.max_value[h] = hall_sensor_readings[h];
            }
            if(hall_sensor_readings[h] < hall_sensor_statistics.min_value[h]) {
                hall_sensor_statistics.min_value[h] = hall_sensor_readings[h];
            }
            if(hall_sensor_statistics.n < 0xFFFFFFFF) {
                hall_sensor_statistics.sum[h] += hall_sensor_readings[h];
            }
        }
        if(hall_sensor_statistics.n < 0xFFFFFFFF) {
            hall_sensor_statistics.n++;
        }
    }

    adjust_hall_sensor_readings(hall_sensor_readings, d);

    if((d[0] >= d[1]) && (d[0] >= d[2])) { // check if d[0] is the highest
        largest_sensor = 0;
        numerator = d[1] - d[2];
        if(d[2] > d[1]) {
            denominator = d[0] - d[1];
        }
        else {
            denominator = d[0] - d[2];
        }
    }
    else if ((d[1] >= d[2]) && (d[1] >= d[0])) { // check if d[1] is the highest
        largest_sensor = 1;
        numerator = d[2] - d[0];
        if(d[0] > d[2]) {
            denominator = d[1] - d[2];
        }
        else {
            denominator = d[1] - d[0];
        }
    }
    else {                                    // otherwise d[2] is the highest
        largest_sensor = 2;
        numerator = d[0] - d[1];
        if(d[1] > d[0]) {
            denominator = d[2] - d[0];
        }
        else {
            denominator = d[2] - d[1];
        }
    }

    numerator >>= 10;
    denominator >>= 10;

    start_time = TIM14->CNT;
    // watch out: it seems that this division will give the wrong result if the denominator exceeds the int16_t range
    fraction = numerator * SENSOR_SEGMENT_RESOLUTION_DIV_2 / denominator;
    end_time = TIM14->CNT;
    time_difference_div = end_time - start_time;
    fraction = fraction + SENSOR_SEGMENT_RESOLUTION_DIV_2;


    if(previous_largest_sensor == -1) {
        previous_largest_sensor = largest_sensor;
    }
    if (largest_sensor != previous_largest_sensor) {
        if (largest_sensor - previous_largest_sensor == 1) {
            sensor_incremental_position = sensor_incremental_position + SENSOR_SEGMENT_RESOLUTION;
//            red_LED_on();
        }
        else if (largest_sensor - previous_largest_sensor == -1) {
            sensor_incremental_position = sensor_incremental_position - SENSOR_SEGMENT_RESOLUTION;
//            red_LED_off();
        }
        else if (largest_sensor - previous_largest_sensor == -2) {
            sensor_incremental_position = sensor_incremental_position + SENSOR_SEGMENT_RESOLUTION;
//            red_LED_on();
        }
        else {
            sensor_incremental_position = sensor_incremental_position - SENSOR_SEGMENT_RESOLUTION;
//            red_LED_off();
        }
        previous_largest_sensor = largest_sensor;
    }

    return sensor_incremental_position + fraction - hall_sensor_offset;
}


int32_t get_hall_position_with_hysteresis(void)
{
    int32_t hall_position;

    hall_position = get_hall_position();
    if(hall_position > hall_position_with_hysteresis) {
        hall_position_with_hysteresis = hall_position;
    }
    else if(hall_position + HALL_POSITION_HYSTERESIS < hall_position_with_hysteresis) {
        hall_position_with_hysteresis = hall_position + HALL_POSITION_HYSTERESIS;
    }

    return hall_position_with_hysteresis;
}


void zero_hall_position(void)
{
    previous_largest_sensor = -1;
    sensor_incremental_position = 0;
    hall_sensor_offset = 0;
    int32_t hall_position = get_hall_position();
    hall_sensor_offset = hall_position;
}


void print_hall_position(void)
{
    char buf[100];
    int32_t hall_position = get_hall_position();
    sprintf(buf, "hall_position: %d   time_difference_div: %hu\n", (int)hall_position, time_difference_div);
    transmit(buf, strlen(buf));
}


void print_hall_midlines(void)
{
    char buf[100];
    sprintf(buf, "Hall sensor midlines: %u %u %u %u\n", global_settings.hall1_midline, global_settings.hall2_midline, global_settings.hall3_midline, global_settings.hall4_midline);
    transmit(buf, strlen(buf));
}


void get_hall_sensor_statistics(hall_sensor_statistics_t *hall_sensor_statistics_output)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    memcpy(hall_sensor_statistics_output, &hall_sensor_statistics, sizeof(hall_sensor_statistics));
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}


void hall_sensor_turn_off_statistics(void)
{
    hall_sensor_statitics_active = 0;
}


void hall_sensor_turn_on_and_reset_statistics(void)
{
    TIM1->DIER &= ~TIM_DIER_UIE; // disable the update interrupt during this operation
    for(uint8_t h = 0; h < N_HALL_SENSORS; h++) {
        hall_sensor_statistics.min_value[h] = 0xFFFF;
        hall_sensor_statistics.max_value[h] = 0;
        hall_sensor_statistics.sum[h] = 0;
        hall_sensor_statistics.n = 0;
    }
    hall_sensor_statitics_active = 1;
    TIM1->DIER |= TIM_DIER_UIE; // enable the update interrupt
}
